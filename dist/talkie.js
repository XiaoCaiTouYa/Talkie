(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global.talkie = factory());
}(this, (function () { 'use strict';

  var _aFunction = function (it) {
    if (typeof it != 'function') throw TypeError(it + ' is not a function!');
    return it;
  };

  // optional / simple context binding

  var _ctx = function (fn, that, length) {
    _aFunction(fn);
    if (that === undefined) return fn;
    switch (length) {
      case 1: return function (a) {
        return fn.call(that, a);
      };
      case 2: return function (a, b) {
        return fn.call(that, a, b);
      };
      case 3: return function (a, b, c) {
        return fn.call(that, a, b, c);
      };
    }
    return function (/* ...args */) {
      return fn.apply(that, arguments);
    };
  };

  var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function unwrapExports (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var _global = createCommonjsModule(function (module) {
  // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
  var global = module.exports = typeof window != 'undefined' && window.Math == Math
    ? window : typeof self != 'undefined' && self.Math == Math ? self
    // eslint-disable-next-line no-new-func
    : Function('return this')();
  if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef
  });

  var _core = createCommonjsModule(function (module) {
  var core = module.exports = { version: '2.5.5' };
  if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef
  });
  var _core_1 = _core.version;

  var _isObject = function (it) {
    return typeof it === 'object' ? it !== null : typeof it === 'function';
  };

  var _anObject = function (it) {
    if (!_isObject(it)) throw TypeError(it + ' is not an object!');
    return it;
  };

  var _fails = function (exec) {
    try {
      return !!exec();
    } catch (e) {
      return true;
    }
  };

  // Thank's IE8 for his funny defineProperty
  var _descriptors = !_fails(function () {
    return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
  });

  var document$1 = _global.document;
  // typeof document.createElement is 'object' in old IE
  var is = _isObject(document$1) && _isObject(document$1.createElement);
  var _domCreate = function (it) {
    return is ? document$1.createElement(it) : {};
  };

  var _ie8DomDefine = !_descriptors && !_fails(function () {
    return Object.defineProperty(_domCreate('div'), 'a', { get: function () { return 7; } }).a != 7;
  });

  // 7.1.1 ToPrimitive(input [, PreferredType])

  // instead of the ES6 spec version, we didn't implement @@toPrimitive case
  // and the second argument - flag - preferred type is a string
  var _toPrimitive = function (it, S) {
    if (!_isObject(it)) return it;
    var fn, val;
    if (S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
    if (typeof (fn = it.valueOf) == 'function' && !_isObject(val = fn.call(it))) return val;
    if (!S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
    throw TypeError("Can't convert object to primitive value");
  };

  var dP = Object.defineProperty;

  var f = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes) {
    _anObject(O);
    P = _toPrimitive(P, true);
    _anObject(Attributes);
    if (_ie8DomDefine) try {
      return dP(O, P, Attributes);
    } catch (e) { /* empty */ }
    if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
    if ('value' in Attributes) O[P] = Attributes.value;
    return O;
  };

  var _objectDp = {
  	f: f
  };

  var _propertyDesc = function (bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value: value
    };
  };

  var _hide = _descriptors ? function (object, key, value) {
    return _objectDp.f(object, key, _propertyDesc(1, value));
  } : function (object, key, value) {
    object[key] = value;
    return object;
  };

  var hasOwnProperty = {}.hasOwnProperty;
  var _has = function (it, key) {
    return hasOwnProperty.call(it, key);
  };

  var id = 0;
  var px = Math.random();
  var _uid = function (key) {
    return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
  };

  var _redefine = createCommonjsModule(function (module) {
  var SRC = _uid('src');
  var TO_STRING = 'toString';
  var $toString = Function[TO_STRING];
  var TPL = ('' + $toString).split(TO_STRING);

  _core.inspectSource = function (it) {
    return $toString.call(it);
  };

  (module.exports = function (O, key, val, safe) {
    var isFunction = typeof val == 'function';
    if (isFunction) _has(val, 'name') || _hide(val, 'name', key);
    if (O[key] === val) return;
    if (isFunction) _has(val, SRC) || _hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
    if (O === _global) {
      O[key] = val;
    } else if (!safe) {
      delete O[key];
      _hide(O, key, val);
    } else if (O[key]) {
      O[key] = val;
    } else {
      _hide(O, key, val);
    }
  // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
  })(Function.prototype, TO_STRING, function toString() {
    return typeof this == 'function' && this[SRC] || $toString.call(this);
  });
  });

  var PROTOTYPE = 'prototype';

  var $export = function (type, name, source) {
    var IS_FORCED = type & $export.F;
    var IS_GLOBAL = type & $export.G;
    var IS_STATIC = type & $export.S;
    var IS_PROTO = type & $export.P;
    var IS_BIND = type & $export.B;
    var target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] || (_global[name] = {}) : (_global[name] || {})[PROTOTYPE];
    var exports = IS_GLOBAL ? _core : _core[name] || (_core[name] = {});
    var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
    var key, own, out, exp;
    if (IS_GLOBAL) source = name;
    for (key in source) {
      // contains in native
      own = !IS_FORCED && target && target[key] !== undefined;
      // export native or passed
      out = (own ? target : source)[key];
      // bind timers to global for call from export context
      exp = IS_BIND && own ? _ctx(out, _global) : IS_PROTO && typeof out == 'function' ? _ctx(Function.call, out) : out;
      // extend global
      if (target) _redefine(target, key, out, type & $export.U);
      // export
      if (exports[key] != out) _hide(exports, key, exp);
      if (IS_PROTO && expProto[key] != out) expProto[key] = out;
    }
  };
  _global.core = _core;
  // type bitmap
  $export.F = 1;   // forced
  $export.G = 2;   // global
  $export.S = 4;   // static
  $export.P = 8;   // proto
  $export.B = 16;  // bind
  $export.W = 32;  // wrap
  $export.U = 64;  // safe
  $export.R = 128; // real proto method for `library`
  var _export = $export;

  // 7.2.1 RequireObjectCoercible(argument)
  var _defined = function (it) {
    if (it == undefined) throw TypeError("Can't call method on  " + it);
    return it;
  };

  // 7.1.13 ToObject(argument)

  var _toObject = function (it) {
    return Object(_defined(it));
  };

  // call something on iterator step with safe closing on error

  var _iterCall = function (iterator, fn, value, entries) {
    try {
      return entries ? fn(_anObject(value)[0], value[1]) : fn(value);
    // 7.4.6 IteratorClose(iterator, completion)
    } catch (e) {
      var ret = iterator['return'];
      if (ret !== undefined) _anObject(ret.call(iterator));
      throw e;
    }
  };

  var _iterators = {};

  var SHARED = '__core-js_shared__';
  var store = _global[SHARED] || (_global[SHARED] = {});
  var _shared = function (key) {
    return store[key] || (store[key] = {});
  };

  var _wks = createCommonjsModule(function (module) {
  var store = _shared('wks');

  var Symbol = _global.Symbol;
  var USE_SYMBOL = typeof Symbol == 'function';

  var $exports = module.exports = function (name) {
    return store[name] || (store[name] =
      USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : _uid)('Symbol.' + name));
  };

  $exports.store = store;
  });

  // check on default Array iterator

  var ITERATOR = _wks('iterator');
  var ArrayProto = Array.prototype;

  var _isArrayIter = function (it) {
    return it !== undefined && (_iterators.Array === it || ArrayProto[ITERATOR] === it);
  };

  // 7.1.4 ToInteger
  var ceil = Math.ceil;
  var floor = Math.floor;
  var _toInteger = function (it) {
    return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
  };

  // 7.1.15 ToLength

  var min = Math.min;
  var _toLength = function (it) {
    return it > 0 ? min(_toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
  };

  var _createProperty = function (object, index, value) {
    if (index in object) _objectDp.f(object, index, _propertyDesc(0, value));
    else object[index] = value;
  };

  var toString = {}.toString;

  var _cof = function (it) {
    return toString.call(it).slice(8, -1);
  };

  // getting tag from 19.1.3.6 Object.prototype.toString()

  var TAG = _wks('toStringTag');
  // ES3 wrong here
  var ARG = _cof(function () { return arguments; }()) == 'Arguments';

  // fallback for IE11 Script Access Denied error
  var tryGet = function (it, key) {
    try {
      return it[key];
    } catch (e) { /* empty */ }
  };

  var _classof = function (it) {
    var O, T, B;
    return it === undefined ? 'Undefined' : it === null ? 'Null'
      // @@toStringTag case
      : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
      // builtinTag case
      : ARG ? _cof(O)
      // ES3 arguments fallback
      : (B = _cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
  };

  var ITERATOR$1 = _wks('iterator');

  var core_getIteratorMethod = _core.getIteratorMethod = function (it) {
    if (it != undefined) return it[ITERATOR$1]
      || it['@@iterator']
      || _iterators[_classof(it)];
  };

  var ITERATOR$2 = _wks('iterator');
  var SAFE_CLOSING = false;

  try {
    var riter = [7][ITERATOR$2]();
    riter['return'] = function () { SAFE_CLOSING = true; };
  } catch (e) { /* empty */ }

  var _iterDetect = function (exec, skipClosing) {
    if (!skipClosing && !SAFE_CLOSING) return false;
    var safe = false;
    try {
      var arr = [7];
      var iter = arr[ITERATOR$2]();
      iter.next = function () { return { done: safe = true }; };
      arr[ITERATOR$2] = function () { return iter; };
      exec(arr);
    } catch (e) { /* empty */ }
    return safe;
  };

  _export(_export.S + _export.F * !_iterDetect(function (iter) { }), 'Array', {
    // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
    from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
      var O = _toObject(arrayLike);
      var C = typeof this == 'function' ? this : Array;
      var aLen = arguments.length;
      var mapfn = aLen > 1 ? arguments[1] : undefined;
      var mapping = mapfn !== undefined;
      var index = 0;
      var iterFn = core_getIteratorMethod(O);
      var length, result, step, iterator;
      if (mapping) mapfn = _ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
      // if object isn't iterable or it's array with default iterator - use simple case
      if (iterFn != undefined && !(C == Array && _isArrayIter(iterFn))) {
        for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
          _createProperty(result, index, mapping ? _iterCall(iterator, mapfn, [step.value, index], true) : step.value);
        }
      } else {
        length = _toLength(O.length);
        for (result = new C(length); length > index; index++) {
          _createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
        }
      }
      result.length = index;
      return result;
    }
  });

  // 22.1.3.31 Array.prototype[@@unscopables]
  var UNSCOPABLES = _wks('unscopables');
  var ArrayProto$1 = Array.prototype;
  if (ArrayProto$1[UNSCOPABLES] == undefined) _hide(ArrayProto$1, UNSCOPABLES, {});
  var _addToUnscopables = function (key) {
    ArrayProto$1[UNSCOPABLES][key] = true;
  };

  var _iterStep = function (done, value) {
    return { value: value, done: !!done };
  };

  // fallback for non-array-like ES3 and non-enumerable old V8 strings

  // eslint-disable-next-line no-prototype-builtins
  var _iobject = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
    return _cof(it) == 'String' ? it.split('') : Object(it);
  };

  // to indexed object, toObject with fallback for non-array-like ES3 strings


  var _toIobject = function (it) {
    return _iobject(_defined(it));
  };

  var _library = false;

  var max = Math.max;
  var min$1 = Math.min;
  var _toAbsoluteIndex = function (index, length) {
    index = _toInteger(index);
    return index < 0 ? max(index + length, 0) : min$1(index, length);
  };

  // false -> Array#indexOf
  // true  -> Array#includes



  var _arrayIncludes = function (IS_INCLUDES) {
    return function ($this, el, fromIndex) {
      var O = _toIobject($this);
      var length = _toLength(O.length);
      var index = _toAbsoluteIndex(fromIndex, length);
      var value;
      // Array#includes uses SameValueZero equality algorithm
      // eslint-disable-next-line no-self-compare
      if (IS_INCLUDES && el != el) while (length > index) {
        value = O[index++];
        // eslint-disable-next-line no-self-compare
        if (value != value) return true;
      // Array#indexOf ignores holes, Array#includes - not
      } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
        if (O[index] === el) return IS_INCLUDES || index || 0;
      } return !IS_INCLUDES && -1;
    };
  };

  var shared = _shared('keys');

  var _sharedKey = function (key) {
    return shared[key] || (shared[key] = _uid(key));
  };

  var arrayIndexOf = _arrayIncludes(false);
  var IE_PROTO = _sharedKey('IE_PROTO');

  var _objectKeysInternal = function (object, names) {
    var O = _toIobject(object);
    var i = 0;
    var result = [];
    var key;
    for (key in O) if (key != IE_PROTO) _has(O, key) && result.push(key);
    // Don't enum bug & hidden keys
    while (names.length > i) if (_has(O, key = names[i++])) {
      ~arrayIndexOf(result, key) || result.push(key);
    }
    return result;
  };

  // IE 8- don't enum bug keys
  var _enumBugKeys = (
    'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
  ).split(',');

  // 19.1.2.14 / 15.2.3.14 Object.keys(O)



  var _objectKeys = Object.keys || function keys(O) {
    return _objectKeysInternal(O, _enumBugKeys);
  };

  var _objectDps = _descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
    _anObject(O);
    var keys = _objectKeys(Properties);
    var length = keys.length;
    var i = 0;
    var P;
    while (length > i) _objectDp.f(O, P = keys[i++], Properties[P]);
    return O;
  };

  var document$2 = _global.document;
  var _html = document$2 && document$2.documentElement;

  // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])



  var IE_PROTO$1 = _sharedKey('IE_PROTO');
  var Empty = function () { /* empty */ };
  var PROTOTYPE$1 = 'prototype';

  // Create object with fake `null` prototype: use iframe Object with cleared prototype
  var createDict = function () {
    // Thrash, waste and sodomy: IE GC bug
    var iframe = _domCreate('iframe');
    var i = _enumBugKeys.length;
    var lt = '<';
    var gt = '>';
    var iframeDocument;
    iframe.style.display = 'none';
    _html.appendChild(iframe);
    iframe.src = 'javascript:'; // eslint-disable-line no-script-url
    // createDict = iframe.contentWindow.Object;
    // html.removeChild(iframe);
    iframeDocument = iframe.contentWindow.document;
    iframeDocument.open();
    iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
    iframeDocument.close();
    createDict = iframeDocument.F;
    while (i--) delete createDict[PROTOTYPE$1][_enumBugKeys[i]];
    return createDict();
  };

  var _objectCreate = Object.create || function create(O, Properties) {
    var result;
    if (O !== null) {
      Empty[PROTOTYPE$1] = _anObject(O);
      result = new Empty();
      Empty[PROTOTYPE$1] = null;
      // add "__proto__" for Object.getPrototypeOf polyfill
      result[IE_PROTO$1] = O;
    } else result = createDict();
    return Properties === undefined ? result : _objectDps(result, Properties);
  };

  var def = _objectDp.f;

  var TAG$1 = _wks('toStringTag');

  var _setToStringTag = function (it, tag, stat) {
    if (it && !_has(it = stat ? it : it.prototype, TAG$1)) def(it, TAG$1, { configurable: true, value: tag });
  };

  var IteratorPrototype = {};

  // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
  _hide(IteratorPrototype, _wks('iterator'), function () { return this; });

  var _iterCreate = function (Constructor, NAME, next) {
    Constructor.prototype = _objectCreate(IteratorPrototype, { next: _propertyDesc(1, next) });
    _setToStringTag(Constructor, NAME + ' Iterator');
  };

  // 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)


  var IE_PROTO$2 = _sharedKey('IE_PROTO');
  var ObjectProto = Object.prototype;

  var _objectGpo = Object.getPrototypeOf || function (O) {
    O = _toObject(O);
    if (_has(O, IE_PROTO$2)) return O[IE_PROTO$2];
    if (typeof O.constructor == 'function' && O instanceof O.constructor) {
      return O.constructor.prototype;
    } return O instanceof Object ? ObjectProto : null;
  };

  var ITERATOR$3 = _wks('iterator');
  var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
  var FF_ITERATOR = '@@iterator';
  var KEYS = 'keys';
  var VALUES = 'values';

  var returnThis = function () { return this; };

  var _iterDefine = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
    _iterCreate(Constructor, NAME, next);
    var getMethod = function (kind) {
      if (!BUGGY && kind in proto) return proto[kind];
      switch (kind) {
        case KEYS: return function keys() { return new Constructor(this, kind); };
        case VALUES: return function values() { return new Constructor(this, kind); };
      } return function entries() { return new Constructor(this, kind); };
    };
    var TAG = NAME + ' Iterator';
    var DEF_VALUES = DEFAULT == VALUES;
    var VALUES_BUG = false;
    var proto = Base.prototype;
    var $native = proto[ITERATOR$3] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
    var $default = $native || getMethod(DEFAULT);
    var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
    var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
    var methods, key, IteratorPrototype;
    // Fix native
    if ($anyNative) {
      IteratorPrototype = _objectGpo($anyNative.call(new Base()));
      if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
        // Set @@toStringTag to native iterators
        _setToStringTag(IteratorPrototype, TAG, true);
        // fix for some old engines
        if (!_library && typeof IteratorPrototype[ITERATOR$3] != 'function') _hide(IteratorPrototype, ITERATOR$3, returnThis);
      }
    }
    // fix Array#{values, @@iterator}.name in V8 / FF
    if (DEF_VALUES && $native && $native.name !== VALUES) {
      VALUES_BUG = true;
      $default = function values() { return $native.call(this); };
    }
    // Define iterator
    if ((!_library || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR$3])) {
      _hide(proto, ITERATOR$3, $default);
    }
    // Plug for library
    _iterators[NAME] = $default;
    _iterators[TAG] = returnThis;
    if (DEFAULT) {
      methods = {
        values: DEF_VALUES ? $default : getMethod(VALUES),
        keys: IS_SET ? $default : getMethod(KEYS),
        entries: $entries
      };
      if (FORCED) for (key in methods) {
        if (!(key in proto)) _redefine(proto, key, methods[key]);
      } else _export(_export.P + _export.F * (BUGGY || VALUES_BUG), NAME, methods);
    }
    return methods;
  };

  // 22.1.3.4 Array.prototype.entries()
  // 22.1.3.13 Array.prototype.keys()
  // 22.1.3.29 Array.prototype.values()
  // 22.1.3.30 Array.prototype[@@iterator]()
  var es6_array_iterator = _iterDefine(Array, 'Array', function (iterated, kind) {
    this._t = _toIobject(iterated); // target
    this._i = 0;                   // next index
    this._k = kind;                // kind
  // 22.1.5.2.1 %ArrayIteratorPrototype%.next()
  }, function () {
    var O = this._t;
    var kind = this._k;
    var index = this._i++;
    if (!O || index >= O.length) {
      this._t = undefined;
      return _iterStep(1);
    }
    if (kind == 'keys') return _iterStep(0, index);
    if (kind == 'values') return _iterStep(0, O[index]);
    return _iterStep(0, [index, O[index]]);
  }, 'values');

  // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
  _iterators.Arguments = _iterators.Array;

  _addToUnscopables('keys');
  _addToUnscopables('values');
  _addToUnscopables('entries');

  var ITERATOR$4 = _wks('iterator');
  var TO_STRING_TAG = _wks('toStringTag');
  var ArrayValues = _iterators.Array;

  var DOMIterables = {
    CSSRuleList: true, // TODO: Not spec compliant, should be false.
    CSSStyleDeclaration: false,
    CSSValueList: false,
    ClientRectList: false,
    DOMRectList: false,
    DOMStringList: false,
    DOMTokenList: true,
    DataTransferItemList: false,
    FileList: false,
    HTMLAllCollection: false,
    HTMLCollection: false,
    HTMLFormElement: false,
    HTMLSelectElement: false,
    MediaList: true, // TODO: Not spec compliant, should be false.
    MimeTypeArray: false,
    NamedNodeMap: false,
    NodeList: true,
    PaintRequestList: false,
    Plugin: false,
    PluginArray: false,
    SVGLengthList: false,
    SVGNumberList: false,
    SVGPathSegList: false,
    SVGPointList: false,
    SVGStringList: false,
    SVGTransformList: false,
    SourceBufferList: false,
    StyleSheetList: true, // TODO: Not spec compliant, should be false.
    TextTrackCueList: false,
    TextTrackList: false,
    TouchList: false
  };

  for (var collections = _objectKeys(DOMIterables), i = 0; i < collections.length; i++) {
    var NAME = collections[i];
    var explicit = DOMIterables[NAME];
    var Collection = _global[NAME];
    var proto = Collection && Collection.prototype;
    var key;
    if (proto) {
      if (!proto[ITERATOR$4]) _hide(proto, ITERATOR$4, ArrayValues);
      if (!proto[TO_STRING_TAG]) _hide(proto, TO_STRING_TAG, NAME);
      _iterators[NAME] = ArrayValues;
      if (explicit) for (key in es6_array_iterator) if (!proto[key]) _redefine(proto, key, es6_array_iterator[key], true);
    }
  }

  var f$1 = _wks;

  var _wksExt = {
  	f: f$1
  };

  var defineProperty = _objectDp.f;
  var _wksDefine = function (name) {
    var $Symbol = _core.Symbol || (_core.Symbol = _library ? {} : _global.Symbol || {});
    if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: _wksExt.f(name) });
  };

  _wksDefine('asyncIterator');

  var _meta = createCommonjsModule(function (module) {
  var META = _uid('meta');


  var setDesc = _objectDp.f;
  var id = 0;
  var isExtensible = Object.isExtensible || function () {
    return true;
  };
  var FREEZE = !_fails(function () {
    return isExtensible(Object.preventExtensions({}));
  });
  var setMeta = function (it) {
    setDesc(it, META, { value: {
      i: 'O' + ++id, // object ID
      w: {}          // weak collections IDs
    } });
  };
  var fastKey = function (it, create) {
    // return primitive with prefix
    if (!_isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
    if (!_has(it, META)) {
      // can't set metadata to uncaught frozen object
      if (!isExtensible(it)) return 'F';
      // not necessary to add metadata
      if (!create) return 'E';
      // add missing metadata
      setMeta(it);
    // return object ID
    } return it[META].i;
  };
  var getWeak = function (it, create) {
    if (!_has(it, META)) {
      // can't set metadata to uncaught frozen object
      if (!isExtensible(it)) return true;
      // not necessary to add metadata
      if (!create) return false;
      // add missing metadata
      setMeta(it);
    // return hash weak collections IDs
    } return it[META].w;
  };
  // add metadata on freeze-family methods calling
  var onFreeze = function (it) {
    if (FREEZE && meta.NEED && isExtensible(it) && !_has(it, META)) setMeta(it);
    return it;
  };
  var meta = module.exports = {
    KEY: META,
    NEED: false,
    fastKey: fastKey,
    getWeak: getWeak,
    onFreeze: onFreeze
  };
  });
  var _meta_1 = _meta.KEY;
  var _meta_2 = _meta.NEED;
  var _meta_3 = _meta.fastKey;
  var _meta_4 = _meta.getWeak;
  var _meta_5 = _meta.onFreeze;

  var f$2 = Object.getOwnPropertySymbols;

  var _objectGops = {
  	f: f$2
  };

  var f$3 = {}.propertyIsEnumerable;

  var _objectPie = {
  	f: f$3
  };

  // all enumerable object keys, includes symbols



  var _enumKeys = function (it) {
    var result = _objectKeys(it);
    var getSymbols = _objectGops.f;
    if (getSymbols) {
      var symbols = getSymbols(it);
      var isEnum = _objectPie.f;
      var i = 0;
      var key;
      while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
    } return result;
  };

  // 7.2.2 IsArray(argument)

  var _isArray = Array.isArray || function isArray(arg) {
    return _cof(arg) == 'Array';
  };

  // 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)

  var hiddenKeys = _enumBugKeys.concat('length', 'prototype');

  var f$4 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
    return _objectKeysInternal(O, hiddenKeys);
  };

  var _objectGopn = {
  	f: f$4
  };

  // fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window

  var gOPN = _objectGopn.f;
  var toString$1 = {}.toString;

  var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
    ? Object.getOwnPropertyNames(window) : [];

  var getWindowNames = function (it) {
    try {
      return gOPN(it);
    } catch (e) {
      return windowNames.slice();
    }
  };

  var f$5 = function getOwnPropertyNames(it) {
    return windowNames && toString$1.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(_toIobject(it));
  };

  var _objectGopnExt = {
  	f: f$5
  };

  var gOPD = Object.getOwnPropertyDescriptor;

  var f$6 = _descriptors ? gOPD : function getOwnPropertyDescriptor(O, P) {
    O = _toIobject(O);
    P = _toPrimitive(P, true);
    if (_ie8DomDefine) try {
      return gOPD(O, P);
    } catch (e) { /* empty */ }
    if (_has(O, P)) return _propertyDesc(!_objectPie.f.call(O, P), O[P]);
  };

  var _objectGopd = {
  	f: f$6
  };

  // ECMAScript 6 symbols shim





  var META = _meta.KEY;



















  var gOPD$1 = _objectGopd.f;
  var dP$1 = _objectDp.f;
  var gOPN$1 = _objectGopnExt.f;
  var $Symbol = _global.Symbol;
  var $JSON = _global.JSON;
  var _stringify = $JSON && $JSON.stringify;
  var PROTOTYPE$2 = 'prototype';
  var HIDDEN = _wks('_hidden');
  var TO_PRIMITIVE = _wks('toPrimitive');
  var isEnum = {}.propertyIsEnumerable;
  var SymbolRegistry = _shared('symbol-registry');
  var AllSymbols = _shared('symbols');
  var OPSymbols = _shared('op-symbols');
  var ObjectProto$1 = Object[PROTOTYPE$2];
  var USE_NATIVE = typeof $Symbol == 'function';
  var QObject = _global.QObject;
  // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
  var setter = !QObject || !QObject[PROTOTYPE$2] || !QObject[PROTOTYPE$2].findChild;

  // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
  var setSymbolDesc = _descriptors && _fails(function () {
    return _objectCreate(dP$1({}, 'a', {
      get: function () { return dP$1(this, 'a', { value: 7 }).a; }
    })).a != 7;
  }) ? function (it, key, D) {
    var protoDesc = gOPD$1(ObjectProto$1, key);
    if (protoDesc) delete ObjectProto$1[key];
    dP$1(it, key, D);
    if (protoDesc && it !== ObjectProto$1) dP$1(ObjectProto$1, key, protoDesc);
  } : dP$1;

  var wrap = function (tag) {
    var sym = AllSymbols[tag] = _objectCreate($Symbol[PROTOTYPE$2]);
    sym._k = tag;
    return sym;
  };

  var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
    return typeof it == 'symbol';
  } : function (it) {
    return it instanceof $Symbol;
  };

  var $defineProperty = function defineProperty(it, key, D) {
    if (it === ObjectProto$1) $defineProperty(OPSymbols, key, D);
    _anObject(it);
    key = _toPrimitive(key, true);
    _anObject(D);
    if (_has(AllSymbols, key)) {
      if (!D.enumerable) {
        if (!_has(it, HIDDEN)) dP$1(it, HIDDEN, _propertyDesc(1, {}));
        it[HIDDEN][key] = true;
      } else {
        if (_has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
        D = _objectCreate(D, { enumerable: _propertyDesc(0, false) });
      } return setSymbolDesc(it, key, D);
    } return dP$1(it, key, D);
  };
  var $defineProperties = function defineProperties(it, P) {
    _anObject(it);
    var keys = _enumKeys(P = _toIobject(P));
    var i = 0;
    var l = keys.length;
    var key;
    while (l > i) $defineProperty(it, key = keys[i++], P[key]);
    return it;
  };
  var $create = function create(it, P) {
    return P === undefined ? _objectCreate(it) : $defineProperties(_objectCreate(it), P);
  };
  var $propertyIsEnumerable = function propertyIsEnumerable(key) {
    var E = isEnum.call(this, key = _toPrimitive(key, true));
    if (this === ObjectProto$1 && _has(AllSymbols, key) && !_has(OPSymbols, key)) return false;
    return E || !_has(this, key) || !_has(AllSymbols, key) || _has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
  };
  var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
    it = _toIobject(it);
    key = _toPrimitive(key, true);
    if (it === ObjectProto$1 && _has(AllSymbols, key) && !_has(OPSymbols, key)) return;
    var D = gOPD$1(it, key);
    if (D && _has(AllSymbols, key) && !(_has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
    return D;
  };
  var $getOwnPropertyNames = function getOwnPropertyNames(it) {
    var names = gOPN$1(_toIobject(it));
    var result = [];
    var i = 0;
    var key;
    while (names.length > i) {
      if (!_has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
    } return result;
  };
  var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
    var IS_OP = it === ObjectProto$1;
    var names = gOPN$1(IS_OP ? OPSymbols : _toIobject(it));
    var result = [];
    var i = 0;
    var key;
    while (names.length > i) {
      if (_has(AllSymbols, key = names[i++]) && (IS_OP ? _has(ObjectProto$1, key) : true)) result.push(AllSymbols[key]);
    } return result;
  };

  // 19.4.1.1 Symbol([description])
  if (!USE_NATIVE) {
    $Symbol = function Symbol() {
      if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
      var tag = _uid(arguments.length > 0 ? arguments[0] : undefined);
      var $set = function (value) {
        if (this === ObjectProto$1) $set.call(OPSymbols, value);
        if (_has(this, HIDDEN) && _has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
        setSymbolDesc(this, tag, _propertyDesc(1, value));
      };
      if (_descriptors && setter) setSymbolDesc(ObjectProto$1, tag, { configurable: true, set: $set });
      return wrap(tag);
    };
    _redefine($Symbol[PROTOTYPE$2], 'toString', function toString() {
      return this._k;
    });

    _objectGopd.f = $getOwnPropertyDescriptor;
    _objectDp.f = $defineProperty;
    _objectGopn.f = _objectGopnExt.f = $getOwnPropertyNames;
    _objectPie.f = $propertyIsEnumerable;
    _objectGops.f = $getOwnPropertySymbols;

    if (_descriptors && !_library) {
      _redefine(ObjectProto$1, 'propertyIsEnumerable', $propertyIsEnumerable, true);
    }

    _wksExt.f = function (name) {
      return wrap(_wks(name));
    };
  }

  _export(_export.G + _export.W + _export.F * !USE_NATIVE, { Symbol: $Symbol });

  for (var es6Symbols = (
    // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
    'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
  ).split(','), j = 0; es6Symbols.length > j;)_wks(es6Symbols[j++]);

  for (var wellKnownSymbols = _objectKeys(_wks.store), k = 0; wellKnownSymbols.length > k;) _wksDefine(wellKnownSymbols[k++]);

  _export(_export.S + _export.F * !USE_NATIVE, 'Symbol', {
    // 19.4.2.1 Symbol.for(key)
    'for': function (key) {
      return _has(SymbolRegistry, key += '')
        ? SymbolRegistry[key]
        : SymbolRegistry[key] = $Symbol(key);
    },
    // 19.4.2.5 Symbol.keyFor(sym)
    keyFor: function keyFor(sym) {
      if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
      for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
    },
    useSetter: function () { setter = true; },
    useSimple: function () { setter = false; }
  });

  _export(_export.S + _export.F * !USE_NATIVE, 'Object', {
    // 19.1.2.2 Object.create(O [, Properties])
    create: $create,
    // 19.1.2.4 Object.defineProperty(O, P, Attributes)
    defineProperty: $defineProperty,
    // 19.1.2.3 Object.defineProperties(O, Properties)
    defineProperties: $defineProperties,
    // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
    getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
    // 19.1.2.7 Object.getOwnPropertyNames(O)
    getOwnPropertyNames: $getOwnPropertyNames,
    // 19.1.2.8 Object.getOwnPropertySymbols(O)
    getOwnPropertySymbols: $getOwnPropertySymbols
  });

  // 24.3.2 JSON.stringify(value [, replacer [, space]])
  $JSON && _export(_export.S + _export.F * (!USE_NATIVE || _fails(function () {
    var S = $Symbol();
    // MS Edge converts symbol values to JSON as {}
    // WebKit converts symbol values to JSON as null
    // V8 throws on boxed symbols
    return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
  })), 'JSON', {
    stringify: function stringify(it) {
      var args = [it];
      var i = 1;
      var replacer, $replacer;
      while (arguments.length > i) args.push(arguments[i++]);
      $replacer = replacer = args[1];
      if (!_isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
      if (!_isArray(replacer)) replacer = function (key, value) {
        if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
        if (!isSymbol(value)) return value;
      };
      args[1] = replacer;
      return _stringify.apply($JSON, args);
    }
  });

  // 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
  $Symbol[PROTOTYPE$2][TO_PRIMITIVE] || _hide($Symbol[PROTOTYPE$2], TO_PRIMITIVE, $Symbol[PROTOTYPE$2].valueOf);
  // 19.4.3.5 Symbol.prototype[@@toStringTag]
  _setToStringTag($Symbol, 'Symbol');
  // 20.2.1.9 Math[@@toStringTag]
  _setToStringTag(Math, 'Math', true);
  // 24.3.3 JSON[@@toStringTag]
  _setToStringTag(_global.JSON, 'JSON', true);

  var _anInstance = function (it, Constructor, name, forbiddenField) {
    if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
      throw TypeError(name + ': incorrect invocation!');
    } return it;
  };

  var _forOf = createCommonjsModule(function (module) {
  var BREAK = {};
  var RETURN = {};
  var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
    var iterFn = ITERATOR ? function () { return iterable; } : core_getIteratorMethod(iterable);
    var f = _ctx(fn, that, entries ? 2 : 1);
    var index = 0;
    var length, step, iterator, result;
    if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
    // fast case for arrays with default iterator
    if (_isArrayIter(iterFn)) for (length = _toLength(iterable.length); length > index; index++) {
      result = entries ? f(_anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
      if (result === BREAK || result === RETURN) return result;
    } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
      result = _iterCall(iterator, f, step.value, entries);
      if (result === BREAK || result === RETURN) return result;
    }
  };
  exports.BREAK = BREAK;
  exports.RETURN = RETURN;
  });

  // 7.3.20 SpeciesConstructor(O, defaultConstructor)


  var SPECIES = _wks('species');
  var _speciesConstructor = function (O, D) {
    var C = _anObject(O).constructor;
    var S;
    return C === undefined || (S = _anObject(C)[SPECIES]) == undefined ? D : _aFunction(S);
  };

  // fast apply, http://jsperf.lnkit.com/fast-apply/5
  var _invoke = function (fn, args, that) {
    var un = that === undefined;
    switch (args.length) {
      case 0: return un ? fn()
                        : fn.call(that);
      case 1: return un ? fn(args[0])
                        : fn.call(that, args[0]);
      case 2: return un ? fn(args[0], args[1])
                        : fn.call(that, args[0], args[1]);
      case 3: return un ? fn(args[0], args[1], args[2])
                        : fn.call(that, args[0], args[1], args[2]);
      case 4: return un ? fn(args[0], args[1], args[2], args[3])
                        : fn.call(that, args[0], args[1], args[2], args[3]);
    } return fn.apply(that, args);
  };

  var process = _global.process;
  var setTask = _global.setImmediate;
  var clearTask = _global.clearImmediate;
  var MessageChannel = _global.MessageChannel;
  var Dispatch = _global.Dispatch;
  var counter = 0;
  var queue = {};
  var ONREADYSTATECHANGE = 'onreadystatechange';
  var defer, channel, port;
  var run = function () {
    var id = +this;
    // eslint-disable-next-line no-prototype-builtins
    if (queue.hasOwnProperty(id)) {
      var fn = queue[id];
      delete queue[id];
      fn();
    }
  };
  var listener = function (event) {
    run.call(event.data);
  };
  // Node.js 0.9+ & IE10+ has setImmediate, otherwise:
  if (!setTask || !clearTask) {
    setTask = function setImmediate(fn) {
      var args = [];
      var i = 1;
      while (arguments.length > i) args.push(arguments[i++]);
      queue[++counter] = function () {
        // eslint-disable-next-line no-new-func
        _invoke(typeof fn == 'function' ? fn : Function(fn), args);
      };
      defer(counter);
      return counter;
    };
    clearTask = function clearImmediate(id) {
      delete queue[id];
    };
    // Node.js 0.8-
    if (_cof(process) == 'process') {
      defer = function (id) {
        process.nextTick(_ctx(run, id, 1));
      };
    // Sphere (JS game engine) Dispatch API
    } else if (Dispatch && Dispatch.now) {
      defer = function (id) {
        Dispatch.now(_ctx(run, id, 1));
      };
    // Browsers with MessageChannel, includes WebWorkers
    } else if (MessageChannel) {
      channel = new MessageChannel();
      port = channel.port2;
      channel.port1.onmessage = listener;
      defer = _ctx(port.postMessage, port, 1);
    // Browsers with postMessage, skip WebWorkers
    // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
    } else if (_global.addEventListener && typeof postMessage == 'function' && !_global.importScripts) {
      defer = function (id) {
        _global.postMessage(id + '', '*');
      };
      _global.addEventListener('message', listener, false);
    // IE8-
    } else if (ONREADYSTATECHANGE in _domCreate('script')) {
      defer = function (id) {
        _html.appendChild(_domCreate('script'))[ONREADYSTATECHANGE] = function () {
          _html.removeChild(this);
          run.call(id);
        };
      };
    // Rest old browsers
    } else {
      defer = function (id) {
        setTimeout(_ctx(run, id, 1), 0);
      };
    }
  }
  var _task = {
    set: setTask,
    clear: clearTask
  };

  var macrotask = _task.set;
  var Observer = _global.MutationObserver || _global.WebKitMutationObserver;
  var process$1 = _global.process;
  var Promise$1 = _global.Promise;
  var isNode = _cof(process$1) == 'process';

  var _microtask = function () {
    var head, last, notify;

    var flush = function () {
      var parent, fn;
      if (isNode && (parent = process$1.domain)) parent.exit();
      while (head) {
        fn = head.fn;
        head = head.next;
        try {
          fn();
        } catch (e) {
          if (head) notify();
          else last = undefined;
          throw e;
        }
      } last = undefined;
      if (parent) parent.enter();
    };

    // Node.js
    if (isNode) {
      notify = function () {
        process$1.nextTick(flush);
      };
    // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
    } else if (Observer && !(_global.navigator && _global.navigator.standalone)) {
      var toggle = true;
      var node = document.createTextNode('');
      new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
      notify = function () {
        node.data = toggle = !toggle;
      };
    // environments with maybe non-completely correct, but existent Promise
    } else if (Promise$1 && Promise$1.resolve) {
      var promise = Promise$1.resolve();
      notify = function () {
        promise.then(flush);
      };
    // for other environments - macrotask based on:
    // - setImmediate
    // - MessageChannel
    // - window.postMessag
    // - onreadystatechange
    // - setTimeout
    } else {
      notify = function () {
        // strange IE + webpack dev server bug - use .call(global)
        macrotask.call(_global, flush);
      };
    }

    return function (fn) {
      var task = { fn: fn, next: undefined };
      if (last) last.next = task;
      if (!head) {
        head = task;
        notify();
      } last = task;
    };
  };

  // 25.4.1.5 NewPromiseCapability(C)


  function PromiseCapability(C) {
    var resolve, reject;
    this.promise = new C(function ($$resolve, $$reject) {
      if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
      resolve = $$resolve;
      reject = $$reject;
    });
    this.resolve = _aFunction(resolve);
    this.reject = _aFunction(reject);
  }

  var f$7 = function (C) {
    return new PromiseCapability(C);
  };

  var _newPromiseCapability = {
  	f: f$7
  };

  var _perform = function (exec) {
    try {
      return { e: false, v: exec() };
    } catch (e) {
      return { e: true, v: e };
    }
  };

  var _promiseResolve = function (C, x) {
    _anObject(C);
    if (_isObject(x) && x.constructor === C) return x;
    var promiseCapability = _newPromiseCapability.f(C);
    var resolve = promiseCapability.resolve;
    resolve(x);
    return promiseCapability.promise;
  };

  var _redefineAll = function (target, src, safe) {
    for (var key in src) _redefine(target, key, src[key], safe);
    return target;
  };

  var SPECIES$1 = _wks('species');

  var _setSpecies = function (KEY) {
    var C = _global[KEY];
    if (_descriptors && C && !C[SPECIES$1]) _objectDp.f(C, SPECIES$1, {
      configurable: true,
      get: function () { return this; }
    });
  };

  var task = _task.set;
  var microtask = _microtask();



  var PROMISE = 'Promise';
  var TypeError$1 = _global.TypeError;
  var process$2 = _global.process;
  var $Promise = _global[PROMISE];
  var isNode$1 = _classof(process$2) == 'process';
  var empty = function () { /* empty */ };
  var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
  var newPromiseCapability = newGenericPromiseCapability = _newPromiseCapability.f;

  var USE_NATIVE$1 = !!function () {
    try {
      // correct subclassing with @@species support
      var promise = $Promise.resolve(1);
      var FakePromise = (promise.constructor = {})[_wks('species')] = function (exec) {
        exec(empty, empty);
      };
      // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
      return (isNode$1 || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
    } catch (e) { /* empty */ }
  }();

  // helpers
  var isThenable = function (it) {
    var then;
    return _isObject(it) && typeof (then = it.then) == 'function' ? then : false;
  };
  var notify = function (promise, isReject) {
    if (promise._n) return;
    promise._n = true;
    var chain = promise._c;
    microtask(function () {
      var value = promise._v;
      var ok = promise._s == 1;
      var i = 0;
      var run = function (reaction) {
        var handler = ok ? reaction.ok : reaction.fail;
        var resolve = reaction.resolve;
        var reject = reaction.reject;
        var domain = reaction.domain;
        var result, then, exited;
        try {
          if (handler) {
            if (!ok) {
              if (promise._h == 2) onHandleUnhandled(promise);
              promise._h = 1;
            }
            if (handler === true) result = value;
            else {
              if (domain) domain.enter();
              result = handler(value); // may throw
              if (domain) {
                domain.exit();
                exited = true;
              }
            }
            if (result === reaction.promise) {
              reject(TypeError$1('Promise-chain cycle'));
            } else if (then = isThenable(result)) {
              then.call(result, resolve, reject);
            } else resolve(result);
          } else reject(value);
        } catch (e) {
          if (domain && !exited) domain.exit();
          reject(e);
        }
      };
      while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
      promise._c = [];
      promise._n = false;
      if (isReject && !promise._h) onUnhandled(promise);
    });
  };
  var onUnhandled = function (promise) {
    task.call(_global, function () {
      var value = promise._v;
      var unhandled = isUnhandled(promise);
      var result, handler, console;
      if (unhandled) {
        result = _perform(function () {
          if (isNode$1) {
            process$2.emit('unhandledRejection', value, promise);
          } else if (handler = _global.onunhandledrejection) {
            handler({ promise: promise, reason: value });
          } else if ((console = _global.console) && console.error) {
            console.error('Unhandled promise rejection', value);
          }
        });
        // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
        promise._h = isNode$1 || isUnhandled(promise) ? 2 : 1;
      } promise._a = undefined;
      if (unhandled && result.e) throw result.v;
    });
  };
  var isUnhandled = function (promise) {
    return promise._h !== 1 && (promise._a || promise._c).length === 0;
  };
  var onHandleUnhandled = function (promise) {
    task.call(_global, function () {
      var handler;
      if (isNode$1) {
        process$2.emit('rejectionHandled', promise);
      } else if (handler = _global.onrejectionhandled) {
        handler({ promise: promise, reason: promise._v });
      }
    });
  };
  var $reject = function (value) {
    var promise = this;
    if (promise._d) return;
    promise._d = true;
    promise = promise._w || promise; // unwrap
    promise._v = value;
    promise._s = 2;
    if (!promise._a) promise._a = promise._c.slice();
    notify(promise, true);
  };
  var $resolve = function (value) {
    var promise = this;
    var then;
    if (promise._d) return;
    promise._d = true;
    promise = promise._w || promise; // unwrap
    try {
      if (promise === value) throw TypeError$1("Promise can't be resolved itself");
      if (then = isThenable(value)) {
        microtask(function () {
          var wrapper = { _w: promise, _d: false }; // wrap
          try {
            then.call(value, _ctx($resolve, wrapper, 1), _ctx($reject, wrapper, 1));
          } catch (e) {
            $reject.call(wrapper, e);
          }
        });
      } else {
        promise._v = value;
        promise._s = 1;
        notify(promise, false);
      }
    } catch (e) {
      $reject.call({ _w: promise, _d: false }, e); // wrap
    }
  };

  // constructor polyfill
  if (!USE_NATIVE$1) {
    // 25.4.3.1 Promise(executor)
    $Promise = function Promise(executor) {
      _anInstance(this, $Promise, PROMISE, '_h');
      _aFunction(executor);
      Internal.call(this);
      try {
        executor(_ctx($resolve, this, 1), _ctx($reject, this, 1));
      } catch (err) {
        $reject.call(this, err);
      }
    };
    // eslint-disable-next-line no-unused-vars
    Internal = function Promise(executor) {
      this._c = [];             // <- awaiting reactions
      this._a = undefined;      // <- checked in isUnhandled reactions
      this._s = 0;              // <- state
      this._d = false;          // <- done
      this._v = undefined;      // <- value
      this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
      this._n = false;          // <- notify
    };
    Internal.prototype = _redefineAll($Promise.prototype, {
      // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
      then: function then(onFulfilled, onRejected) {
        var reaction = newPromiseCapability(_speciesConstructor(this, $Promise));
        reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
        reaction.fail = typeof onRejected == 'function' && onRejected;
        reaction.domain = isNode$1 ? process$2.domain : undefined;
        this._c.push(reaction);
        if (this._a) this._a.push(reaction);
        if (this._s) notify(this, false);
        return reaction.promise;
      },
      // 25.4.5.1 Promise.prototype.catch(onRejected)
      'catch': function (onRejected) {
        return this.then(undefined, onRejected);
      }
    });
    OwnPromiseCapability = function () {
      var promise = new Internal();
      this.promise = promise;
      this.resolve = _ctx($resolve, promise, 1);
      this.reject = _ctx($reject, promise, 1);
    };
    _newPromiseCapability.f = newPromiseCapability = function (C) {
      return C === $Promise || C === Wrapper
        ? new OwnPromiseCapability(C)
        : newGenericPromiseCapability(C);
    };
  }

  _export(_export.G + _export.W + _export.F * !USE_NATIVE$1, { Promise: $Promise });
  _setToStringTag($Promise, PROMISE);
  _setSpecies(PROMISE);
  Wrapper = _core[PROMISE];

  // statics
  _export(_export.S + _export.F * !USE_NATIVE$1, PROMISE, {
    // 25.4.4.5 Promise.reject(r)
    reject: function reject(r) {
      var capability = newPromiseCapability(this);
      var $$reject = capability.reject;
      $$reject(r);
      return capability.promise;
    }
  });
  _export(_export.S + _export.F * (_library || !USE_NATIVE$1), PROMISE, {
    // 25.4.4.6 Promise.resolve(x)
    resolve: function resolve(x) {
      return _promiseResolve(_library && this === Wrapper ? $Promise : this, x);
    }
  });
  _export(_export.S + _export.F * !(USE_NATIVE$1 && _iterDetect(function (iter) {
    $Promise.all(iter)['catch'](empty);
  })), PROMISE, {
    // 25.4.4.1 Promise.all(iterable)
    all: function all(iterable) {
      var C = this;
      var capability = newPromiseCapability(C);
      var resolve = capability.resolve;
      var reject = capability.reject;
      var result = _perform(function () {
        var values = [];
        var index = 0;
        var remaining = 1;
        _forOf(iterable, false, function (promise) {
          var $index = index++;
          var alreadyCalled = false;
          values.push(undefined);
          remaining++;
          C.resolve(promise).then(function (value) {
            if (alreadyCalled) return;
            alreadyCalled = true;
            values[$index] = value;
            --remaining || resolve(values);
          }, reject);
        });
        --remaining || resolve(values);
      });
      if (result.e) reject(result.v);
      return capability.promise;
    },
    // 25.4.4.4 Promise.race(iterable)
    race: function race(iterable) {
      var C = this;
      var capability = newPromiseCapability(C);
      var reject = capability.reject;
      var result = _perform(function () {
        _forOf(iterable, false, function (promise) {
          C.resolve(promise).then(capability.resolve, reject);
        });
      });
      if (result.e) reject(result.v);
      return capability.promise;
    }
  });

  // 19.1.2.1 Object.assign(target, source, ...)





  var $assign = Object.assign;

  // should work with symbols and should have deterministic property order (V8 bug)
  var _objectAssign = !$assign || _fails(function () {
    var A = {};
    var B = {};
    // eslint-disable-next-line no-undef
    var S = Symbol();
    var K = 'abcdefghijklmnopqrst';
    A[S] = 7;
    K.split('').forEach(function (k) { B[k] = k; });
    return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
  }) ? function assign(target, source) { // eslint-disable-line no-unused-vars
    var T = _toObject(target);
    var aLen = arguments.length;
    var index = 1;
    var getSymbols = _objectGops.f;
    var isEnum = _objectPie.f;
    while (aLen > index) {
      var S = _iobject(arguments[index++]);
      var keys = getSymbols ? _objectKeys(S).concat(getSymbols(S)) : _objectKeys(S);
      var length = keys.length;
      var j = 0;
      var key;
      while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
    } return T;
  } : $assign;

  // 19.1.3.1 Object.assign(target, source)


  _export(_export.S + _export.F, 'Object', { assign: _objectAssign });

  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */

  /* global Reflect, Promise */
  var extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) {
      if (b.hasOwnProperty(p)) d[p] = b[p];
    }
  };

  function __extends(d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }

  // typeof any so that it we don't have to cast when comparing a result to the error object

  /** PURE_IMPORTS_START  PURE_IMPORTS_END */
  var errorObject = {
    e: {}
  };

  /** PURE_IMPORTS_START ._errorObject PURE_IMPORTS_END */
  var tryCatchTarget;

  function tryCatcher() {
    try {
      return tryCatchTarget.apply(this, arguments);
    } catch (e) {
      errorObject.e = e;
      return errorObject;
    }
  }

  function tryCatch(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
  }

  /** PURE_IMPORTS_START  PURE_IMPORTS_END */
  function isFunction(x) {
    return typeof x === 'function';
  }

  /** PURE_IMPORTS_START  PURE_IMPORTS_END */
  var empty$1 = {
    closed: true,
    next: function next(value) {},
    error: function error(err) {
      throw err;
    },
    complete: function complete() {}
  };

  /** PURE_IMPORTS_START  PURE_IMPORTS_END */
  var isArray = Array.isArray || function (x) {
    return x && typeof x.length === 'number';
  };

  /** PURE_IMPORTS_START  PURE_IMPORTS_END */
  function isObject(x) {
    return x != null && typeof x === 'object';
  }

  /** PURE_IMPORTS_START tslib PURE_IMPORTS_END */
  /**
   * An error thrown when one or more errors have occurred during the
   * `unsubscribe` of a {@link Subscription}.
   */

  var UnsubscriptionError =
  /*@__PURE__*/
  function (_super) {
    __extends(UnsubscriptionError, _super);

    function UnsubscriptionError(errors) {
      var _this = _super.call(this, errors ? errors.length + " errors occurred during unsubscription:\n  " + errors.map(function (err, i) {
        return i + 1 + ") " + err.toString();
      }).join('\n  ') : '') || this;

      _this.errors = errors;
      _this.name = 'UnsubscriptionError';
      Object.setPrototypeOf(_this, UnsubscriptionError.prototype);
      return _this;
    }

    return UnsubscriptionError;
  }(Error);

  /** PURE_IMPORTS_START ._util_isArray,._util_isObject,._util_isFunction,._util_tryCatch,._util_errorObject,._util_UnsubscriptionError PURE_IMPORTS_END */
  /**
   * Represents a disposable resource, such as the execution of an Observable. A
   * Subscription has one important method, `unsubscribe`, that takes no argument
   * and just disposes the resource held by the subscription.
   *
   * Additionally, subscriptions may be grouped together through the `add()`
   * method, which will attach a child Subscription to the current Subscription.
   * When a Subscription is unsubscribed, all its children (and its grandchildren)
   * will be unsubscribed as well.
   *
   * @class Subscription
   */

  var Subscription =
  /*@__PURE__*/

  /*@__PURE__*/
  function () {
    /**
     * @param {function(): void} [unsubscribe] A function describing how to
     * perform the disposal of resources when the `unsubscribe` method is called.
     */
    function Subscription(unsubscribe) {
      /**
       * A flag to indicate whether this Subscription has already been unsubscribed.
       * @type {boolean}
       */
      this.closed = false;
      /** @internal */

      this._parent = null;
      /** @internal */

      this._parents = null;
      /** @internal */

      this._subscriptions = null;

      if (unsubscribe) {
        this._unsubscribe = unsubscribe;
      }
    }
    /**
     * Disposes the resources held by the subscription. May, for instance, cancel
     * an ongoing Observable execution or cancel any other type of work that
     * started when the Subscription was created.
     * @return {void}
     */


    Subscription.prototype.unsubscribe = function () {
      var hasErrors = false;
      var errors;

      if (this.closed) {
        return;
      }

      var _a = this,
          _parent = _a._parent,
          _parents = _a._parents,
          _unsubscribe = _a._unsubscribe,
          _subscriptions = _a._subscriptions;

      this.closed = true;
      this._parent = null;
      this._parents = null; // null out _subscriptions first so any child subscriptions that attempt
      // to remove themselves from this subscription will noop

      this._subscriptions = null;
      var index = -1;
      var len = _parents ? _parents.length : 0; // if this._parent is null, then so is this._parents, and we
      // don't have to remove ourselves from any parent subscriptions.

      while (_parent) {
        _parent.remove(this); // if this._parents is null or index >= len,
        // then _parent is set to null, and the loop exits


        _parent = ++index < len && _parents[index] || null;
      }

      if (isFunction(_unsubscribe)) {
        var trial = tryCatch(_unsubscribe).call(this);

        if (trial === errorObject) {
          hasErrors = true;
          errors = errors || (errorObject.e instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(errorObject.e.errors) : [errorObject.e]);
        }
      }

      if (isArray(_subscriptions)) {
        index = -1;
        len = _subscriptions.length;

        while (++index < len) {
          var sub = _subscriptions[index];

          if (isObject(sub)) {
            var trial = tryCatch(sub.unsubscribe).call(sub);

            if (trial === errorObject) {
              hasErrors = true;
              errors = errors || [];
              var err = errorObject.e;

              if (err instanceof UnsubscriptionError) {
                errors = errors.concat(flattenUnsubscriptionErrors(err.errors));
              } else {
                errors.push(err);
              }
            }
          }
        }
      }

      if (hasErrors) {
        throw new UnsubscriptionError(errors);
      }
    };
    /**
     * Adds a tear down to be called during the unsubscribe() of this
     * Subscription.
     *
     * If the tear down being added is a subscription that is already
     * unsubscribed, is the same reference `add` is being called on, or is
     * `Subscription.EMPTY`, it will not be added.
     *
     * If this subscription is already in an `closed` state, the passed
     * tear down logic will be executed immediately.
     *
     * @param {TeardownLogic} teardown The additional logic to execute on
     * teardown.
     * @return {Subscription} Returns the Subscription used or created to be
     * added to the inner subscriptions list. This Subscription can be used with
     * `remove()` to remove the passed teardown logic from the inner subscriptions
     * list.
     */


    Subscription.prototype.add = function (teardown) {
      if (!teardown || teardown === Subscription.EMPTY) {
        return Subscription.EMPTY;
      }

      if (teardown === this) {
        return this;
      }

      var subscription = teardown;

      switch (typeof teardown) {
        case 'function':
          subscription = new Subscription(teardown);

        case 'object':
          if (subscription.closed || typeof subscription.unsubscribe !== 'function') {
            return subscription;
          } else if (this.closed) {
            subscription.unsubscribe();
            return subscription;
          } else if (typeof subscription._addParent !== 'function'
          /* quack quack */
          ) {
              var tmp = subscription;
              subscription = new Subscription();
              subscription._subscriptions = [tmp];
            }

          break;

        default:
          throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
      }

      var subscriptions = this._subscriptions || (this._subscriptions = []);
      subscriptions.push(subscription);

      subscription._addParent(this);

      return subscription;
    };
    /**
     * Removes a Subscription from the internal list of subscriptions that will
     * unsubscribe during the unsubscribe process of this Subscription.
     * @param {Subscription} subscription The subscription to remove.
     * @return {void}
     */


    Subscription.prototype.remove = function (subscription) {
      var subscriptions = this._subscriptions;

      if (subscriptions) {
        var subscriptionIndex = subscriptions.indexOf(subscription);

        if (subscriptionIndex !== -1) {
          subscriptions.splice(subscriptionIndex, 1);
        }
      }
    };
    /** @internal */


    Subscription.prototype._addParent = function (parent) {
      var _a = this,
          _parent = _a._parent,
          _parents = _a._parents;

      if (!_parent || _parent === parent) {
        // If we don't have a parent, or the new parent is the same as the
        // current parent, then set this._parent to the new parent.
        this._parent = parent;
      } else if (!_parents) {
        // If there's already one parent, but not multiple, allocate an Array to
        // store the rest of the parent Subscriptions.
        this._parents = [parent];
      } else if (_parents.indexOf(parent) === -1) {
        // Only add the new parent to the _parents list if it's not already there.
        _parents.push(parent);
      }
    };

    Subscription.EMPTY = function (empty) {
      empty.closed = true;
      return empty;
    }(new Subscription());

    return Subscription;
  }();

  function flattenUnsubscriptionErrors(errors) {
    return errors.reduce(function (errs, err) {
      return errs.concat(err instanceof UnsubscriptionError ? err.errors : err);
    }, []);
  }

  /** PURE_IMPORTS_START  PURE_IMPORTS_END */
  var rxSubscriber = typeof Symbol === 'function' && typeof Symbol.for === 'function' ?
  /*@__PURE__*/
  Symbol.for('rxSubscriber') : '@@rxSubscriber';

  /** PURE_IMPORTS_START tslib,._util_isFunction,._Observer,._Subscription,.._internal_symbol_rxSubscriber PURE_IMPORTS_END */
  /**
   * Implements the {@link Observer} interface and extends the
   * {@link Subscription} class. While the {@link Observer} is the public API for
   * consuming the values of an {@link Observable}, all Observers get converted to
   * a Subscriber, in order to provide Subscription-like capabilities such as
   * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for
   * implementing operators, but it is rarely used as a public API.
   *
   * @class Subscriber<T>
   */

  var Subscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(Subscriber, _super);
    /**
     * @param {Observer|function(value: T): void} [destinationOrNext] A partially
     * defined Observer or a `next` callback function.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     */


    function Subscriber(destinationOrNext, error, complete) {
      var _this = _super.call(this) || this;

      _this.isStopped = false;

      switch (arguments.length) {
        case 0:
          _this.destination = empty$1;
          break;

        case 1:
          if (!destinationOrNext) {
            _this.destination = empty$1;
            break;
          }

          if (typeof destinationOrNext === 'object') {
            if (destinationOrNext instanceof Subscriber) {
              _this.destination = destinationOrNext;

              _this.destination.add(_this);
            } else {
              _this.destination = new SafeSubscriber(destinationOrNext);
            }

            break;
          }

        default:
          _this.destination = new SafeSubscriber(destinationOrNext, error, complete);
          break;
      }

      return _this;
    }

    Subscriber.prototype[rxSubscriber] = function () {
      return this;
    };
    /**
     * A static factory for a Subscriber, given a (potentially partial) definition
     * of an Observer.
     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)
     * Observer represented by the given arguments.
     */


    Subscriber.create = function (next, error, complete) {
      var subscriber = new Subscriber(next, error, complete);
      return subscriber;
    };
    /**
     * The {@link Observer} callback to receive notifications of type `next` from
     * the Observable, with a value. The Observable may call this method 0 or more
     * times.
     * @param {T} [value] The `next` value.
     * @return {void}
     */


    Subscriber.prototype.next = function (value) {
      if (!this.isStopped) {
        this._next(value);
      }
    };
    /**
     * The {@link Observer} callback to receive notifications of type `error` from
     * the Observable, with an attached {@link Error}. Notifies the Observer that
     * the Observable has experienced an error condition.
     * @param {any} [err] The `error` exception.
     * @return {void}
     */


    Subscriber.prototype.error = function (err) {
      if (!this.isStopped) {
        this.isStopped = true;

        this._error(err);
      }
    };
    /**
     * The {@link Observer} callback to receive a valueless notification of type
     * `complete` from the Observable. Notifies the Observer that the Observable
     * has finished sending push-based notifications.
     * @return {void}
     */


    Subscriber.prototype.complete = function () {
      if (!this.isStopped) {
        this.isStopped = true;

        this._complete();
      }
    };

    Subscriber.prototype.unsubscribe = function () {
      if (this.closed) {
        return;
      }

      this.isStopped = true;

      _super.prototype.unsubscribe.call(this);
    };

    Subscriber.prototype._next = function (value) {
      this.destination.next(value);
    };

    Subscriber.prototype._error = function (err) {
      this.destination.error(err);
      this.unsubscribe();
    };

    Subscriber.prototype._complete = function () {
      this.destination.complete();
      this.unsubscribe();
    };

    Subscriber.prototype._unsubscribeAndRecycle = function () {
      var _a = this,
          _parent = _a._parent,
          _parents = _a._parents;

      this._parent = null;
      this._parents = null;
      this.unsubscribe();
      this.closed = false;
      this.isStopped = false;
      this._parent = _parent;
      this._parents = _parents;
      return this;
    };

    return Subscriber;
  }(Subscription);
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */

  var SafeSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(SafeSubscriber, _super);

    function SafeSubscriber(observerOrNext, error, complete) {
      var _this = _super.call(this) || this;

      var next;
      var context = _this;

      if (isFunction(observerOrNext)) {
        next = observerOrNext;
      } else if (observerOrNext) {
        next = observerOrNext.next;
        error = observerOrNext.error;
        complete = observerOrNext.complete;

        if (observerOrNext !== empty$1) {
          context = Object.create(observerOrNext);

          if (isFunction(context.unsubscribe)) {
            _this.add(context.unsubscribe.bind(context));
          }

          context.unsubscribe = _this.unsubscribe.bind(_this);
        }
      }

      _this._context = context;
      _this._next = next;
      _this._error = error;
      _this._complete = complete;
      return _this;
    }

    SafeSubscriber.prototype.next = function (value) {
      if (!this.isStopped && this._next) {
        try {
          this._next.call(this._context, value);
        } catch (err) {
          this._hostReportError(err);

          this.unsubscribe();
        }
      }
    };

    SafeSubscriber.prototype.error = function (err) {
      if (!this.isStopped) {
        if (this._error) {
          try {
            this._error.call(this._context, err);
          } catch (err) {
            this._hostReportError(err);
          }
        } else {
          this._hostReportError(err);
        }

        this.unsubscribe();
      }
    };

    SafeSubscriber.prototype.complete = function () {
      if (!this.isStopped) {
        if (this._complete) {
          try {
            this._complete.call(this._context);
          } catch (err) {
            this._hostReportError(err);
          }
        }

        this.unsubscribe();
      }
    };

    SafeSubscriber.prototype._unsubscribe = function () {
      this._context = null;
    };

    SafeSubscriber.prototype._hostReportError = function (err) {
      setTimeout(function () {
        throw err;
      });
    };

    return SafeSubscriber;
  }(Subscriber);

  /** PURE_IMPORTS_START tslib,._Subscriber PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */

  var OuterSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(OuterSubscriber, _super);

    function OuterSubscriber() {
      return _super !== null && _super.apply(this, arguments) || this;
    }

    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
      this.destination.next(innerValue);
    };

    OuterSubscriber.prototype.notifyError = function (error, innerSub) {
      this.destination.error(error);
    };

    OuterSubscriber.prototype.notifyComplete = function (innerSub) {
      this.destination.complete();
    };

    return OuterSubscriber;
  }(Subscriber);

  /** PURE_IMPORTS_START tslib,._Subscriber PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @internal
   * @ignore
   * @extends {Ignored}
   */

  var InnerSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(InnerSubscriber, _super);

    function InnerSubscriber(parent, outerValue, outerIndex) {
      var _this = _super.call(this) || this;

      _this.parent = parent;
      _this.outerValue = outerValue;
      _this.outerIndex = outerIndex;
      _this.index = 0;
      return _this;
    }

    InnerSubscriber.prototype._next = function (value) {
      this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
    };

    InnerSubscriber.prototype._error = function (error) {
      this.parent.notifyError(error, this);
      this.unsubscribe();
    };

    InnerSubscriber.prototype._complete = function () {
      this.parent.notifyComplete(this);
      this.unsubscribe();
    };

    return InnerSubscriber;
  }(Subscriber);

  /** PURE_IMPORTS_START .._Subscriber,.._symbol_rxSubscriber,.._Observer PURE_IMPORTS_END */
  function toSubscriber(nextOrObserver, error, complete) {
    if (nextOrObserver) {
      if (nextOrObserver instanceof Subscriber) {
        return nextOrObserver;
      }

      if (nextOrObserver[rxSubscriber]) {
        return nextOrObserver[rxSubscriber]();
      }
    }

    if (!nextOrObserver && !error && !complete) {
      return new Subscriber(empty$1);
    }

    return new Subscriber(nextOrObserver, error, complete);
  }

  /** Symbol.observable or a string "@@observable". Used for interop */

  /** PURE_IMPORTS_START  PURE_IMPORTS_END */
  var observable = typeof Symbol === 'function' && Symbol.observable || '@@observable';

  /* tslint:disable:no-empty */

  /** PURE_IMPORTS_START  PURE_IMPORTS_END */
  function noop() {}

  /** PURE_IMPORTS_START ._noop PURE_IMPORTS_END */
  /* @internal */

  function pipeFromArray(fns) {
    if (!fns) {
      return noop;
    }

    if (fns.length === 1) {
      return fns[0];
    }

    return function piped(input) {
      return fns.reduce(function (prev, fn) {
        return fn(prev);
      }, input);
    };
  }

  /**
   * The global configuration object for RxJS, used to configure things
   * like what Promise contructor should used to create Promises
   */

  /** PURE_IMPORTS_START  PURE_IMPORTS_END */
  var config = {
    /**
     * The promise constructor used by default for methods such as
     * {@link toPromise} and {@link forEach}
     */
    Promise: Promise
  };

  /**
   * A representation of any set of values over any amount of time. This is the most basic building block
   * of RxJS.
   *
   * @class Observable<T>
   */

  var Observable =
  /*@__PURE__*/

  /*@__PURE__*/
  function () {
    /**
     * @constructor
     * @param {Function} subscribe the function that is called when the Observable is
     * initially subscribed to. This function is given a Subscriber, to which new values
     * can be `next`ed, or an `error` method can be called to raise an error, or
     * `complete` can be called to notify of a successful completion.
     */
    function Observable(subscribe) {
      /** @internal */
      this._isScalar = false;

      if (subscribe) {
        this._subscribe = subscribe;
      }
    }
    /**
     * Creates a new Observable, with this Observable as the source, and the passed
     * operator defined as the new observable's operator.
     * @method lift
     * @param {Operator} operator the operator defining the operation to take on the observable
     * @return {Observable} a new observable with the Operator applied
     */


    Observable.prototype.lift = function (operator) {
      var observable$$1 = new Observable();
      observable$$1.source = this;
      observable$$1.operator = operator;
      return observable$$1;
    };
    /**
     * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.
     *
     * <span class="informal">Use it when you have all these Observables, but still nothing is happening.</span>
     *
     * `subscribe` is not a regular operator, but a method that calls Observable's internal `subscribe` function. It
     * might be for example a function that you passed to a {@link create} static factory, but most of the time it is
     * a library implementation, which defines what and when will be emitted by an Observable. This means that calling
     * `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often
     * thought.
     *
     * Apart from starting the execution of an Observable, this method allows you to listen for values
     * that an Observable emits, as well as for when it completes or errors. You can achieve this in two
     * following ways.
     *
     * The first way is creating an object that implements {@link Observer} interface. It should have methods
     * defined by that interface, but note that it should be just a regular JavaScript object, which you can create
     * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular do
     * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also
     * that your object does not have to implement all methods. If you find yourself creating a method that doesn't
     * do anything, you can simply omit it. Note however, that if `error` method is not provided, all errors will
     * be left uncaught.
     *
     * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.
     * This means you can provide three functions as arguments to `subscribe`, where first function is equivalent
     * of a `next` method, second of an `error` method and third of a `complete` method. Just as in case of Observer,
     * if you do not need to listen for something, you can omit a function, preferably by passing `undefined` or `null`,
     * since `subscribe` recognizes these functions by where they were placed in function call. When it comes
     * to `error` function, just as before, if not provided, errors emitted by an Observable will be thrown.
     *
     * Whatever style of calling `subscribe` you use, in both cases it returns a Subscription object.
     * This object allows you to call `unsubscribe` on it, which in turn will stop work that an Observable does and will clean
     * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback
     * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.
     *
     * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.
     * It is an Observable itself that decides when these functions will be called. For example {@link of}
     * by default emits all its values synchronously. Always check documentation for how given Observable
     * will behave when subscribed and if its default behavior can be modified with a {@link Scheduler}.
     *
     * @example <caption>Subscribe with an Observer</caption>
     * const sumObserver = {
     *   sum: 0,
     *   next(value) {
     *     console.log('Adding: ' + value);
     *     this.sum = this.sum + value;
     *   },
     *   error() { // We actually could just remove this method,
     *   },        // since we do not really care about errors right now.
     *   complete() {
     *     console.log('Sum equals: ' + this.sum);
     *   }
     * };
     *
     * Rx.Observable.of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.
     * .subscribe(sumObserver);
     *
     * // Logs:
     * // "Adding: 1"
     * // "Adding: 2"
     * // "Adding: 3"
     * // "Sum equals: 6"
     *
     *
     * @example <caption>Subscribe with functions</caption>
     * let sum = 0;
     *
     * Rx.Observable.of(1, 2, 3)
     * .subscribe(
     *   function(value) {
     *     console.log('Adding: ' + value);
     *     sum = sum + value;
     *   },
     *   undefined,
     *   function() {
     *     console.log('Sum equals: ' + sum);
     *   }
     * );
     *
     * // Logs:
     * // "Adding: 1"
     * // "Adding: 2"
     * // "Adding: 3"
     * // "Sum equals: 6"
     *
     *
     * @example <caption>Cancel a subscription</caption>
     * const subscription = Rx.Observable.interval(1000).subscribe(
     *   num => console.log(num),
     *   undefined,
     *   () => console.log('completed!') // Will not be called, even
     * );                                // when cancelling subscription
     *
     *
     * setTimeout(() => {
     *   subscription.unsubscribe();
     *   console.log('unsubscribed!');
     * }, 2500);
     *
     * // Logs:
     * // 0 after 1s
     * // 1 after 2s
     * // "unsubscribed!" after 2.5s
     *
     *
     * @param {Observer|Function} observerOrNext (optional) Either an observer with methods to be called,
     *  or the first of three possible handlers, which is the handler for each value emitted from the subscribed
     *  Observable.
     * @param {Function} error (optional) A handler for a terminal event resulting from an error. If no error handler is provided,
     *  the error will be thrown as unhandled.
     * @param {Function} complete (optional) A handler for a terminal event resulting from successful completion.
     * @return {ISubscription} a subscription reference to the registered handlers
     * @method subscribe
     */


    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
      var operator = this.operator;
      var sink = toSubscriber(observerOrNext, error, complete);

      if (operator) {
        operator.call(sink, this.source);
      } else {
        sink.add(this.source ? this._subscribe(sink) : this._trySubscribe(sink));
      }

      return sink;
    };

    Observable.prototype._trySubscribe = function (sink) {
      try {
        return this._subscribe(sink);
      } catch (err) {
        sink.error(err);
      }
    };
    /**
     * @method forEach
     * @param {Function} next a handler for each value emitted by the observable
     * @param {PromiseConstructor} [promiseCtor] a constructor function used to instantiate the Promise
     * @return {Promise} a promise that either resolves on observable completion or
     *  rejects with the handled error
     */


    Observable.prototype.forEach = function (next, promiseCtor) {
      var _this = this;

      promiseCtor = getPromiseCtor(promiseCtor);
      return new promiseCtor(function (resolve, reject) {
        // Must be declared in a separate statement to avoid a RefernceError when
        // accessing subscription below in the closure due to Temporal Dead Zone.
        var subscription;
        subscription = _this.subscribe(function (value) {
          try {
            next(value);
          } catch (err) {
            reject(err);

            if (subscription) {
              subscription.unsubscribe();
            }
          }
        }, reject, resolve);
      });
    };
    /** @internal */


    Observable.prototype._subscribe = function (subscriber) {
      return this.source.subscribe(subscriber);
    };
    /**
     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable
     * @method Symbol.observable
     * @return {Observable} this instance of the observable
     */


    Observable.prototype[observable] = function () {
      return this;
    };
    /* tslint:enable:max-line-length */

    /**
     * Used to stitch together functional operators into a chain.
     * @method pipe
     * @return {Observable} the Observable result of all of the operators having
     * been called in the order they were passed in.
     *
     * @example
     *
     * import { map, filter, scan } from 'rxjs/internal/operators';
     *
     * Rx.Observable.interval(1000)
     *   .pipe(
     *     filter(x => x % 2 === 0),
     *     map(x => x + x),
     *     scan((acc, x) => acc + x)
     *   )
     *   .subscribe(x => console.log(x))
     */


    Observable.prototype.pipe = function () {
      var operations = [];

      for (var _i = 0; _i < arguments.length; _i++) {
        operations[_i] = arguments[_i];
      }

      if (operations.length === 0) {
        return this;
      }

      return pipeFromArray(operations)(this);
    };
    /* tslint:enable:max-line-length */


    Observable.prototype.toPromise = function (promiseCtor) {
      var _this = this;

      promiseCtor = getPromiseCtor(promiseCtor);
      return new promiseCtor(function (resolve, reject) {
        var value;

        _this.subscribe(function (x) {
          return value = x;
        }, function (err) {
          return reject(err);
        }, function () {
          return resolve(value);
        });
      });
    }; // HACK: Since TypeScript inherits static properties too, we have to
    // fight against TypeScript here so Subject can have a different static create signature

    /**
     * Creates a new cold Observable by calling the Observable constructor
     * @static true
     * @owner Observable
     * @method create
     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
     * @return {Observable} a new cold observable
     */


    Observable.create = function (subscribe) {
      return new Observable(subscribe);
    };

    return Observable;
  }();
  /**
   * Decides between a passed promise constructor from consuming code,
   * A default configured promise constructor, and the native promise
   * constructor and returns it. If nothing can be found, it will throw
   * an error.
   * @param promiseCtor The optional promise constructor to passed by consuming code
   */

  function getPromiseCtor(promiseCtor) {
    if (!promiseCtor) {
      promiseCtor = config.Promise || Promise;
    }

    if (!promiseCtor) {
      throw new Error('no Promise impl found');
    }

    return promiseCtor;
  }

  /**
   * Subscribes to an ArrayLike with a subscriber
   * @param array The array or array-like to subscribe to
   * @param subscriber The subscriber to subscribe with.
   */

  /** PURE_IMPORTS_START  PURE_IMPORTS_END */
  var subscribeToArray = function subscribeToArray(array) {
    return function (subscriber) {
      for (var i = 0, len = array.length; i < len && !subscriber.closed; i++) {
        subscriber.next(array[i]);
      }

      if (!subscriber.closed) {
        subscriber.complete();
      }
    };
  };

  /** PURE_IMPORTS_START  PURE_IMPORTS_END */
  var subscribeToPromise = function subscribeToPromise(promise) {
    return function (subscriber) {
      promise.then(function (value) {
        if (!subscriber.closed) {
          subscriber.next(value);
          subscriber.complete();
        }
      }, function (err) {
        return subscriber.error(err);
      }).then(null, function (err) {
        // Escaping the Promise trap: globally throw unhandled errors
        setTimeout(function () {
          throw err;
        });
      });
      return subscriber;
    };
  };

  /** PURE_IMPORTS_START  PURE_IMPORTS_END */
  function getSymbolIterator() {
    if (typeof Symbol !== 'function' || !Symbol.iterator) {
      return '@@iterator';
    }

    return Symbol.iterator;
  }
  var iterator =
  /*@__PURE__*/
  getSymbolIterator();

  /** PURE_IMPORTS_START .._symbol_iterator PURE_IMPORTS_END */
  var subscribeToIterable = function subscribeToIterable(iterable) {
    return function (subscriber) {
      var iterator$$1 = iterable[iterator]();

      do {
        var item = iterator$$1.next();

        if (item.done) {
          subscriber.complete();
          break;
        }

        subscriber.next(item.value);

        if (subscriber.closed) {
          break;
        }
      } while (true); // Finalize the iterator if it happens to be a Generator


      if (typeof iterator$$1.return === 'function') {
        subscriber.add(function () {
          if (iterator$$1.return) {
            iterator$$1.return();
          }
        });
      }

      return subscriber;
    };
  };

  /** PURE_IMPORTS_START .._symbol_observable PURE_IMPORTS_END */
  /**
   * Subscribes to an object that implements Symbol.observable with the given
   * Subscriber.
   * @param obj An object that implements Symbol.observable
   * @param subscriber The Subscriber to use to subscribe to the observable
   */

  var subscribeToObservable = function subscribeToObservable(obj) {
    return function (subscriber) {
      var obs = obj[observable]();

      if (typeof obs.subscribe !== 'function') {
        // Should be caught by observable subscribe function error handling.
        throw new TypeError('Provided object does not correctly implement Symbol.observable');
      } else {
        return obs.subscribe(subscriber);
      }
    };
  };

  /** PURE_IMPORTS_START  PURE_IMPORTS_END */
  var isArrayLike = function isArrayLike(x) {
    return x && typeof x.length === 'number';
  };

  /** PURE_IMPORTS_START  PURE_IMPORTS_END */
  function isPromise(value) {
    return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
  }

  /** PURE_IMPORTS_START .._Observable,._subscribeToArray,._subscribeToPromise,._subscribeToIterable,._subscribeToObservable,._isArrayLike,._isPromise,._isObject,.._symbol_iterator,.._symbol_observable PURE_IMPORTS_END */
  var subscribeTo = function subscribeTo(result) {
    if (result instanceof Observable) {
      return function (subscriber) {
        if (result._isScalar) {
          subscriber.next(result.value);
          subscriber.complete();
          return undefined;
        } else {
          return result.subscribe(subscriber);
        }
      };
    } else if (isArrayLike(result)) {
      return subscribeToArray(result);
    } else if (isPromise(result)) {
      return subscribeToPromise(result);
    } else if (result && typeof result[iterator] === 'function') {
      return subscribeToIterable(result);
    } else if (result && typeof result[observable] === 'function') {
      return subscribeToObservable(result);
    } else {
      var value = isObject(result) ? 'an invalid object' : "'" + result + "'";
      var msg = "You provided " + value + " where a stream was expected." + ' You can provide an Observable, Promise, Array, or Iterable.';
      throw new TypeError(msg);
    }
  };

  /** PURE_IMPORTS_START .._InnerSubscriber,._subscribeTo PURE_IMPORTS_END */
  function subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {
    var destination = new InnerSubscriber(outerSubscriber, outerValue, outerIndex);
    return subscribeTo(result)(destination);
  }

  /** PURE_IMPORTS_START tslib,.._util_tryCatch,.._util_errorObject,.._OuterSubscriber,.._util_subscribeToResult PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var AuditSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(AuditSubscriber, _super);

    function AuditSubscriber(destination, durationSelector) {
      var _this = _super.call(this, destination) || this;

      _this.durationSelector = durationSelector;
      _this.hasValue = false;
      return _this;
    }

    AuditSubscriber.prototype._next = function (value) {
      this.value = value;
      this.hasValue = true;

      if (!this.throttled) {
        var duration = tryCatch(this.durationSelector)(value);

        if (duration === errorObject) {
          this.destination.error(errorObject.e);
        } else {
          var innerSubscription = subscribeToResult(this, duration);

          if (innerSubscription.closed) {
            this.clearThrottle();
          } else {
            this.add(this.throttled = innerSubscription);
          }
        }
      }
    };

    AuditSubscriber.prototype.clearThrottle = function () {
      var _a = this,
          value = _a.value,
          hasValue = _a.hasValue,
          throttled = _a.throttled;

      if (throttled) {
        this.remove(throttled);
        this.throttled = null;
        throttled.unsubscribe();
      }

      if (hasValue) {
        this.value = null;
        this.hasValue = false;
        this.destination.next(value);
      }
    };

    AuditSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {
      this.clearThrottle();
    };

    AuditSubscriber.prototype.notifyComplete = function () {
      this.clearThrottle();
    };

    return AuditSubscriber;
  }(OuterSubscriber);

  /** PURE_IMPORTS_START tslib,.._Subscription PURE_IMPORTS_END */
  /**
   * A unit of work to be executed in a {@link Scheduler}. An action is typically
   * created from within a Scheduler and an RxJS user does not need to concern
   * themselves about creating and manipulating an Action.
   *
   * ```ts
   * class Action<T> extends Subscription {
   *   new (scheduler: Scheduler, work: (state?: T) => void);
   *   schedule(state?: T, delay: number = 0): Subscription;
   * }
   * ```
   *
   * @class Action<T>
   */

  var Action =
  /*@__PURE__*/
  function (_super) {
    __extends(Action, _super);

    function Action(scheduler, work) {
      return _super.call(this) || this;
    }
    /**
     * Schedules this action on its parent Scheduler for execution. May be passed
     * some context object, `state`. May happen at some point in the future,
     * according to the `delay` parameter, if specified.
     * @param {T} [state] Some contextual data that the `work` function uses when
     * called by the Scheduler.
     * @param {number} [delay] Time to wait before executing the work, where the
     * time unit is implicit and defined by the Scheduler.
     * @return {void}
     */


    Action.prototype.schedule = function (state, delay) {
      if (delay === void 0) {
        delay = 0;
      }

      return this;
    };

    return Action;
  }(Subscription);

  /** PURE_IMPORTS_START tslib,._Action PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */

  var AsyncAction =
  /*@__PURE__*/
  function (_super) {
    __extends(AsyncAction, _super);

    function AsyncAction(scheduler, work) {
      var _this = _super.call(this, scheduler, work) || this;

      _this.scheduler = scheduler;
      _this.work = work;
      _this.pending = false;
      return _this;
    }

    AsyncAction.prototype.schedule = function (state, delay) {
      if (delay === void 0) {
        delay = 0;
      }

      if (this.closed) {
        return this;
      } // Always replace the current state with the new state.


      this.state = state;
      var id = this.id;
      var scheduler = this.scheduler; //
      // Important implementation note:
      //
      // Actions only execute once by default, unless rescheduled from within the
      // scheduled callback. This allows us to implement single and repeat
      // actions via the same code path, without adding API surface area, as well
      // as mimic traditional recursion but across asynchronous boundaries.
      //
      // However, JS runtimes and timers distinguish between intervals achieved by
      // serial `setTimeout` calls vs. a single `setInterval` call. An interval of
      // serial `setTimeout` calls can be individually delayed, which delays
      // scheduling the next `setTimeout`, and so on. `setInterval` attempts to
      // guarantee the interval callback will be invoked more precisely to the
      // interval period, regardless of load.
      //
      // Therefore, we use `setInterval` to schedule single and repeat actions.
      // If the action reschedules itself with the same delay, the interval is not
      // canceled. If the action doesn't reschedule, or reschedules with a
      // different delay, the interval will be canceled after scheduled callback
      // execution.
      //

      if (id != null) {
        this.id = this.recycleAsyncId(scheduler, id, delay);
      } // Set the pending flag indicating that this action has been scheduled, or
      // has recursively rescheduled itself.


      this.pending = true;
      this.delay = delay; // If this action has already an async Id, don't request a new one.

      this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
      return this;
    };

    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {
      if (delay === void 0) {
        delay = 0;
      }

      return setInterval(scheduler.flush.bind(scheduler, this), delay);
    };

    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
      if (delay === void 0) {
        delay = 0;
      } // If this action is rescheduled with the same delay time, don't clear the interval id.


      if (delay !== null && this.delay === delay && this.pending === false) {
        return id;
      } // Otherwise, if the action's delay time is different from the current delay,
      // or the action has been rescheduled before it's executed, clear the interval id


      return clearInterval(id) && undefined || undefined;
    };
    /**
     * Immediately executes this action and the `work` it contains.
     * @return {any}
     */


    AsyncAction.prototype.execute = function (state, delay) {
      if (this.closed) {
        return new Error('executing a cancelled action');
      }

      this.pending = false;

      var error = this._execute(state, delay);

      if (error) {
        return error;
      } else if (this.pending === false && this.id != null) {
        // Dequeue if the action didn't reschedule itself. Don't call
        // unsubscribe(), because the action could reschedule later.
        // For example:
        // ```
        // scheduler.schedule(function doWork(counter) {
        //   /* ... I'm a busy worker bee ... */
        //   var originalAction = this;
        //   /* wait 100ms before rescheduling the action */
        //   setTimeout(function () {
        //     originalAction.schedule(counter + 1);
        //   }, 100);
        // }, 1000);
        // ```
        this.id = this.recycleAsyncId(this.scheduler, this.id, null);
      }
    };

    AsyncAction.prototype._execute = function (state, delay) {
      var errored = false;
      var errorValue = undefined;

      try {
        this.work(state);
      } catch (e) {
        errored = true;
        errorValue = !!e && e || new Error(e);
      }

      if (errored) {
        this.unsubscribe();
        return errorValue;
      }
    };

    AsyncAction.prototype._unsubscribe = function () {
      var id = this.id;
      var scheduler = this.scheduler;
      var actions = scheduler.actions;
      var index = actions.indexOf(this);
      this.work = null;
      this.state = null;
      this.pending = false;
      this.scheduler = null;

      if (index !== -1) {
        actions.splice(index, 1);
      }

      if (id != null) {
        this.id = this.recycleAsyncId(scheduler, id, null);
      }

      this.delay = null;
    };

    return AsyncAction;
  }(Action);

  /**
   * An execution context and a data structure to order tasks and schedule their
   * execution. Provides a notion of (potentially virtual) time, through the
   * `now()` getter method.
   *
   * Each unit of work in a Scheduler is called an {@link Action}.
   *
   * ```ts
   * class Scheduler {
   *   now(): number;
   *   schedule(work, delay?, state?): Subscription;
   * }
   * ```
   *
   * @class Scheduler
   */
  var Scheduler =
  /*@__PURE__*/

  /*@__PURE__*/
  function () {
    function Scheduler(SchedulerAction, now) {
      if (now === void 0) {
        now = Scheduler.now;
      }

      this.SchedulerAction = SchedulerAction;
      this.now = now;
    }
    /**
     * Schedules a function, `work`, for execution. May happen at some point in
     * the future, according to the `delay` parameter, if specified. May be passed
     * some context object, `state`, which will be passed to the `work` function.
     *
     * The given arguments will be processed an stored as an Action object in a
     * queue of actions.
     *
     * @param {function(state: ?T): ?Subscription} work A function representing a
     * task, or some unit of work to be executed by the Scheduler.
     * @param {number} [delay] Time to wait before executing the work, where the
     * time unit is implicit and defined by the Scheduler itself.
     * @param {T} [state] Some contextual data that the `work` function uses when
     * called by the Scheduler.
     * @return {Subscription} A subscription in order to be able to unsubscribe
     * the scheduled work.
     */


    Scheduler.prototype.schedule = function (work, delay, state) {
      if (delay === void 0) {
        delay = 0;
      }

      return new this.SchedulerAction(this, work).schedule(state, delay);
    };

    Scheduler.now = Date.now ? Date.now : function () {
      return +new Date();
    };
    return Scheduler;
  }();

  /** PURE_IMPORTS_START tslib,.._Scheduler PURE_IMPORTS_END */

  var AsyncScheduler =
  /*@__PURE__*/
  function (_super) {
    __extends(AsyncScheduler, _super);

    function AsyncScheduler() {
      var _this = _super !== null && _super.apply(this, arguments) || this;

      _this.actions = [];
      /**
       * A flag to indicate whether the Scheduler is currently executing a batch of
       * queued actions.
       * @type {boolean}
       */

      _this.active = false;
      /**
       * An internal ID used to track the latest asynchronous task such as those
       * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and
       * others.
       * @type {any}
       */

      _this.scheduled = undefined;
      return _this;
    }

    AsyncScheduler.prototype.flush = function (action) {
      var actions = this.actions;

      if (this.active) {
        actions.push(action);
        return;
      }

      var error;
      this.active = true;

      do {
        if (error = action.execute(action.state, action.delay)) {
          break;
        }
      } while (action = actions.shift()); // exhaust the scheduler queue


      this.active = false;

      if (error) {
        while (action = actions.shift()) {
          action.unsubscribe();
        }

        throw error;
      }
    };

    return AsyncScheduler;
  }(Scheduler);

  /** PURE_IMPORTS_START ._AsyncAction,._AsyncScheduler PURE_IMPORTS_END */
  /**
   *
   * Async Scheduler
   *
   * <span class="informal">Schedule task as if you used setTimeout(task, duration)</span>
   *
   * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript
   * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating
   * in intervals.
   *
   * If you just want to "defer" task, that is to perform it right after currently
   * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),
   * better choice will be the {@link asap} scheduler.
   *
   * @example <caption>Use async scheduler to delay task</caption>
   * const task = () => console.log('it works!');
   *
   * Rx.Scheduler.async.schedule(task, 2000);
   *
   * // After 2 seconds logs:
   * // "it works!"
   *
   *
   * @example <caption>Use async scheduler to repeat task in intervals</caption>
   * function task(state) {
   *   console.log(state);
   *   this.schedule(state + 1, 1000); // `this` references currently executing Action,
   *                                   // which we reschedule with new state and delay
   * }
   *
   * Rx.Scheduler.async.schedule(task, 3000, 0);
   *
   * // Logs:
   * // 0 after 3s
   * // 1 after 4s
   * // 2 after 5s
   * // 3 after 6s
   *
   * @static true
   * @name async
   * @owner Scheduler
   */

  var async =
  /*@__PURE__*/
  new AsyncScheduler(AsyncAction);

  /** PURE_IMPORTS_START ._isArray PURE_IMPORTS_END */

  /** PURE_IMPORTS_START  PURE_IMPORTS_END */
  function isScheduler(value) {
    return value && typeof value.schedule === 'function';
  }

  /** PURE_IMPORTS_START .._Observable,.._scheduler_async,.._util_isNumeric,.._util_isScheduler PURE_IMPORTS_END */

  /** PURE_IMPORTS_START .._scheduler_async,._audit,.._observable_timer PURE_IMPORTS_END */

  /** PURE_IMPORTS_START tslib,.._OuterSubscriber,.._util_subscribeToResult PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var BufferSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(BufferSubscriber, _super);

    function BufferSubscriber(destination, closingNotifier) {
      var _this = _super.call(this, destination) || this;

      _this.buffer = [];

      _this.add(subscribeToResult(_this, closingNotifier));

      return _this;
    }

    BufferSubscriber.prototype._next = function (value) {
      this.buffer.push(value);
    };

    BufferSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
      var buffer = this.buffer;
      this.buffer = [];
      this.destination.next(buffer);
    };

    return BufferSubscriber;
  }(OuterSubscriber);

  /** PURE_IMPORTS_START tslib,.._Subscriber PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var BufferCountSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(BufferCountSubscriber, _super);

    function BufferCountSubscriber(destination, bufferSize) {
      var _this = _super.call(this, destination) || this;

      _this.bufferSize = bufferSize;
      _this.buffer = [];
      return _this;
    }

    BufferCountSubscriber.prototype._next = function (value) {
      var buffer = this.buffer;
      buffer.push(value);

      if (buffer.length == this.bufferSize) {
        this.destination.next(buffer);
        this.buffer = [];
      }
    };

    BufferCountSubscriber.prototype._complete = function () {
      var buffer = this.buffer;

      if (buffer.length > 0) {
        this.destination.next(buffer);
      }

      _super.prototype._complete.call(this);
    };

    return BufferCountSubscriber;
  }(Subscriber);
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var BufferSkipCountSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(BufferSkipCountSubscriber, _super);

    function BufferSkipCountSubscriber(destination, bufferSize, startBufferEvery) {
      var _this = _super.call(this, destination) || this;

      _this.bufferSize = bufferSize;
      _this.startBufferEvery = startBufferEvery;
      _this.buffers = [];
      _this.count = 0;
      return _this;
    }

    BufferSkipCountSubscriber.prototype._next = function (value) {
      var _a = this,
          bufferSize = _a.bufferSize,
          startBufferEvery = _a.startBufferEvery,
          buffers = _a.buffers,
          count = _a.count;

      this.count++;

      if (count % startBufferEvery === 0) {
        buffers.push([]);
      }

      for (var i = buffers.length; i--;) {
        var buffer = buffers[i];
        buffer.push(value);

        if (buffer.length === bufferSize) {
          buffers.splice(i, 1);
          this.destination.next(buffer);
        }
      }
    };

    BufferSkipCountSubscriber.prototype._complete = function () {
      var _a = this,
          buffers = _a.buffers,
          destination = _a.destination;

      while (buffers.length > 0) {
        var buffer = buffers.shift();

        if (buffer.length > 0) {
          destination.next(buffer);
        }
      }

      _super.prototype._complete.call(this);
    };

    return BufferSkipCountSubscriber;
  }(Subscriber);

  /** PURE_IMPORTS_START tslib,.._scheduler_async,.._Subscriber,.._util_isScheduler PURE_IMPORTS_END */

  var Context =
  /*@__PURE__*/

  /*@__PURE__*/
  function () {
    function Context() {
      this.buffer = [];
    }

    return Context;
  }();
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var BufferTimeSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(BufferTimeSubscriber, _super);

    function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
      var _this = _super.call(this, destination) || this;

      _this.bufferTimeSpan = bufferTimeSpan;
      _this.bufferCreationInterval = bufferCreationInterval;
      _this.maxBufferSize = maxBufferSize;
      _this.scheduler = scheduler;
      _this.contexts = [];

      var context = _this.openContext();

      _this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;

      if (_this.timespanOnly) {
        var timeSpanOnlyState = {
          subscriber: _this,
          context: context,
          bufferTimeSpan: bufferTimeSpan
        };

        _this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
      } else {
        var closeState = {
          subscriber: _this,
          context: context
        };
        var creationState = {
          bufferTimeSpan: bufferTimeSpan,
          bufferCreationInterval: bufferCreationInterval,
          subscriber: _this,
          scheduler: scheduler
        };

        _this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));

        _this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));
      }

      return _this;
    }

    BufferTimeSubscriber.prototype._next = function (value) {
      var contexts = this.contexts;
      var len = contexts.length;
      var filledBufferContext;

      for (var i = 0; i < len; i++) {
        var context_1 = contexts[i];
        var buffer = context_1.buffer;
        buffer.push(value);

        if (buffer.length == this.maxBufferSize) {
          filledBufferContext = context_1;
        }
      }

      if (filledBufferContext) {
        this.onBufferFull(filledBufferContext);
      }
    };

    BufferTimeSubscriber.prototype._error = function (err) {
      this.contexts.length = 0;

      _super.prototype._error.call(this, err);
    };

    BufferTimeSubscriber.prototype._complete = function () {
      var _a = this,
          contexts = _a.contexts,
          destination = _a.destination;

      while (contexts.length > 0) {
        var context_2 = contexts.shift();
        destination.next(context_2.buffer);
      }

      _super.prototype._complete.call(this);
    };

    BufferTimeSubscriber.prototype._unsubscribe = function () {
      this.contexts = null;
    };

    BufferTimeSubscriber.prototype.onBufferFull = function (context) {
      this.closeContext(context);
      var closeAction = context.closeAction;
      closeAction.unsubscribe();
      this.remove(closeAction);

      if (!this.closed && this.timespanOnly) {
        context = this.openContext();
        var bufferTimeSpan = this.bufferTimeSpan;
        var timeSpanOnlyState = {
          subscriber: this,
          context: context,
          bufferTimeSpan: bufferTimeSpan
        };
        this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
      }
    };

    BufferTimeSubscriber.prototype.openContext = function () {
      var context = new Context();
      this.contexts.push(context);
      return context;
    };

    BufferTimeSubscriber.prototype.closeContext = function (context) {
      this.destination.next(context.buffer);
      var contexts = this.contexts;
      var spliceIndex = contexts ? contexts.indexOf(context) : -1;

      if (spliceIndex >= 0) {
        contexts.splice(contexts.indexOf(context), 1);
      }
    };

    return BufferTimeSubscriber;
  }(Subscriber);

  function dispatchBufferTimeSpanOnly(state) {
    var subscriber = state.subscriber;
    var prevContext = state.context;

    if (prevContext) {
      subscriber.closeContext(prevContext);
    }

    if (!subscriber.closed) {
      state.context = subscriber.openContext();
      state.context.closeAction = this.schedule(state, state.bufferTimeSpan);
    }
  }

  function dispatchBufferCreation(state) {
    var bufferCreationInterval = state.bufferCreationInterval,
        bufferTimeSpan = state.bufferTimeSpan,
        subscriber = state.subscriber,
        scheduler = state.scheduler;
    var context = subscriber.openContext();
    var action = this;

    if (!subscriber.closed) {
      subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, {
        subscriber: subscriber,
        context: context
      }));
      action.schedule(state, bufferCreationInterval);
    }
  }

  function dispatchBufferClose(arg) {
    var subscriber = arg.subscriber,
        context = arg.context;
    subscriber.closeContext(context);
  }

  /** PURE_IMPORTS_START tslib,.._Subscription,.._util_subscribeToResult,.._OuterSubscriber PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var BufferToggleSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(BufferToggleSubscriber, _super);

    function BufferToggleSubscriber(destination, openings, closingSelector) {
      var _this = _super.call(this, destination) || this;

      _this.openings = openings;
      _this.closingSelector = closingSelector;
      _this.contexts = [];

      _this.add(subscribeToResult(_this, openings));

      return _this;
    }

    BufferToggleSubscriber.prototype._next = function (value) {
      var contexts = this.contexts;
      var len = contexts.length;

      for (var i = 0; i < len; i++) {
        contexts[i].buffer.push(value);
      }
    };

    BufferToggleSubscriber.prototype._error = function (err) {
      var contexts = this.contexts;

      while (contexts.length > 0) {
        var context_1 = contexts.shift();
        context_1.subscription.unsubscribe();
        context_1.buffer = null;
        context_1.subscription = null;
      }

      this.contexts = null;

      _super.prototype._error.call(this, err);
    };

    BufferToggleSubscriber.prototype._complete = function () {
      var contexts = this.contexts;

      while (contexts.length > 0) {
        var context_2 = contexts.shift();
        this.destination.next(context_2.buffer);
        context_2.subscription.unsubscribe();
        context_2.buffer = null;
        context_2.subscription = null;
      }

      this.contexts = null;

      _super.prototype._complete.call(this);
    };

    BufferToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
      outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);
    };

    BufferToggleSubscriber.prototype.notifyComplete = function (innerSub) {
      this.closeBuffer(innerSub.context);
    };

    BufferToggleSubscriber.prototype.openBuffer = function (value) {
      try {
        var closingSelector = this.closingSelector;
        var closingNotifier = closingSelector.call(this, value);

        if (closingNotifier) {
          this.trySubscribe(closingNotifier);
        }
      } catch (err) {
        this._error(err);
      }
    };

    BufferToggleSubscriber.prototype.closeBuffer = function (context) {
      var contexts = this.contexts;

      if (contexts && context) {
        var buffer = context.buffer,
            subscription = context.subscription;
        this.destination.next(buffer);
        contexts.splice(contexts.indexOf(context), 1);
        this.remove(subscription);
        subscription.unsubscribe();
      }
    };

    BufferToggleSubscriber.prototype.trySubscribe = function (closingNotifier) {
      var contexts = this.contexts;
      var buffer = [];
      var subscription = new Subscription();
      var context = {
        buffer: buffer,
        subscription: subscription
      };
      contexts.push(context);
      var innerSubscription = subscribeToResult(this, closingNotifier, context);

      if (!innerSubscription || innerSubscription.closed) {
        this.closeBuffer(context);
      } else {
        innerSubscription.context = context;
        this.add(innerSubscription);
        subscription.add(innerSubscription);
      }
    };

    return BufferToggleSubscriber;
  }(OuterSubscriber);

  /** PURE_IMPORTS_START tslib,.._Subscription,.._util_tryCatch,.._util_errorObject,.._OuterSubscriber,.._util_subscribeToResult PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var BufferWhenSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(BufferWhenSubscriber, _super);

    function BufferWhenSubscriber(destination, closingSelector) {
      var _this = _super.call(this, destination) || this;

      _this.closingSelector = closingSelector;
      _this.subscribing = false;

      _this.openBuffer();

      return _this;
    }

    BufferWhenSubscriber.prototype._next = function (value) {
      this.buffer.push(value);
    };

    BufferWhenSubscriber.prototype._complete = function () {
      var buffer = this.buffer;

      if (buffer) {
        this.destination.next(buffer);
      }

      _super.prototype._complete.call(this);
    };

    BufferWhenSubscriber.prototype._unsubscribe = function () {
      this.buffer = null;
      this.subscribing = false;
    };

    BufferWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
      this.openBuffer();
    };

    BufferWhenSubscriber.prototype.notifyComplete = function () {
      if (this.subscribing) {
        this.complete();
      } else {
        this.openBuffer();
      }
    };

    BufferWhenSubscriber.prototype.openBuffer = function () {
      var closingSubscription = this.closingSubscription;

      if (closingSubscription) {
        this.remove(closingSubscription);
        closingSubscription.unsubscribe();
      }

      var buffer = this.buffer;

      if (this.buffer) {
        this.destination.next(buffer);
      }

      this.buffer = [];
      var closingNotifier = tryCatch(this.closingSelector)();

      if (closingNotifier === errorObject) {
        this.error(errorObject.e);
      } else {
        closingSubscription = new Subscription();
        this.closingSubscription = closingSubscription;
        this.add(closingSubscription);
        this.subscribing = true;
        closingSubscription.add(subscribeToResult(this, closingNotifier));
        this.subscribing = false;
      }
    };

    return BufferWhenSubscriber;
  }(OuterSubscriber);

  /** PURE_IMPORTS_START tslib,.._OuterSubscriber,.._util_subscribeToResult PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var CatchSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(CatchSubscriber, _super);

    function CatchSubscriber(destination, selector, caught) {
      var _this = _super.call(this, destination) || this;

      _this.selector = selector;
      _this.caught = caught;
      return _this;
    } // NOTE: overriding `error` instead of `_error` because we don't want
    // to have this flag this subscriber as `isStopped`. We can mimic the
    // behavior of the RetrySubscriber (from the `retry` operator), where
    // we unsubscribe from our source chain, reset our Subscriber flags,
    // then subscribe to the selector result.


    CatchSubscriber.prototype.error = function (err) {
      if (!this.isStopped) {
        var result = void 0;

        try {
          result = this.selector(err, this.caught);
        } catch (err2) {
          _super.prototype.error.call(this, err2);

          return;
        }

        this._unsubscribeAndRecycle();

        this.add(subscribeToResult(this, result));
      }
    };

    return CatchSubscriber;
  }(OuterSubscriber);

  /** PURE_IMPORTS_START .._Observable,.._Subscription,.._util_subscribeToArray PURE_IMPORTS_END */
  function fromArray(input, scheduler) {
    if (!scheduler) {
      return new Observable(subscribeToArray(input));
    } else {
      return new Observable(function (subscriber) {
        var sub = new Subscription();
        var i = 0;
        sub.add(scheduler.schedule(function () {
          if (i === input.length) {
            subscriber.complete();
            return;
          }

          subscriber.next(input[i++]);

          if (!subscriber.closed) {
            sub.add(this.schedule());
          }
        }));
        return sub;
      });
    }
  }

  /** PURE_IMPORTS_START tslib,.._util_isScheduler,.._util_isArray,.._OuterSubscriber,.._util_subscribeToResult,._fromArray PURE_IMPORTS_END */
  var NONE = {};
  /* tslint:enable:max-line-length */

  /**
   * Combines multiple Observables to create an Observable whose values are
   * calculated from the latest values of each of its input Observables.
   *
   * <span class="informal">Whenever any input Observable emits a value, it
   * computes a formula using the latest values from all the inputs, then emits
   * the output of that formula.</span>
   *
   * <img src="./img/combineLatest.png" width="100%">
   *
   * `combineLatest` combines the values from all the Observables passed as
   * arguments. This is done by subscribing to each Observable in order and,
   * whenever any Observable emits, collecting an array of the most recent
   * values from each Observable. So if you pass `n` Observables to operator,
   * returned Observable will always emit an array of `n` values, in order
   * corresponding to order of passed Observables (value from the first Observable
   * on the first place and so on).
   *
   * Static version of `combineLatest` accepts either an array of Observables
   * or each Observable can be put directly as an argument. Note that array of
   * Observables is good choice, if you don't know beforehand how many Observables
   * you will combine. Passing empty array will result in Observable that
   * completes immediately.
   *
   * To ensure output array has always the same length, `combineLatest` will
   * actually wait for all input Observables to emit at least once,
   * before it starts emitting results. This means if some Observable emits
   * values before other Observables started emitting, all that values but last
   * will be lost. On the other hand, is some Observable does not emit value but
   * completes, resulting Observable will complete at the same moment without
   * emitting anything, since it will be now impossible to include value from
   * completed Observable in resulting array. Also, if some input Observable does
   * not emit any value and never completes, `combineLatest` will also never emit
   * and never complete, since, again, it will wait for all streams to emit some
   * value.
   *
   * If at least one Observable was passed to `combineLatest` and all passed Observables
   * emitted something, resulting Observable will complete when all combined
   * streams complete. So even if some Observable completes, result of
   * `combineLatest` will still emit values when other Observables do. In case
   * of completed Observable, its value from now on will always be the last
   * emitted value. On the other hand, if any Observable errors, `combineLatest`
   * will error immediately as well, and all other Observables will be unsubscribed.
   *
   * `combineLatest` accepts as optional parameter `project` function, which takes
   * as arguments all values that would normally be emitted by resulting Observable.
   * `project` can return any kind of value, which will be then emitted by Observable
   * instead of default array. Note that `project` does not take as argument that array
   * of values, but values themselves. That means default `project` can be imagined
   * as function that takes all its arguments and puts them into an array.
   *
   *
   * @example <caption>Combine two timer Observables</caption>
   * const firstTimer = Rx.Observable.timer(0, 1000); // emit 0, 1, 2... after every second, starting from now
   * const secondTimer = Rx.Observable.timer(500, 1000); // emit 0, 1, 2... after every second, starting 0,5s from now
   * const combinedTimers = Rx.Observable.combineLatest(firstTimer, secondTimer);
   * combinedTimers.subscribe(value => console.log(value));
   * // Logs
   * // [0, 0] after 0.5s
   * // [1, 0] after 1s
   * // [1, 1] after 1.5s
   * // [2, 1] after 2s
   *
   *
   * @example <caption>Combine an array of Observables</caption>
   * const observables = [1, 5, 10].map(
   *   n => Rx.Observable.of(n).delay(n * 1000).startWith(0) // emit 0 and then emit n after n seconds
   * );
   * const combined = Rx.Observable.combineLatest(observables);
   * combined.subscribe(value => console.log(value));
   * // Logs
   * // [0, 0, 0] immediately
   * // [1, 0, 0] after 1s
   * // [1, 5, 0] after 5s
   * // [1, 5, 10] after 10s
   *
   *
   * @example <caption>Use project function to dynamically calculate the Body-Mass Index</caption>
   * var weight = Rx.Observable.of(70, 72, 76, 79, 75);
   * var height = Rx.Observable.of(1.76, 1.77, 1.78);
   * var bmi = Rx.Observable.combineLatest(weight, height, (w, h) => w / (h * h));
   * bmi.subscribe(x => console.log('BMI is ' + x));
   *
   * // With output to console:
   * // BMI is 24.212293388429753
   * // BMI is 23.93948099205209
   * // BMI is 23.671253629592222
   *
   *
   * @see {@link combineAll}
   * @see {@link merge}
   * @see {@link withLatestFrom}
   *
   * @param {ObservableInput} observable1 An input Observable to combine with other Observables.
   * @param {ObservableInput} observable2 An input Observable to combine with other Observables.
   * More than one input Observables may be given as arguments
   * or an array of Observables may be given as the first argument.
   * @param {function} [project] An optional function to project the values from
   * the combined latest values into a new value on the output Observable.
   * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to
   * each input Observable.
   * @return {Observable} An Observable of projected values from the most recent
   * values from each input Observable, or an array of the most recent values from
   * each input Observable.
   * @static true
   * @name combineLatest
   * @owner Observable
   */

  function combineLatest() {
    var observables = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      observables[_i] = arguments[_i];
    }

    var project = null;
    var scheduler = null;

    if (isScheduler(observables[observables.length - 1])) {
      scheduler = observables.pop();
    }

    if (typeof observables[observables.length - 1] === 'function') {
      project = observables.pop();
    } // if the first and only other argument besides the resultSelector is an array
    // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`


    if (observables.length === 1 && isArray(observables[0])) {
      observables = observables[0];
    }

    return fromArray(observables, scheduler).lift(new CombineLatestOperator(project));
  }

  var CombineLatestOperator =
  /*@__PURE__*/

  /*@__PURE__*/
  function () {
    function CombineLatestOperator(project) {
      this.project = project;
    }

    CombineLatestOperator.prototype.call = function (subscriber, source) {
      return source.subscribe(new CombineLatestSubscriber(subscriber, this.project));
    };

    return CombineLatestOperator;
  }();
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */

  var CombineLatestSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(CombineLatestSubscriber, _super);

    function CombineLatestSubscriber(destination, project) {
      var _this = _super.call(this, destination) || this;

      _this.project = project;
      _this.active = 0;
      _this.values = [];
      _this.observables = [];
      return _this;
    }

    CombineLatestSubscriber.prototype._next = function (observable) {
      this.values.push(NONE);
      this.observables.push(observable);
    };

    CombineLatestSubscriber.prototype._complete = function () {
      var observables = this.observables;
      var len = observables.length;

      if (len === 0) {
        this.destination.complete();
      } else {
        this.active = len;
        this.toRespond = len;

        for (var i = 0; i < len; i++) {
          var observable = observables[i];
          this.add(subscribeToResult(this, observable, observable, i));
        }
      }
    };

    CombineLatestSubscriber.prototype.notifyComplete = function (unused) {
      if ((this.active -= 1) === 0) {
        this.destination.complete();
      }
    };

    CombineLatestSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
      var values = this.values;
      var oldVal = values[outerIndex];
      var toRespond = !this.toRespond ? 0 : oldVal === NONE ? --this.toRespond : this.toRespond;
      values[outerIndex] = innerValue;

      if (toRespond === 0) {
        if (this.project) {
          this._tryProject(values);
        } else {
          this.destination.next(values.slice());
        }
      }
    };

    CombineLatestSubscriber.prototype._tryProject = function (values) {
      var result;

      try {
        result = this.project.apply(this, values);
      } catch (err) {
        this.destination.error(err);
        return;
      }

      this.destination.next(result);
    };

    return CombineLatestSubscriber;
  }(OuterSubscriber);

  /** PURE_IMPORTS_START .._observable_combineLatest PURE_IMPORTS_END */

  /** PURE_IMPORTS_START tslib,.._util_subscribeToResult,.._OuterSubscriber PURE_IMPORTS_END */
  /* tslint:enable:max-line-length */

  /**
   * Projects each source value to an Observable which is merged in the output
   * Observable.
   *
   * <span class="informal">Maps each value to an Observable, then flattens all of
   * these inner Observables using {@link mergeAll}.</span>
   *
   * <img src="./img/mergeMap.png" width="100%">
   *
   * Returns an Observable that emits items based on applying a function that you
   * supply to each item emitted by the source Observable, where that function
   * returns an Observable, and then merging those resulting Observables and
   * emitting the results of this merger.
   *
   * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>
   * var letters = Rx.Observable.of('a', 'b', 'c');
   * var result = letters.mergeMap(x =>
   *   Rx.Observable.interval(1000).map(i => x+i)
   * );
   * result.subscribe(x => console.log(x));
   *
   * // Results in the following:
   * // a0
   * // b0
   * // c0
   * // a1
   * // b1
   * // c1
   * // continues to list a,b,c with respective ascending integers
   *
   * @see {@link concatMap}
   * @see {@link exhaustMap}
   * @see {@link merge}
   * @see {@link mergeAll}
   * @see {@link mergeMapTo}
   * @see {@link mergeScan}
   * @see {@link switchMap}
   *
   * @param {function(value: T, ?index: number): ObservableInput} project A function
   * that, when applied to an item emitted by the source Observable, returns an
   * Observable.
   * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
   * Observables being subscribed to concurrently.
   * @return {Observable} An Observable that emits the result of applying the
   * projection function (and the optional `resultSelector`) to each item emitted
   * by the source Observable and merging the results of the Observables obtained
   * from this transformation.
   * @method mergeMap
   * @owner Observable
   */

  function mergeMap(project, concurrent) {
    if (concurrent === void 0) {
      concurrent = Number.POSITIVE_INFINITY;
    }

    return function mergeMapOperatorFunction(source) {
      return source.lift(new MergeMapOperator(project, concurrent));
    };
  }

  var MergeMapOperator =
  /*@__PURE__*/

  /*@__PURE__*/
  function () {
    function MergeMapOperator(project, concurrent) {
      if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
      }

      this.project = project;
      this.concurrent = concurrent;
    }

    MergeMapOperator.prototype.call = function (observer, source) {
      return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
    };

    return MergeMapOperator;
  }();
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */

  var MergeMapSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(MergeMapSubscriber, _super);

    function MergeMapSubscriber(destination, project, concurrent) {
      if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
      }

      var _this = _super.call(this, destination) || this;

      _this.project = project;
      _this.concurrent = concurrent;
      _this.hasCompleted = false;
      _this.buffer = [];
      _this.active = 0;
      _this.index = 0;
      return _this;
    }

    MergeMapSubscriber.prototype._next = function (value) {
      if (this.active < this.concurrent) {
        this._tryNext(value);
      } else {
        this.buffer.push(value);
      }
    };

    MergeMapSubscriber.prototype._tryNext = function (value) {
      var result;
      var index = this.index++;

      try {
        result = this.project(value, index);
      } catch (err) {
        this.destination.error(err);
        return;
      }

      this.active++;

      this._innerSub(result, value, index);
    };

    MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {
      this.add(subscribeToResult(this, ish, value, index));
    };

    MergeMapSubscriber.prototype._complete = function () {
      this.hasCompleted = true;

      if (this.active === 0 && this.buffer.length === 0) {
        this.destination.complete();
      }
    };

    MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
      this.destination.next(innerValue);
    };

    MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {
      var buffer = this.buffer;
      this.remove(innerSub);
      this.active--;

      if (buffer.length > 0) {
        this._next(buffer.shift());
      } else if (this.active === 0 && this.hasCompleted) {
        this.destination.complete();
      }
    };

    return MergeMapSubscriber;
  }(OuterSubscriber);

  /** PURE_IMPORTS_START  PURE_IMPORTS_END */
  function identity(x) {
    return x;
  }

  /** PURE_IMPORTS_START ._mergeMap,.._util_identity PURE_IMPORTS_END */
  /**
   * Converts a higher-order Observable into a first-order Observable which
   * concurrently delivers all values that are emitted on the inner Observables.
   *
   * <span class="informal">Flattens an Observable-of-Observables.</span>
   *
   * <img src="./img/mergeAll.png" width="100%">
   *
   * `mergeAll` subscribes to an Observable that emits Observables, also known as
   * a higher-order Observable. Each time it observes one of these emitted inner
   * Observables, it subscribes to that and delivers all the values from the
   * inner Observable on the output Observable. The output Observable only
   * completes once all inner Observables have completed. Any error delivered by
   * a inner Observable will be immediately emitted on the output Observable.
   *
   * @example <caption>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</caption>
   * var clicks = Rx.Observable.fromEvent(document, 'click');
   * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));
   * var firstOrder = higherOrder.mergeAll();
   * firstOrder.subscribe(x => console.log(x));
   *
   * @example <caption>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</caption>
   * var clicks = Rx.Observable.fromEvent(document, 'click');
   * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));
   * var firstOrder = higherOrder.mergeAll(2);
   * firstOrder.subscribe(x => console.log(x));
   *
   * @see {@link combineAll}
   * @see {@link concatAll}
   * @see {@link exhaust}
   * @see {@link merge}
   * @see {@link mergeMap}
   * @see {@link mergeMapTo}
   * @see {@link mergeScan}
   * @see {@link switch}
   * @see {@link zipAll}
   *
   * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner
   * Observables being subscribed to concurrently.
   * @return {Observable} An Observable that emits values coming from all the
   * inner Observables emitted by the source Observable.
   * @method mergeAll
   * @owner Observable
   */

  function mergeAll(concurrent) {
    if (concurrent === void 0) {
      concurrent = Number.POSITIVE_INFINITY;
    }

    return mergeMap(identity, concurrent);
  }

  /** PURE_IMPORTS_START ._mergeAll PURE_IMPORTS_END */

  /** PURE_IMPORTS_START ._mergeMap PURE_IMPORTS_END */

  /** PURE_IMPORTS_START ._concatMap PURE_IMPORTS_END */

  /** PURE_IMPORTS_START tslib,.._Subscriber PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var CountSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(CountSubscriber, _super);

    function CountSubscriber(destination, predicate, source) {
      var _this = _super.call(this, destination) || this;

      _this.predicate = predicate;
      _this.source = source;
      _this.count = 0;
      _this.index = 0;
      return _this;
    }

    CountSubscriber.prototype._next = function (value) {
      if (this.predicate) {
        this._tryPredicate(value);
      } else {
        this.count++;
      }
    };

    CountSubscriber.prototype._tryPredicate = function (value) {
      var result;

      try {
        result = this.predicate(value, this.index++, this.source);
      } catch (err) {
        this.destination.error(err);
        return;
      }

      if (result) {
        this.count++;
      }
    };

    CountSubscriber.prototype._complete = function () {
      this.destination.next(this.count);
      this.destination.complete();
    };

    return CountSubscriber;
  }(Subscriber);

  /** PURE_IMPORTS_START tslib,.._OuterSubscriber,.._util_subscribeToResult PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var DebounceSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(DebounceSubscriber, _super);

    function DebounceSubscriber(destination, durationSelector) {
      var _this = _super.call(this, destination) || this;

      _this.durationSelector = durationSelector;
      _this.hasValue = false;
      _this.durationSubscription = null;
      return _this;
    }

    DebounceSubscriber.prototype._next = function (value) {
      try {
        var result = this.durationSelector.call(this, value);

        if (result) {
          this._tryNext(value, result);
        }
      } catch (err) {
        this.destination.error(err);
      }
    };

    DebounceSubscriber.prototype._complete = function () {
      this.emitValue();
      this.destination.complete();
    };

    DebounceSubscriber.prototype._tryNext = function (value, duration) {
      var subscription = this.durationSubscription;
      this.value = value;
      this.hasValue = true;

      if (subscription) {
        subscription.unsubscribe();
        this.remove(subscription);
      }

      subscription = subscribeToResult(this, duration);

      if (subscription && !subscription.closed) {
        this.add(this.durationSubscription = subscription);
      }
    };

    DebounceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
      this.emitValue();
    };

    DebounceSubscriber.prototype.notifyComplete = function () {
      this.emitValue();
    };

    DebounceSubscriber.prototype.emitValue = function () {
      if (this.hasValue) {
        var value = this.value;
        var subscription = this.durationSubscription;

        if (subscription) {
          this.durationSubscription = null;
          subscription.unsubscribe();
          this.remove(subscription);
        } // This must be done *before* passing the value
        // along to the destination because it's possible for
        // the value to synchronously re-enter this operator
        // recursively if the duration selector Observable
        // emits synchronously


        this.value = null;
        this.hasValue = false;

        _super.prototype._next.call(this, value);
      }
    };

    return DebounceSubscriber;
  }(OuterSubscriber);

  /** PURE_IMPORTS_START tslib,.._Subscriber,.._scheduler_async PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var DebounceTimeSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(DebounceTimeSubscriber, _super);

    function DebounceTimeSubscriber(destination, dueTime, scheduler) {
      var _this = _super.call(this, destination) || this;

      _this.dueTime = dueTime;
      _this.scheduler = scheduler;
      _this.debouncedSubscription = null;
      _this.lastValue = null;
      _this.hasValue = false;
      return _this;
    }

    DebounceTimeSubscriber.prototype._next = function (value) {
      this.clearDebounce();
      this.lastValue = value;
      this.hasValue = true;
      this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));
    };

    DebounceTimeSubscriber.prototype._complete = function () {
      this.debouncedNext();
      this.destination.complete();
    };

    DebounceTimeSubscriber.prototype.debouncedNext = function () {
      this.clearDebounce();

      if (this.hasValue) {
        var lastValue = this.lastValue; // This must be done *before* passing the value
        // along to the destination because it's possible for
        // the value to synchronously re-enter this operator
        // recursively when scheduled with things like
        // VirtualScheduler/TestScheduler.

        this.lastValue = null;
        this.hasValue = false;
        this.destination.next(lastValue);
      }
    };

    DebounceTimeSubscriber.prototype.clearDebounce = function () {
      var debouncedSubscription = this.debouncedSubscription;

      if (debouncedSubscription !== null) {
        this.remove(debouncedSubscription);
        debouncedSubscription.unsubscribe();
        this.debouncedSubscription = null;
      }
    };

    return DebounceTimeSubscriber;
  }(Subscriber);

  function dispatchNext(subscriber) {
    subscriber.debouncedNext();
  }

  /** PURE_IMPORTS_START tslib,.._Subscriber PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var DefaultIfEmptySubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(DefaultIfEmptySubscriber, _super);

    function DefaultIfEmptySubscriber(destination, defaultValue) {
      var _this = _super.call(this, destination) || this;

      _this.defaultValue = defaultValue;
      _this.isEmpty = true;
      return _this;
    }

    DefaultIfEmptySubscriber.prototype._next = function (value) {
      this.isEmpty = false;
      this.destination.next(value);
    };

    DefaultIfEmptySubscriber.prototype._complete = function () {
      if (this.isEmpty) {
        this.destination.next(this.defaultValue);
      }

      this.destination.complete();
    };

    return DefaultIfEmptySubscriber;
  }(Subscriber);

  /** PURE_IMPORTS_START  PURE_IMPORTS_END */

  /** PURE_IMPORTS_START .._Observable PURE_IMPORTS_END */
  /**
   * The same Observable instance returned by any call to {@link empty} without a
   * {@link Scheduler}. It is preferrable to use this over `empty()`.
   */

  var EMPTY =
  /*@__PURE__*/
  new Observable(function (subscriber) {
    return subscriber.complete();
  });
  /**
   * Creates an Observable that emits no items to the Observer and immediately
   * emits a complete notification.
   *
   * <span class="informal">Just emits 'complete', and nothing else.
   * </span>
   *
   * <img src="./img/empty.png" width="100%">
   *
   * This static operator is useful for creating a simple Observable that only
   * emits the complete notification. It can be used for composing with other
   * Observables, such as in a {@link mergeMap}.
   *
   * @example <caption>Emit the number 7, then complete.</caption>
   * var result = Rx.Observable.empty().startWith(7);
   * result.subscribe(x => console.log(x));
   *
   * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>
   * var interval = Rx.Observable.interval(1000);
   * var result = interval.mergeMap(x =>
   *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()
   * );
   * result.subscribe(x => console.log(x));
   *
   * // Results in the following to the console:
   * // x is equal to the count on the interval eg(0,1,2,3,...)
   * // x will occur every 1000ms
   * // if x % 2 is equal to 1 print abc
   * // if x % 2 is not equal to 1 nothing will be output
   *
   * @see {@link create}
   * @see {@link never}
   * @see {@link of}
   * @see {@link throw}
   *
   * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
   * the emission of the complete notification.
   * @return {Observable} An "empty" Observable: emits only the complete
   * notification.
   * @static true
   * @name empty
   * @owner Observable
   */

  function empty$2(scheduler) {
    return scheduler ? emptyScheduled(scheduler) : EMPTY;
  }
  function emptyScheduled(scheduler) {
    return new Observable(function (subscriber) {
      return scheduler.schedule(function () {
        return subscriber.complete();
      });
    });
  }

  /** PURE_IMPORTS_START .._Observable PURE_IMPORTS_END */
  function scalar(value) {
    var result = new Observable(function (subscriber) {
      subscriber.next(value);
      subscriber.complete();
    });
    result._isScalar = true;
    result.value = value;
    return result;
  }

  /** PURE_IMPORTS_START .._util_isScheduler,._fromArray,._empty,._scalar PURE_IMPORTS_END */
  function of() {
    var args = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }

    var scheduler = args[args.length - 1];

    if (isScheduler(scheduler)) {
      args.pop();
    } else {
      scheduler = undefined;
    }

    switch (args.length) {
      case 0:
        return empty$2(scheduler);

      case 1:
        return scheduler ? fromArray(args, scheduler) : scalar(args[0]);

      default:
        return fromArray(args, scheduler);
    }
  }

  /** PURE_IMPORTS_START .._Observable PURE_IMPORTS_END */
  /**
   * Creates an Observable that emits no items to the Observer and immediately
   * emits an error notification.
   *
   * <span class="informal">Just emits 'error', and nothing else.
   * </span>
   *
   * <img src="./img/throw.png" width="100%">
   *
   * This static operator is useful for creating a simple Observable that only
   * emits the error notification. It can be used for composing with other
   * Observables, such as in a {@link mergeMap}.
   *
   * @example <caption>Emit the number 7, then emit an error.</caption>
   * import { throwError, concat, of } from 'rxjs/create';
   *
   * const result = concat(of(7), throwError(new Error('oops!')));
   * result.subscribe(x => console.log(x), e => console.error(e));
   *
   * @example <caption>Map and flatten numbers to the sequence 'a', 'b', 'c', but throw an error for 13</caption>
   * import { throwError, interval, of } from 'rxjs/create';
   * import { mergeMap } from 'rxjs/operators';
   *
   * interval(1000).pipe(
   *   mergeMap(x => x === 13 ?
   *     throwError('Thirteens are bad') :
   *     of('a', 'b', 'c')
   *   )
   * ).subscribe(x => console.log(x), e => console.error(e));
   *
   * @see {@link create}
   * @see {@link empty}
   * @see {@link never}
   * @see {@link of}
   *
   * @param {any} error The particular Error to pass to the error notification.
   * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
   * the emission of the error notification.
   * @return {Observable} An error Observable: emits only the error notification
   * using the given error argument.
   * @static true
   * @name throw
   * @owner Observable
   */

  function throwError(error, scheduler) {
    if (!scheduler) {
      return new Observable(function (subscriber) {
        return subscriber.error(error);
      });
    } else {
      return new Observable(function (subscriber) {
        return scheduler.schedule(dispatch$1, 0, {
          error: error,
          subscriber: subscriber
        });
      });
    }
  }

  function dispatch$1(_a) {
    var error = _a.error,
        subscriber = _a.subscriber;
    subscriber.error(error);
  }

  /** PURE_IMPORTS_START ._observable_empty,._observable_of,._observable_throwError PURE_IMPORTS_END */
  /**
   * Represents a push-based event or value that an {@link Observable} can emit.
   * This class is particularly useful for operators that manage notifications,
   * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and
   * others. Besides wrapping the actual delivered value, it also annotates it
   * with metadata of, for instance, what type of push message it is (`next`,
   * `error`, or `complete`).
   *
   * @see {@link materialize}
   * @see {@link dematerialize}
   * @see {@link observeOn}
   *
   * @class Notification<T>
   */

  var Notification =
  /*@__PURE__*/

  /*@__PURE__*/
  function () {
    function Notification(kind, value, error) {
      this.kind = kind;
      this.value = value;
      this.error = error;
      this.hasValue = kind === 'N';
    }
    /**
     * Delivers to the given `observer` the value wrapped by this Notification.
     * @param {Observer} observer
     * @return
     */


    Notification.prototype.observe = function (observer) {
      switch (this.kind) {
        case 'N':
          return observer.next && observer.next(this.value);

        case 'E':
          return observer.error && observer.error(this.error);

        case 'C':
          return observer.complete && observer.complete();
      }
    };
    /**
     * Given some {@link Observer} callbacks, deliver the value represented by the
     * current Notification to the correctly corresponding callback.
     * @param {function(value: T): void} next An Observer `next` callback.
     * @param {function(err: any): void} [error] An Observer `error` callback.
     * @param {function(): void} [complete] An Observer `complete` callback.
     * @return {any}
     */


    Notification.prototype.do = function (next, error, complete) {
      var kind = this.kind;

      switch (kind) {
        case 'N':
          return next && next(this.value);

        case 'E':
          return error && error(this.error);

        case 'C':
          return complete && complete();
      }
    };
    /**
     * Takes an Observer or its individual callback functions, and calls `observe`
     * or `do` methods accordingly.
     * @param {Observer|function(value: T): void} nextOrObserver An Observer or
     * the `next` callback.
     * @param {function(err: any): void} [error] An Observer `error` callback.
     * @param {function(): void} [complete] An Observer `complete` callback.
     * @return {any}
     */


    Notification.prototype.accept = function (nextOrObserver, error, complete) {
      if (nextOrObserver && typeof nextOrObserver.next === 'function') {
        return this.observe(nextOrObserver);
      } else {
        return this.do(nextOrObserver, error, complete);
      }
    };
    /**
     * Returns a simple Observable that just delivers the notification represented
     * by this Notification instance.
     * @return {any}
     */


    Notification.prototype.toObservable = function () {
      var kind = this.kind;

      switch (kind) {
        case 'N':
          return of(this.value);

        case 'E':
          return throwError(this.error);

        case 'C':
          return empty$2();
      }

      throw new Error('unexpected notification kind value');
    };
    /**
     * A shortcut to create a Notification instance of the type `next` from a
     * given value.
     * @param {T} value The `next` value.
     * @return {Notification<T>} The "next" Notification representing the
     * argument.
     */


    Notification.createNext = function (value) {
      if (typeof value !== 'undefined') {
        return new Notification('N', value);
      }

      return Notification.undefinedValueNotification;
    };
    /**
     * A shortcut to create a Notification instance of the type `error` from a
     * given error.
     * @param {any} [err] The `error` error.
     * @return {Notification<T>} The "error" Notification representing the
     * argument.
     */


    Notification.createError = function (err) {
      return new Notification('E', undefined, err);
    };
    /**
     * A shortcut to create a Notification instance of the type `complete`.
     * @return {Notification<any>} The valueless "complete" Notification.
     */


    Notification.createComplete = function () {
      return Notification.completeNotification;
    };

    Notification.completeNotification = new Notification('C');
    Notification.undefinedValueNotification = new Notification('N', undefined);
    return Notification;
  }();

  /** PURE_IMPORTS_START tslib,.._scheduler_async,.._util_isDate,.._Subscriber,.._Notification PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var DelaySubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(DelaySubscriber, _super);

    function DelaySubscriber(destination, delay, scheduler) {
      var _this = _super.call(this, destination) || this;

      _this.delay = delay;
      _this.scheduler = scheduler;
      _this.queue = [];
      _this.active = false;
      _this.errored = false;
      return _this;
    }

    DelaySubscriber.dispatch = function (state) {
      var source = state.source;
      var queue = source.queue;
      var scheduler = state.scheduler;
      var destination = state.destination;

      while (queue.length > 0 && queue[0].time - scheduler.now() <= 0) {
        queue.shift().notification.observe(destination);
      }

      if (queue.length > 0) {
        var delay_1 = Math.max(0, queue[0].time - scheduler.now());
        this.schedule(state, delay_1);
      } else {
        source.active = false;
      }
    };

    DelaySubscriber.prototype._schedule = function (scheduler) {
      this.active = true;
      this.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {
        source: this,
        destination: this.destination,
        scheduler: scheduler
      }));
    };

    DelaySubscriber.prototype.scheduleNotification = function (notification) {
      if (this.errored === true) {
        return;
      }

      var scheduler = this.scheduler;
      var message = new DelayMessage(scheduler.now() + this.delay, notification);
      this.queue.push(message);

      if (this.active === false) {
        this._schedule(scheduler);
      }
    };

    DelaySubscriber.prototype._next = function (value) {
      this.scheduleNotification(Notification.createNext(value));
    };

    DelaySubscriber.prototype._error = function (err) {
      this.errored = true;
      this.queue = [];
      this.destination.error(err);
    };

    DelaySubscriber.prototype._complete = function () {
      this.scheduleNotification(Notification.createComplete());
    };

    return DelaySubscriber;
  }(Subscriber);

  var DelayMessage =
  /*@__PURE__*/

  /*@__PURE__*/
  function () {
    function DelayMessage(time, notification) {
      this.time = time;
      this.notification = notification;
    }

    return DelayMessage;
  }();

  /** PURE_IMPORTS_START tslib,.._Subscriber,.._Observable,.._OuterSubscriber,.._util_subscribeToResult PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var DelayWhenSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(DelayWhenSubscriber, _super);

    function DelayWhenSubscriber(destination, delayDurationSelector) {
      var _this = _super.call(this, destination) || this;

      _this.delayDurationSelector = delayDurationSelector;
      _this.completed = false;
      _this.delayNotifierSubscriptions = [];
      _this.values = [];
      return _this;
    }

    DelayWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
      this.destination.next(outerValue);
      this.removeSubscription(innerSub);
      this.tryComplete();
    };

    DelayWhenSubscriber.prototype.notifyError = function (error, innerSub) {
      this._error(error);
    };

    DelayWhenSubscriber.prototype.notifyComplete = function (innerSub) {
      var value = this.removeSubscription(innerSub);

      if (value) {
        this.destination.next(value);
      }

      this.tryComplete();
    };

    DelayWhenSubscriber.prototype._next = function (value) {
      try {
        var delayNotifier = this.delayDurationSelector(value);

        if (delayNotifier) {
          this.tryDelay(delayNotifier, value);
        }
      } catch (err) {
        this.destination.error(err);
      }
    };

    DelayWhenSubscriber.prototype._complete = function () {
      this.completed = true;
      this.tryComplete();
    };

    DelayWhenSubscriber.prototype.removeSubscription = function (subscription) {
      subscription.unsubscribe();
      var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);
      var value = null;

      if (subscriptionIdx !== -1) {
        value = this.values[subscriptionIdx];
        this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);
        this.values.splice(subscriptionIdx, 1);
      }

      return value;
    };

    DelayWhenSubscriber.prototype.tryDelay = function (delayNotifier, value) {
      var notifierSubscription = subscribeToResult(this, delayNotifier, value);

      if (notifierSubscription && !notifierSubscription.closed) {
        this.add(notifierSubscription);
        this.delayNotifierSubscriptions.push(notifierSubscription);
      }

      this.values.push(value);
    };

    DelayWhenSubscriber.prototype.tryComplete = function () {
      if (this.completed && this.delayNotifierSubscriptions.length === 0) {
        this.destination.complete();
      }
    };

    return DelayWhenSubscriber;
  }(OuterSubscriber);
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var SubscriptionDelayObservable =
  /*@__PURE__*/
  function (_super) {
    __extends(SubscriptionDelayObservable, _super);

    function SubscriptionDelayObservable(source, subscriptionDelay) {
      var _this = _super.call(this) || this;

      _this.source = source;
      _this.subscriptionDelay = subscriptionDelay;
      return _this;
    }

    SubscriptionDelayObservable.prototype._subscribe = function (subscriber) {
      this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));
    };

    return SubscriptionDelayObservable;
  }(Observable);
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var SubscriptionDelaySubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(SubscriptionDelaySubscriber, _super);

    function SubscriptionDelaySubscriber(parent, source) {
      var _this = _super.call(this) || this;

      _this.parent = parent;
      _this.source = source;
      _this.sourceSubscribed = false;
      return _this;
    }

    SubscriptionDelaySubscriber.prototype._next = function (unused) {
      this.subscribeToSource();
    };

    SubscriptionDelaySubscriber.prototype._error = function (err) {
      this.unsubscribe();
      this.parent.error(err);
    };

    SubscriptionDelaySubscriber.prototype._complete = function () {
      this.subscribeToSource();
    };

    SubscriptionDelaySubscriber.prototype.subscribeToSource = function () {
      if (!this.sourceSubscribed) {
        this.sourceSubscribed = true;
        this.unsubscribe();
        this.source.subscribe(this.parent);
      }
    };

    return SubscriptionDelaySubscriber;
  }(Subscriber);

  /** PURE_IMPORTS_START tslib,.._Subscriber PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var DeMaterializeSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(DeMaterializeSubscriber, _super);

    function DeMaterializeSubscriber(destination) {
      return _super.call(this, destination) || this;
    }

    DeMaterializeSubscriber.prototype._next = function (value) {
      value.observe(this.destination);
    };

    return DeMaterializeSubscriber;
  }(Subscriber);

  var _validateCollection = function (it, TYPE) {
    if (!_isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
    return it;
  };

  var dP$2 = _objectDp.f;









  var fastKey = _meta.fastKey;

  var SIZE = _descriptors ? '_s' : 'size';

  var getEntry = function (that, key) {
    // fast case
    var index = fastKey(key);
    var entry;
    if (index !== 'F') return that._i[index];
    // frozen object case
    for (entry = that._f; entry; entry = entry.n) {
      if (entry.k == key) return entry;
    }
  };

  var _collectionStrong = {
    getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
      var C = wrapper(function (that, iterable) {
        _anInstance(that, C, NAME, '_i');
        that._t = NAME;         // collection type
        that._i = _objectCreate(null); // index
        that._f = undefined;    // first entry
        that._l = undefined;    // last entry
        that[SIZE] = 0;         // size
        if (iterable != undefined) _forOf(iterable, IS_MAP, that[ADDER], that);
      });
      _redefineAll(C.prototype, {
        // 23.1.3.1 Map.prototype.clear()
        // 23.2.3.2 Set.prototype.clear()
        clear: function clear() {
          for (var that = _validateCollection(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
            entry.r = true;
            if (entry.p) entry.p = entry.p.n = undefined;
            delete data[entry.i];
          }
          that._f = that._l = undefined;
          that[SIZE] = 0;
        },
        // 23.1.3.3 Map.prototype.delete(key)
        // 23.2.3.4 Set.prototype.delete(value)
        'delete': function (key) {
          var that = _validateCollection(this, NAME);
          var entry = getEntry(that, key);
          if (entry) {
            var next = entry.n;
            var prev = entry.p;
            delete that._i[entry.i];
            entry.r = true;
            if (prev) prev.n = next;
            if (next) next.p = prev;
            if (that._f == entry) that._f = next;
            if (that._l == entry) that._l = prev;
            that[SIZE]--;
          } return !!entry;
        },
        // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
        // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
        forEach: function forEach(callbackfn /* , that = undefined */) {
          _validateCollection(this, NAME);
          var f = _ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
          var entry;
          while (entry = entry ? entry.n : this._f) {
            f(entry.v, entry.k, this);
            // revert to the last existing entry
            while (entry && entry.r) entry = entry.p;
          }
        },
        // 23.1.3.7 Map.prototype.has(key)
        // 23.2.3.7 Set.prototype.has(value)
        has: function has(key) {
          return !!getEntry(_validateCollection(this, NAME), key);
        }
      });
      if (_descriptors) dP$2(C.prototype, 'size', {
        get: function () {
          return _validateCollection(this, NAME)[SIZE];
        }
      });
      return C;
    },
    def: function (that, key, value) {
      var entry = getEntry(that, key);
      var prev, index;
      // change existing entry
      if (entry) {
        entry.v = value;
      // create new entry
      } else {
        that._l = entry = {
          i: index = fastKey(key, true), // <- index
          k: key,                        // <- key
          v: value,                      // <- value
          p: prev = that._l,             // <- previous entry
          n: undefined,                  // <- next entry
          r: false                       // <- removed
        };
        if (!that._f) that._f = entry;
        if (prev) prev.n = entry;
        that[SIZE]++;
        // add to index
        if (index !== 'F') that._i[index] = entry;
      } return that;
    },
    getEntry: getEntry,
    setStrong: function (C, NAME, IS_MAP) {
      // add .keys, .values, .entries, [@@iterator]
      // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
      _iterDefine(C, NAME, function (iterated, kind) {
        this._t = _validateCollection(iterated, NAME); // target
        this._k = kind;                     // kind
        this._l = undefined;                // previous
      }, function () {
        var that = this;
        var kind = that._k;
        var entry = that._l;
        // revert to the last existing entry
        while (entry && entry.r) entry = entry.p;
        // get next entry
        if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
          // or finish the iteration
          that._t = undefined;
          return _iterStep(1);
        }
        // return step by kind
        if (kind == 'keys') return _iterStep(0, entry.k);
        if (kind == 'values') return _iterStep(0, entry.v);
        return _iterStep(0, [entry.k, entry.v]);
      }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

      // add [@@species], 23.1.2.2, 23.2.2.2
      _setSpecies(NAME);
    }
  };

  // Works with __proto__ only. Old v8 can't work with null proto objects.
  /* eslint-disable no-proto */


  var check = function (O, proto) {
    _anObject(O);
    if (!_isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
  };
  var _setProto = {
    set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
      function (test, buggy, set) {
        try {
          set = _ctx(Function.call, _objectGopd.f(Object.prototype, '__proto__').set, 2);
          set(test, []);
          buggy = !(test instanceof Array);
        } catch (e) { buggy = true; }
        return function setPrototypeOf(O, proto) {
          check(O, proto);
          if (buggy) O.__proto__ = proto;
          else set(O, proto);
          return O;
        };
      }({}, false) : undefined),
    check: check
  };

  var setPrototypeOf = _setProto.set;
  var _inheritIfRequired = function (that, target, C) {
    var S = target.constructor;
    var P;
    if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && _isObject(P) && setPrototypeOf) {
      setPrototypeOf(that, P);
    } return that;
  };

  var _collection = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
    var Base = _global[NAME];
    var C = Base;
    var ADDER = IS_MAP ? 'set' : 'add';
    var proto = C && C.prototype;
    var O = {};
    var fixMethod = function (KEY) {
      var fn = proto[KEY];
      _redefine(proto, KEY,
        KEY == 'delete' ? function (a) {
          return IS_WEAK && !_isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
        } : KEY == 'has' ? function has(a) {
          return IS_WEAK && !_isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
        } : KEY == 'get' ? function get(a) {
          return IS_WEAK && !_isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
        } : KEY == 'add' ? function add(a) { fn.call(this, a === 0 ? 0 : a); return this; }
          : function set(a, b) { fn.call(this, a === 0 ? 0 : a, b); return this; }
      );
    };
    if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !_fails(function () {
      new C().entries().next();
    }))) {
      // create collection constructor
      C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
      _redefineAll(C.prototype, methods);
      _meta.NEED = true;
    } else {
      var instance = new C();
      // early implementations not supports chaining
      var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
      // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
      var THROWS_ON_PRIMITIVES = _fails(function () { instance.has(1); });
      // most early implementations doesn't supports iterables, most modern - not close it correctly
      var ACCEPT_ITERABLES = _iterDetect(function (iter) { new C(iter); }); // eslint-disable-line no-new
      // for early implementations -0 and +0 not the same
      var BUGGY_ZERO = !IS_WEAK && _fails(function () {
        // V8 ~ Chromium 42- fails only with 5+ elements
        var $instance = new C();
        var index = 5;
        while (index--) $instance[ADDER](index, index);
        return !$instance.has(-0);
      });
      if (!ACCEPT_ITERABLES) {
        C = wrapper(function (target, iterable) {
          _anInstance(target, C, NAME);
          var that = _inheritIfRequired(new Base(), target, C);
          if (iterable != undefined) _forOf(iterable, IS_MAP, that[ADDER], that);
          return that;
        });
        C.prototype = proto;
        proto.constructor = C;
      }
      if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
        fixMethod('delete');
        fixMethod('has');
        IS_MAP && fixMethod('get');
      }
      if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
      // weak collections should not contains .clear method
      if (IS_WEAK && proto.clear) delete proto.clear;
    }

    _setToStringTag(C, NAME);

    O[NAME] = C;
    _export(_export.G + _export.W + _export.F * (C != Base), O);

    if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

    return C;
  };

  var SET = 'Set';

  // 23.2 Set Objects
  var es6_set = _collection(SET, function (get) {
    return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
  }, {
    // 23.2.3.1 Set.prototype.add(value)
    add: function add(value) {
      return _collectionStrong.def(_validateCollection(this, SET), value = value === 0 ? 0 : value, value);
    }
  }, _collectionStrong);

  if (!Set) {
    throw (
      /*@__PURE__*/
      new Error('Set is not present, please polyfill')
    );
  }
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var DistinctSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(DistinctSubscriber, _super);

    function DistinctSubscriber(destination, keySelector, flushes) {
      var _this = _super.call(this, destination) || this;

      _this.keySelector = keySelector;
      _this.values = new Set();

      if (flushes) {
        _this.add(subscribeToResult(_this, flushes));
      }

      return _this;
    }

    DistinctSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
      this.values.clear();
    };

    DistinctSubscriber.prototype.notifyError = function (error, innerSub) {
      this._error(error);
    };

    DistinctSubscriber.prototype._next = function (value) {
      if (this.keySelector) {
        this._useKeySelector(value);
      } else {
        this._finalizeNext(value, value);
      }
    };

    DistinctSubscriber.prototype._useKeySelector = function (value) {
      var key;
      var destination = this.destination;

      try {
        key = this.keySelector(value);
      } catch (err) {
        destination.error(err);
        return;
      }

      this._finalizeNext(key, value);
    };

    DistinctSubscriber.prototype._finalizeNext = function (key, value) {
      var values = this.values;

      if (!values.has(key)) {
        values.add(key);
        this.destination.next(value);
      }
    };

    return DistinctSubscriber;
  }(OuterSubscriber);

  /** PURE_IMPORTS_START tslib,.._Subscriber,.._util_tryCatch,.._util_errorObject PURE_IMPORTS_END */
  /* tslint:enable:max-line-length */

  /**
   * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item.
   *
   * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.
   *
   * If a comparator function is not provided, an equality check is used by default.
   *
   * @example <caption>A simple example with numbers</caption>
   * Observable.of(1, 1, 2, 2, 2, 1, 1, 2, 3, 3, 4)
   *   .distinctUntilChanged()
   *   .subscribe(x => console.log(x)); // 1, 2, 1, 2, 3, 4
   *
   * @example <caption>An example using a compare function</caption>
   * interface Person {
   *    age: number,
   *    name: string
   * }
   *
   * Observable.of<Person>(
   *     { age: 4, name: 'Foo'},
   *     { age: 7, name: 'Bar'},
   *     { age: 5, name: 'Foo'})
   *     { age: 6, name: 'Foo'})
   *     .distinctUntilChanged((p: Person, q: Person) => p.name === q.name)
   *     .subscribe(x => console.log(x));
   *
   * // displays:
   * // { age: 4, name: 'Foo' }
   * // { age: 7, name: 'Bar' }
   * // { age: 5, name: 'Foo' }
   *
   * @see {@link distinct}
   * @see {@link distinctUntilKeyChanged}
   *
   * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.
   * @return {Observable} An Observable that emits items from the source Observable with distinct values.
   * @method distinctUntilChanged
   * @owner Observable
   */

  function distinctUntilChanged(compare, keySelector) {
    return function (source) {
      return source.lift(new DistinctUntilChangedOperator(compare, keySelector));
    };
  }

  var DistinctUntilChangedOperator =
  /*@__PURE__*/

  /*@__PURE__*/
  function () {
    function DistinctUntilChangedOperator(compare, keySelector) {
      this.compare = compare;
      this.keySelector = keySelector;
    }

    DistinctUntilChangedOperator.prototype.call = function (subscriber, source) {
      return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
    };

    return DistinctUntilChangedOperator;
  }();
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var DistinctUntilChangedSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(DistinctUntilChangedSubscriber, _super);

    function DistinctUntilChangedSubscriber(destination, compare, keySelector) {
      var _this = _super.call(this, destination) || this;

      _this.keySelector = keySelector;
      _this.hasKey = false;

      if (typeof compare === 'function') {
        _this.compare = compare;
      }

      return _this;
    }

    DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {
      return x === y;
    };

    DistinctUntilChangedSubscriber.prototype._next = function (value) {
      var keySelector = this.keySelector;
      var key = value;

      if (keySelector) {
        key = tryCatch(this.keySelector)(value);

        if (key === errorObject) {
          return this.destination.error(errorObject.e);
        }
      }

      var result = false;

      if (this.hasKey) {
        result = tryCatch(this.compare)(this.key, key);

        if (result === errorObject) {
          return this.destination.error(errorObject.e);
        }
      } else {
        this.hasKey = true;
      }

      if (Boolean(result) === false) {
        this.key = key;
        this.destination.next(value);
      }
    };

    return DistinctUntilChangedSubscriber;
  }(Subscriber);

  /** PURE_IMPORTS_START ._distinctUntilChanged PURE_IMPORTS_END */

  /** PURE_IMPORTS_START tslib PURE_IMPORTS_END */
  /**
   * An error thrown when an element was queried at a certain index of an
   * Observable, but no such index or position exists in that sequence.
   *
   * @see {@link elementAt}
   * @see {@link take}
   * @see {@link takeLast}
   *
   * @class ArgumentOutOfRangeError
   */

  var ArgumentOutOfRangeError =
  /*@__PURE__*/
  function (_super) {
    __extends(ArgumentOutOfRangeError, _super);

    function ArgumentOutOfRangeError() {
      var _this = _super.call(this, 'argument out of range') || this;

      _this.name = 'ArgumentOutOfRangeError';
      Object.setPrototypeOf(_this, ArgumentOutOfRangeError.prototype);
      return _this;
    }

    return ArgumentOutOfRangeError;
  }(Error);

  /** PURE_IMPORTS_START tslib,.._Subscriber,.._util_ArgumentOutOfRangeError PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var ElementAtSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(ElementAtSubscriber, _super);

    function ElementAtSubscriber(destination, index, defaultValue) {
      var _this = _super.call(this, destination) || this;

      _this.index = index;
      _this.defaultValue = defaultValue;
      return _this;
    }

    ElementAtSubscriber.prototype._next = function (x) {
      if (this.index-- === 0) {
        this.destination.next(x);
        this.destination.complete();
      }
    };

    ElementAtSubscriber.prototype._complete = function () {
      var destination = this.destination;

      if (this.index >= 0) {
        if (typeof this.defaultValue !== 'undefined') {
          destination.next(this.defaultValue);
        } else {
          destination.error(new ArgumentOutOfRangeError());
        }
      }

      destination.complete();
    };

    return ElementAtSubscriber;
  }(Subscriber);

  /** PURE_IMPORTS_START tslib,.._Subscriber PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var EverySubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(EverySubscriber, _super);

    function EverySubscriber(destination, predicate, thisArg, source) {
      var _this = _super.call(this, destination) || this;

      _this.predicate = predicate;
      _this.thisArg = thisArg;
      _this.source = source;
      _this.index = 0;
      _this.thisArg = thisArg || _this;
      return _this;
    }

    EverySubscriber.prototype.notifyComplete = function (everyValueMatch) {
      this.destination.next(everyValueMatch);
      this.destination.complete();
    };

    EverySubscriber.prototype._next = function (value) {
      var result = false;

      try {
        result = this.predicate.call(this.thisArg, value, this.index++, this.source);
      } catch (err) {
        this.destination.error(err);
        return;
      }

      if (!result) {
        this.notifyComplete(false);
      }
    };

    EverySubscriber.prototype._complete = function () {
      this.notifyComplete(true);
    };

    return EverySubscriber;
  }(Subscriber);

  /** PURE_IMPORTS_START tslib,.._OuterSubscriber,.._util_subscribeToResult PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var SwitchFirstSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(SwitchFirstSubscriber, _super);

    function SwitchFirstSubscriber(destination) {
      var _this = _super.call(this, destination) || this;

      _this.hasCompleted = false;
      _this.hasSubscription = false;
      return _this;
    }

    SwitchFirstSubscriber.prototype._next = function (value) {
      if (!this.hasSubscription) {
        this.hasSubscription = true;
        this.add(subscribeToResult(this, value));
      }
    };

    SwitchFirstSubscriber.prototype._complete = function () {
      this.hasCompleted = true;

      if (!this.hasSubscription) {
        this.destination.complete();
      }
    };

    SwitchFirstSubscriber.prototype.notifyComplete = function (innerSub) {
      this.remove(innerSub);
      this.hasSubscription = false;

      if (this.hasCompleted) {
        this.destination.complete();
      }
    };

    return SwitchFirstSubscriber;
  }(OuterSubscriber);

  /** PURE_IMPORTS_START tslib,.._OuterSubscriber,.._util_subscribeToResult PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var SwitchFirstMapSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(SwitchFirstMapSubscriber, _super);

    function SwitchFirstMapSubscriber(destination, project) {
      var _this = _super.call(this, destination) || this;

      _this.project = project;
      _this.hasSubscription = false;
      _this.hasCompleted = false;
      _this.index = 0;
      return _this;
    }

    SwitchFirstMapSubscriber.prototype._next = function (value) {
      if (!this.hasSubscription) {
        this.tryNext(value);
      }
    };

    SwitchFirstMapSubscriber.prototype.tryNext = function (value) {
      var index = this.index++;
      var destination = this.destination;

      try {
        var result = this.project(value, index);
        this.hasSubscription = true;
        this.add(subscribeToResult(this, result, value, index));
      } catch (err) {
        destination.error(err);
      }
    };

    SwitchFirstMapSubscriber.prototype._complete = function () {
      this.hasCompleted = true;

      if (!this.hasSubscription) {
        this.destination.complete();
      }
    };

    SwitchFirstMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
      this.destination.next(innerValue);
    };

    SwitchFirstMapSubscriber.prototype.notifyError = function (err) {
      this.destination.error(err);
    };

    SwitchFirstMapSubscriber.prototype.notifyComplete = function (innerSub) {
      this.remove(innerSub);
      this.hasSubscription = false;

      if (this.hasCompleted) {
        this.destination.complete();
      }
    };

    return SwitchFirstMapSubscriber;
  }(OuterSubscriber);

  /** PURE_IMPORTS_START tslib,.._util_tryCatch,.._util_errorObject,.._OuterSubscriber,.._util_subscribeToResult PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */

  var ExpandSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(ExpandSubscriber, _super);

    function ExpandSubscriber(destination, project, concurrent, scheduler) {
      var _this = _super.call(this, destination) || this;

      _this.project = project;
      _this.concurrent = concurrent;
      _this.scheduler = scheduler;
      _this.index = 0;
      _this.active = 0;
      _this.hasCompleted = false;

      if (concurrent < Number.POSITIVE_INFINITY) {
        _this.buffer = [];
      }

      return _this;
    }

    ExpandSubscriber.dispatch = function (arg) {
      var subscriber = arg.subscriber,
          result = arg.result,
          value = arg.value,
          index = arg.index;
      subscriber.subscribeToProjection(result, value, index);
    };

    ExpandSubscriber.prototype._next = function (value) {
      var destination = this.destination;

      if (destination.closed) {
        this._complete();

        return;
      }

      var index = this.index++;

      if (this.active < this.concurrent) {
        destination.next(value);
        var result = tryCatch(this.project)(value, index);

        if (result === errorObject) {
          destination.error(errorObject.e);
        } else if (!this.scheduler) {
          this.subscribeToProjection(result, value, index);
        } else {
          var state = {
            subscriber: this,
            result: result,
            value: value,
            index: index
          };
          this.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state));
        }
      } else {
        this.buffer.push(value);
      }
    };

    ExpandSubscriber.prototype.subscribeToProjection = function (result, value, index) {
      this.active++;
      this.add(subscribeToResult(this, result, value, index));
    };

    ExpandSubscriber.prototype._complete = function () {
      this.hasCompleted = true;

      if (this.hasCompleted && this.active === 0) {
        this.destination.complete();
      }
    };

    ExpandSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
      this._next(innerValue);
    };

    ExpandSubscriber.prototype.notifyComplete = function (innerSub) {
      var buffer = this.buffer;
      this.remove(innerSub);
      this.active--;

      if (buffer && buffer.length > 0) {
        this._next(buffer.shift());
      }

      if (this.hasCompleted && this.active === 0) {
        this.destination.complete();
      }
    };

    return ExpandSubscriber;
  }(OuterSubscriber);

  /** PURE_IMPORTS_START tslib,.._Subscriber PURE_IMPORTS_END */
  /* tslint:enable:max-line-length */

  /**
   * Filter items emitted by the source Observable by only emitting those that
   * satisfy a specified predicate.
   *
   * <span class="informal">Like
   * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),
   * it only emits a value from the source if it passes a criterion function.</span>
   *
   * <img src="./img/filter.png" width="100%">
   *
   * Similar to the well-known `Array.prototype.filter` method, this operator
   * takes values from the source Observable, passes them through a `predicate`
   * function and only emits those values that yielded `true`.
   *
   * @example <caption>Emit only click events whose target was a DIV element</caption>
   * var clicks = Rx.Observable.fromEvent(document, 'click');
   * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');
   * clicksOnDivs.subscribe(x => console.log(x));
   *
   * @see {@link distinct}
   * @see {@link distinctUntilChanged}
   * @see {@link distinctUntilKeyChanged}
   * @see {@link ignoreElements}
   * @see {@link partition}
   * @see {@link skip}
   *
   * @param {function(value: T, index: number): boolean} predicate A function that
   * evaluates each value emitted by the source Observable. If it returns `true`,
   * the value is emitted, if `false` the value is not passed to the output
   * Observable. The `index` parameter is the number `i` for the i-th source
   * emission that has happened since the subscription, starting from the number
   * `0`.
   * @param {any} [thisArg] An optional argument to determine the value of `this`
   * in the `predicate` function.
   * @return {Observable} An Observable of values from the source that were
   * allowed by the `predicate` function.
   * @method filter
   * @owner Observable
   */

  function filter(predicate, thisArg) {
    return function filterOperatorFunction(source) {
      return source.lift(new FilterOperator(predicate, thisArg));
    };
  }

  var FilterOperator =
  /*@__PURE__*/

  /*@__PURE__*/
  function () {
    function FilterOperator(predicate, thisArg) {
      this.predicate = predicate;
      this.thisArg = thisArg;
    }

    FilterOperator.prototype.call = function (subscriber, source) {
      return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
    };

    return FilterOperator;
  }();
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var FilterSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(FilterSubscriber, _super);

    function FilterSubscriber(destination, predicate, thisArg) {
      var _this = _super.call(this, destination) || this;

      _this.predicate = predicate;
      _this.thisArg = thisArg;
      _this.count = 0;
      return _this;
    } // the try catch block below is left specifically for
    // optimization and perf reasons. a tryCatcher is not necessary here.


    FilterSubscriber.prototype._next = function (value) {
      var result;

      try {
        result = this.predicate.call(this.thisArg, value, this.count++);
      } catch (err) {
        this.destination.error(err);
        return;
      }

      if (result) {
        this.destination.next(value);
      }
    };

    return FilterSubscriber;
  }(Subscriber);

  /** PURE_IMPORTS_START tslib,.._Subscriber,.._Subscription PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var FinallySubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(FinallySubscriber, _super);

    function FinallySubscriber(destination, callback) {
      var _this = _super.call(this, destination) || this;

      _this.add(new Subscription(callback));

      return _this;
    }

    return FinallySubscriber;
  }(Subscriber);

  /** PURE_IMPORTS_START tslib,.._Subscriber PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */

  var FindValueSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(FindValueSubscriber, _super);

    function FindValueSubscriber(destination, predicate, source, yieldIndex, thisArg) {
      var _this = _super.call(this, destination) || this;

      _this.predicate = predicate;
      _this.source = source;
      _this.yieldIndex = yieldIndex;
      _this.thisArg = thisArg;
      _this.index = 0;
      return _this;
    }

    FindValueSubscriber.prototype.notifyComplete = function (value) {
      var destination = this.destination;
      destination.next(value);
      destination.complete();
    };

    FindValueSubscriber.prototype._next = function (value) {
      var _a = this,
          predicate = _a.predicate,
          thisArg = _a.thisArg;

      var index = this.index++;

      try {
        var result = predicate.call(thisArg || this, value, index, this.source);

        if (result) {
          this.notifyComplete(this.yieldIndex ? index : value);
        }
      } catch (err) {
        this.destination.error(err);
      }
    };

    FindValueSubscriber.prototype._complete = function () {
      this.notifyComplete(this.yieldIndex ? -1 : undefined);
    };

    return FindValueSubscriber;
  }(Subscriber);

  /** PURE_IMPORTS_START .._operators_find PURE_IMPORTS_END */

  /** PURE_IMPORTS_START tslib PURE_IMPORTS_END */
  /**
   * An error thrown when an Observable or a sequence was queried but has no
   * elements.
   *
   * @see {@link first}
   * @see {@link last}
   * @see {@link single}
   *
   * @class EmptyError
   */

  var EmptyError =
  /*@__PURE__*/
  function (_super) {
    __extends(EmptyError, _super);

    function EmptyError() {
      var _this = _super.call(this, 'no elements in sequence') || this;

      _this.name = 'EmptyError';
      Object.setPrototypeOf(_this, EmptyError.prototype);
      return _this;
    }

    return EmptyError;
  }(Error);

  /** PURE_IMPORTS_START tslib,.._Subscriber,.._util_EmptyError PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var FirstSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(FirstSubscriber, _super);

    function FirstSubscriber(destination, predicate, defaultValue, source) {
      var _this = _super.call(this, destination) || this;

      _this.predicate = predicate;
      _this.defaultValue = defaultValue;
      _this.source = source;
      _this.index = 0;
      _this.hasCompleted = false;
      _this._emitted = false;
      return _this;
    }

    FirstSubscriber.prototype._next = function (value) {
      var index = this.index++;

      if (this.predicate) {
        this._tryPredicate(value, index);
      } else {
        this._emit(value);
      }
    };

    FirstSubscriber.prototype._tryPredicate = function (value, index) {
      var result;

      try {
        result = this.predicate(value, index, this.source);
      } catch (err) {
        this.destination.error(err);
        return;
      }

      if (result) {
        this._emit(value);
      }
    };

    FirstSubscriber.prototype._emit = function (value) {
      var destination = this.destination;

      if (!this._emitted) {
        this._emitted = true;
        destination.next(value);
        destination.complete();
        this.hasCompleted = true;
      }
    };

    FirstSubscriber.prototype._complete = function () {
      var destination = this.destination;

      if (!this.hasCompleted && typeof this.defaultValue !== 'undefined') {
        destination.next(this.defaultValue);
        destination.complete();
      } else if (!this.hasCompleted) {
        destination.error(new EmptyError());
      }
    };

    return FirstSubscriber;
  }(Subscriber);

  var MAP = 'Map';

  // 23.1 Map Objects
  var es6_map = _collection(MAP, function (get) {
    return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
  }, {
    // 23.1.3.6 Map.prototype.get(key)
    get: function get(key) {
      var entry = _collectionStrong.getEntry(_validateCollection(this, MAP), key);
      return entry && entry.v;
    },
    // 23.1.3.9 Map.prototype.set(key, value)
    set: function set(key, value) {
      return _collectionStrong.def(_validateCollection(this, MAP), key === 0 ? 0 : key, value);
    }
  }, _collectionStrong, true);

  /** PURE_IMPORTS_START tslib PURE_IMPORTS_END */
  /**
   * An error thrown when an action is invalid because the object has been
   * unsubscribed.
   *
   * @see {@link Subject}
   * @see {@link BehaviorSubject}
   *
   * @class ObjectUnsubscribedError
   */

  var ObjectUnsubscribedError =
  /*@__PURE__*/
  function (_super) {
    __extends(ObjectUnsubscribedError, _super);

    function ObjectUnsubscribedError() {
      var _this = _super.call(this, 'object unsubscribed') || this;

      _this.name = 'ObjectUnsubscribedError';
      Object.setPrototypeOf(_this, ObjectUnsubscribedError.prototype);
      return _this;
    }

    return ObjectUnsubscribedError;
  }(Error);

  /** PURE_IMPORTS_START tslib,._Subscription PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */

  var SubjectSubscription =
  /*@__PURE__*/
  function (_super) {
    __extends(SubjectSubscription, _super);

    function SubjectSubscription(subject, subscriber) {
      var _this = _super.call(this) || this;

      _this.subject = subject;
      _this.subscriber = subscriber;
      _this.closed = false;
      return _this;
    }

    SubjectSubscription.prototype.unsubscribe = function () {
      if (this.closed) {
        return;
      }

      this.closed = true;
      var subject = this.subject;
      var observers = subject.observers;
      this.subject = null;

      if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
        return;
      }

      var subscriberIndex = observers.indexOf(this.subscriber);

      if (subscriberIndex !== -1) {
        observers.splice(subscriberIndex, 1);
      }
    };

    return SubjectSubscription;
  }(Subscription);

  /** PURE_IMPORTS_START tslib,._Observable,._Subscriber,._Subscription,._util_ObjectUnsubscribedError,._SubjectSubscription,.._internal_symbol_rxSubscriber PURE_IMPORTS_END */
  /**
   * @class SubjectSubscriber<T>
   */

  var SubjectSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(SubjectSubscriber, _super);

    function SubjectSubscriber(destination) {
      var _this = _super.call(this, destination) || this;

      _this.destination = destination;
      return _this;
    }

    return SubjectSubscriber;
  }(Subscriber);
  /**
   * @class Subject<T>
   */

  var Subject =
  /*@__PURE__*/
  function (_super) {
    __extends(Subject, _super);

    function Subject() {
      var _this = _super.call(this) || this;

      _this.observers = [];
      _this.closed = false;
      _this.isStopped = false;
      _this.hasError = false;
      _this.thrownError = null;
      return _this;
    }

    Subject.prototype[rxSubscriber] = function () {
      return new SubjectSubscriber(this);
    };

    Subject.prototype.lift = function (operator) {
      var subject = new AnonymousSubject(this, this);
      subject.operator = operator;
      return subject;
    };

    Subject.prototype.next = function (value) {
      if (this.closed) {
        throw new ObjectUnsubscribedError();
      }

      if (!this.isStopped) {
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();

        for (var i = 0; i < len; i++) {
          copy[i].next(value);
        }
      }
    };

    Subject.prototype.error = function (err) {
      if (this.closed) {
        throw new ObjectUnsubscribedError();
      }

      this.hasError = true;
      this.thrownError = err;
      this.isStopped = true;
      var observers = this.observers;
      var len = observers.length;
      var copy = observers.slice();

      for (var i = 0; i < len; i++) {
        copy[i].error(err);
      }

      this.observers.length = 0;
    };

    Subject.prototype.complete = function () {
      if (this.closed) {
        throw new ObjectUnsubscribedError();
      }

      this.isStopped = true;
      var observers = this.observers;
      var len = observers.length;
      var copy = observers.slice();

      for (var i = 0; i < len; i++) {
        copy[i].complete();
      }

      this.observers.length = 0;
    };

    Subject.prototype.unsubscribe = function () {
      this.isStopped = true;
      this.closed = true;
      this.observers = null;
    };

    Subject.prototype._trySubscribe = function (subscriber) {
      if (this.closed) {
        throw new ObjectUnsubscribedError();
      } else {
        return _super.prototype._trySubscribe.call(this, subscriber);
      }
    };

    Subject.prototype._subscribe = function (subscriber) {
      if (this.closed) {
        throw new ObjectUnsubscribedError();
      } else if (this.hasError) {
        subscriber.error(this.thrownError);
        return Subscription.EMPTY;
      } else if (this.isStopped) {
        subscriber.complete();
        return Subscription.EMPTY;
      } else {
        this.observers.push(subscriber);
        return new SubjectSubscription(this, subscriber);
      }
    };

    Subject.prototype.asObservable = function () {
      var observable = new Observable();
      observable.source = this;
      return observable;
    };

    Subject.create = function (destination, source) {
      return new AnonymousSubject(destination, source);
    };

    return Subject;
  }(Observable);
  /**
   * @class AnonymousSubject<T>
   */

  var AnonymousSubject =
  /*@__PURE__*/
  function (_super) {
    __extends(AnonymousSubject, _super);

    function AnonymousSubject(destination, source) {
      var _this = _super.call(this) || this;

      _this.destination = destination;
      _this.source = source;
      return _this;
    }

    AnonymousSubject.prototype.next = function (value) {
      var destination = this.destination;

      if (destination && destination.next) {
        destination.next(value);
      }
    };

    AnonymousSubject.prototype.error = function (err) {
      var destination = this.destination;

      if (destination && destination.error) {
        this.destination.error(err);
      }
    };

    AnonymousSubject.prototype.complete = function () {
      var destination = this.destination;

      if (destination && destination.complete) {
        this.destination.complete();
      }
    };

    AnonymousSubject.prototype._subscribe = function (subscriber) {
      var source = this.source;

      if (source) {
        return this.source.subscribe(subscriber);
      } else {
        return Subscription.EMPTY;
      }
    };

    return AnonymousSubject;
  }(Subject);

  /** Assert that map is present for this operator */

  if (!Map) {
    throw (
      /*@__PURE__*/
      new Error('Map not found, please polyfill')
    );
  }
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var GroupBySubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(GroupBySubscriber, _super);

    function GroupBySubscriber(destination, keySelector, elementSelector, durationSelector, subjectSelector) {
      var _this = _super.call(this, destination) || this;

      _this.keySelector = keySelector;
      _this.elementSelector = elementSelector;
      _this.durationSelector = durationSelector;
      _this.subjectSelector = subjectSelector;
      _this.groups = null;
      _this.attemptedToUnsubscribe = false;
      _this.count = 0;
      return _this;
    }

    GroupBySubscriber.prototype._next = function (value) {
      var key;

      try {
        key = this.keySelector(value);
      } catch (err) {
        this.error(err);
        return;
      }

      this._group(value, key);
    };

    GroupBySubscriber.prototype._group = function (value, key) {
      var groups = this.groups;

      if (!groups) {
        groups = this.groups = new Map();
      }

      var group = groups.get(key);
      var element;

      if (this.elementSelector) {
        try {
          element = this.elementSelector(value);
        } catch (err) {
          this.error(err);
        }
      } else {
        element = value;
      }

      if (!group) {
        group = this.subjectSelector ? this.subjectSelector() : new Subject();
        groups.set(key, group);
        var groupedObservable = new GroupedObservable(key, group, this);
        this.destination.next(groupedObservable);

        if (this.durationSelector) {
          var duration = void 0;

          try {
            duration = this.durationSelector(new GroupedObservable(key, group));
          } catch (err) {
            this.error(err);
            return;
          }

          this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));
        }
      }

      if (!group.closed) {
        group.next(element);
      }
    };

    GroupBySubscriber.prototype._error = function (err) {
      var groups = this.groups;

      if (groups) {
        groups.forEach(function (group, key) {
          group.error(err);
        });
        groups.clear();
      }

      this.destination.error(err);
    };

    GroupBySubscriber.prototype._complete = function () {
      var groups = this.groups;

      if (groups) {
        groups.forEach(function (group, key) {
          group.complete();
        });
        groups.clear();
      }

      this.destination.complete();
    };

    GroupBySubscriber.prototype.removeGroup = function (key) {
      this.groups.delete(key);
    };

    GroupBySubscriber.prototype.unsubscribe = function () {
      if (!this.closed) {
        this.attemptedToUnsubscribe = true;

        if (this.count === 0) {
          _super.prototype.unsubscribe.call(this);
        }
      }
    };

    return GroupBySubscriber;
  }(Subscriber);
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var GroupDurationSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(GroupDurationSubscriber, _super);

    function GroupDurationSubscriber(key, group, parent) {
      var _this = _super.call(this, group) || this;

      _this.key = key;
      _this.group = group;
      _this.parent = parent;
      return _this;
    }

    GroupDurationSubscriber.prototype._next = function (value) {
      this.complete();
    };

    GroupDurationSubscriber.prototype._unsubscribe = function () {
      var _a = this,
          parent = _a.parent,
          key = _a.key;

      this.key = this.parent = null;

      if (parent) {
        parent.removeGroup(key);
      }
    };

    return GroupDurationSubscriber;
  }(Subscriber);
  /**
   * An Observable representing values belonging to the same group represented by
   * a common key. The values emitted by a GroupedObservable come from the source
   * Observable. The common key is available as the field `key` on a
   * GroupedObservable instance.
   *
   * @class GroupedObservable<K, T>
   */


  var GroupedObservable =
  /*@__PURE__*/
  function (_super) {
    __extends(GroupedObservable, _super);

    function GroupedObservable(key, groupSubject, refCountSubscription) {
      var _this = _super.call(this) || this;

      _this.key = key;
      _this.groupSubject = groupSubject;
      _this.refCountSubscription = refCountSubscription;
      return _this;
    }

    GroupedObservable.prototype._subscribe = function (subscriber) {
      var subscription = new Subscription();

      var _a = this,
          refCountSubscription = _a.refCountSubscription,
          groupSubject = _a.groupSubject;

      if (refCountSubscription && !refCountSubscription.closed) {
        subscription.add(new InnerRefCountSubscription(refCountSubscription));
      }

      subscription.add(groupSubject.subscribe(subscriber));
      return subscription;
    };

    return GroupedObservable;
  }(Observable);
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */

  var InnerRefCountSubscription =
  /*@__PURE__*/
  function (_super) {
    __extends(InnerRefCountSubscription, _super);

    function InnerRefCountSubscription(parent) {
      var _this = _super.call(this) || this;

      _this.parent = parent;
      parent.count++;
      return _this;
    }

    InnerRefCountSubscription.prototype.unsubscribe = function () {
      var parent = this.parent;

      if (!parent.closed && !this.closed) {
        _super.prototype.unsubscribe.call(this);

        parent.count -= 1;

        if (parent.count === 0 && parent.attemptedToUnsubscribe) {
          parent.unsubscribe();
        }
      }
    };

    return InnerRefCountSubscription;
  }(Subscription);

  /** PURE_IMPORTS_START tslib,.._Subscriber PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var IgnoreElementsSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(IgnoreElementsSubscriber, _super);

    function IgnoreElementsSubscriber() {
      return _super !== null && _super.apply(this, arguments) || this;
    }

    IgnoreElementsSubscriber.prototype._next = function (unused) {// Do nothing
    };

    return IgnoreElementsSubscriber;
  }(Subscriber);

  /** PURE_IMPORTS_START tslib,.._Subscriber PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var IsEmptySubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(IsEmptySubscriber, _super);

    function IsEmptySubscriber(destination) {
      return _super.call(this, destination) || this;
    }

    IsEmptySubscriber.prototype.notifyComplete = function (isEmpty) {
      var destination = this.destination;
      destination.next(isEmpty);
      destination.complete();
    };

    IsEmptySubscriber.prototype._next = function (value) {
      this.notifyComplete(false);
    };

    IsEmptySubscriber.prototype._complete = function () {
      this.notifyComplete(true);
    };

    return IsEmptySubscriber;
  }(Subscriber);

  /** PURE_IMPORTS_START tslib,.._Subscriber,.._util_EmptyError PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var LastSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(LastSubscriber, _super);

    function LastSubscriber(destination, predicate, defaultValue, source) {
      var _this = _super.call(this, destination) || this;

      _this.predicate = predicate;
      _this.defaultValue = defaultValue;
      _this.source = source;
      _this.hasValue = false;
      _this.index = 0;

      if (typeof defaultValue !== 'undefined') {
        _this.lastValue = defaultValue;
        _this.hasValue = true;
      }

      return _this;
    }

    LastSubscriber.prototype._next = function (value) {
      var index = this.index++;

      if (this.predicate) {
        this._tryPredicate(value, index);
      } else {
        this.lastValue = value;
        this.hasValue = true;
      }
    };

    LastSubscriber.prototype._tryPredicate = function (value, index) {
      var result;

      try {
        result = this.predicate(value, index, this.source);
      } catch (err) {
        this.destination.error(err);
        return;
      }

      if (result) {
        this.lastValue = value;
        this.hasValue = true;
      }
    };

    LastSubscriber.prototype._complete = function () {
      var destination = this.destination;

      if (this.hasValue) {
        destination.next(this.lastValue);
        destination.complete();
      } else {
        destination.error(new EmptyError());
      }
    };

    return LastSubscriber;
  }(Subscriber);

  /** PURE_IMPORTS_START tslib,.._Subscriber PURE_IMPORTS_END */
  /**
   * Applies a given `project` function to each value emitted by the source
   * Observable, and emits the resulting values as an Observable.
   *
   * <span class="informal">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),
   * it passes each source value through a transformation function to get
   * corresponding output values.</span>
   *
   * <img src="./img/map.png" width="100%">
   *
   * Similar to the well known `Array.prototype.map` function, this operator
   * applies a projection to each value and emits that projection in the output
   * Observable.
   *
   * @example <caption>Map every click to the clientX position of that click</caption>
   * var clicks = Rx.Observable.fromEvent(document, 'click');
   * var positions = clicks.map(ev => ev.clientX);
   * positions.subscribe(x => console.log(x));
   *
   * @see {@link mapTo}
   * @see {@link pluck}
   *
   * @param {function(value: T, index: number): R} project The function to apply
   * to each `value` emitted by the source Observable. The `index` parameter is
   * the number `i` for the i-th emission that has happened since the
   * subscription, starting from the number `0`.
   * @param {any} [thisArg] An optional argument to define what `this` is in the
   * `project` function.
   * @return {Observable<R>} An Observable that emits the values from the source
   * Observable transformed by the given `project` function.
   * @method map
   * @owner Observable
   */

  function map(project, thisArg) {
    return function mapOperation(source) {
      if (typeof project !== 'function') {
        throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
      }

      return source.lift(new MapOperator(project, thisArg));
    };
  }

  var MapOperator =
  /*@__PURE__*/

  /*@__PURE__*/
  function () {
    function MapOperator(project, thisArg) {
      this.project = project;
      this.thisArg = thisArg;
    }

    MapOperator.prototype.call = function (subscriber, source) {
      return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
    };

    return MapOperator;
  }();
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */

  var MapSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(MapSubscriber, _super);

    function MapSubscriber(destination, project, thisArg) {
      var _this = _super.call(this, destination) || this;

      _this.project = project;
      _this.count = 0;
      _this.thisArg = thisArg || _this;
      return _this;
    } // NOTE: This looks unoptimized, but it's actually purposefully NOT
    // using try/catch optimizations.


    MapSubscriber.prototype._next = function (value) {
      var result;

      try {
        result = this.project.call(this.thisArg, value, this.count++);
      } catch (err) {
        this.destination.error(err);
        return;
      }

      this.destination.next(result);
    };

    return MapSubscriber;
  }(Subscriber);

  /** PURE_IMPORTS_START tslib,.._Subscriber PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var MapToSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(MapToSubscriber, _super);

    function MapToSubscriber(destination, value) {
      var _this = _super.call(this, destination) || this;

      _this.value = value;
      return _this;
    }

    MapToSubscriber.prototype._next = function (x) {
      this.destination.next(this.value);
    };

    return MapToSubscriber;
  }(Subscriber);

  /** PURE_IMPORTS_START tslib,.._Subscriber,.._Notification PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var MaterializeSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(MaterializeSubscriber, _super);

    function MaterializeSubscriber(destination) {
      return _super.call(this, destination) || this;
    }

    MaterializeSubscriber.prototype._next = function (value) {
      this.destination.next(Notification.createNext(value));
    };

    MaterializeSubscriber.prototype._error = function (err) {
      var destination = this.destination;
      destination.next(Notification.createError(err));
      destination.complete();
    };

    MaterializeSubscriber.prototype._complete = function () {
      var destination = this.destination;
      destination.next(Notification.createComplete());
      destination.complete();
    };

    return MaterializeSubscriber;
  }(Subscriber);

  /** PURE_IMPORTS_START tslib,.._Subscriber PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var ScanSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(ScanSubscriber, _super);

    function ScanSubscriber(destination, accumulator, _seed, hasSeed) {
      var _this = _super.call(this, destination) || this;

      _this.accumulator = accumulator;
      _this._seed = _seed;
      _this.hasSeed = hasSeed;
      _this.index = 0;
      return _this;
    }

    Object.defineProperty(ScanSubscriber.prototype, "seed", {
      get: function get() {
        return this._seed;
      },
      set: function set(value) {
        this.hasSeed = true;
        this._seed = value;
      },
      enumerable: true,
      configurable: true
    });

    ScanSubscriber.prototype._next = function (value) {
      if (!this.hasSeed) {
        this.seed = value;
        this.destination.next(value);
      } else {
        return this._tryNext(value);
      }
    };

    ScanSubscriber.prototype._tryNext = function (value) {
      var index = this.index++;
      var result;

      try {
        result = this.accumulator(this.seed, value, index);
      } catch (err) {
        this.destination.error(err);
      }

      this.seed = result;
      this.destination.next(result);
    };

    return ScanSubscriber;
  }(Subscriber);

  /** PURE_IMPORTS_START tslib,.._Subscriber,.._util_ArgumentOutOfRangeError,.._observable_empty PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var TakeLastSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(TakeLastSubscriber, _super);

    function TakeLastSubscriber(destination, total) {
      var _this = _super.call(this, destination) || this;

      _this.total = total;
      _this.ring = new Array();
      _this.count = 0;
      return _this;
    }

    TakeLastSubscriber.prototype._next = function (value) {
      var ring = this.ring;
      var total = this.total;
      var count = this.count++;

      if (ring.length < total) {
        ring.push(value);
      } else {
        var index = count % total;
        ring[index] = value;
      }
    };

    TakeLastSubscriber.prototype._complete = function () {
      var destination = this.destination;
      var count = this.count;

      if (count > 0) {
        var total = this.count >= this.total ? this.total : this.count;
        var ring = this.ring;

        for (var i = 0; i < total; i++) {
          var idx = count++ % total;
          destination.next(ring[idx]);
        }
      }

      destination.complete();
    };

    return TakeLastSubscriber;
  }(Subscriber);

  /** PURE_IMPORTS_START ._scan,._takeLast,._defaultIfEmpty,.._util_pipe PURE_IMPORTS_END */

  /** PURE_IMPORTS_START ._reduce PURE_IMPORTS_END */

  /** PURE_IMPORTS_START ._mergeMap PURE_IMPORTS_END */

  /** PURE_IMPORTS_START tslib,.._util_tryCatch,.._util_errorObject,.._util_subscribeToResult,.._OuterSubscriber PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */

  var MergeScanSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(MergeScanSubscriber, _super);

    function MergeScanSubscriber(destination, accumulator, acc, concurrent) {
      var _this = _super.call(this, destination) || this;

      _this.accumulator = accumulator;
      _this.acc = acc;
      _this.concurrent = concurrent;
      _this.hasValue = false;
      _this.hasCompleted = false;
      _this.buffer = [];
      _this.active = 0;
      _this.index = 0;
      return _this;
    }

    MergeScanSubscriber.prototype._next = function (value) {
      if (this.active < this.concurrent) {
        var index = this.index++;
        var ish = tryCatch(this.accumulator)(this.acc, value);
        var destination = this.destination;

        if (ish === errorObject) {
          destination.error(errorObject.e);
        } else {
          this.active++;

          this._innerSub(ish, value, index);
        }
      } else {
        this.buffer.push(value);
      }
    };

    MergeScanSubscriber.prototype._innerSub = function (ish, value, index) {
      this.add(subscribeToResult(this, ish, value, index));
    };

    MergeScanSubscriber.prototype._complete = function () {
      this.hasCompleted = true;

      if (this.active === 0 && this.buffer.length === 0) {
        if (this.hasValue === false) {
          this.destination.next(this.acc);
        }

        this.destination.complete();
      }
    };

    MergeScanSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
      var destination = this.destination;
      this.acc = innerValue;
      this.hasValue = true;
      destination.next(innerValue);
    };

    MergeScanSubscriber.prototype.notifyComplete = function (innerSub) {
      var buffer = this.buffer;
      this.remove(innerSub);
      this.active--;

      if (buffer.length > 0) {
        this._next(buffer.shift());
      } else if (this.active === 0 && this.hasCompleted) {
        if (this.hasValue === false) {
          this.destination.next(this.acc);
        }

        this.destination.complete();
      }
    };

    return MergeScanSubscriber;
  }(OuterSubscriber);

  /** PURE_IMPORTS_START ._reduce PURE_IMPORTS_END */

  /** PURE_IMPORTS_START tslib,.._Subscriber PURE_IMPORTS_END */
  function refCount() {
    return function refCountOperatorFunction(source) {
      return source.lift(new RefCountOperator(source));
    };
  }

  var RefCountOperator =
  /*@__PURE__*/

  /*@__PURE__*/
  function () {
    function RefCountOperator(connectable) {
      this.connectable = connectable;
    }

    RefCountOperator.prototype.call = function (subscriber, source) {
      var connectable = this.connectable;
      connectable._refCount++;
      var refCounter = new RefCountSubscriber(subscriber, connectable);
      var subscription = source.subscribe(refCounter);

      if (!refCounter.closed) {
        refCounter.connection = connectable.connect();
      }

      return subscription;
    };

    return RefCountOperator;
  }();

  var RefCountSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(RefCountSubscriber, _super);

    function RefCountSubscriber(destination, connectable) {
      var _this = _super.call(this, destination) || this;

      _this.connectable = connectable;
      return _this;
    }

    RefCountSubscriber.prototype._unsubscribe = function () {
      var connectable = this.connectable;

      if (!connectable) {
        this.connection = null;
        return;
      }

      this.connectable = null;
      var refCount = connectable._refCount;

      if (refCount <= 0) {
        this.connection = null;
        return;
      }

      connectable._refCount = refCount - 1;

      if (refCount > 1) {
        this.connection = null;
        return;
      } ///
      // Compare the local RefCountSubscriber's connection Subscription to the
      // connection Subscription on the shared ConnectableObservable. In cases
      // where the ConnectableObservable source synchronously emits values, and
      // the RefCountSubscriber's downstream Observers synchronously unsubscribe,
      // execution continues to here before the RefCountOperator has a chance to
      // supply the RefCountSubscriber with the shared connection Subscription.
      // For example:
      // ```
      // Observable.range(0, 10)
      //   .publish()
      //   .refCount()
      //   .take(5)
      //   .subscribe();
      // ```
      // In order to account for this case, RefCountSubscriber should only dispose
      // the ConnectableObservable's shared connection Subscription if the
      // connection Subscription exists, *and* either:
      //   a. RefCountSubscriber doesn't have a reference to the shared connection
      //      Subscription yet, or,
      //   b. RefCountSubscriber's connection Subscription reference is identical
      //      to the shared connection Subscription
      ///


      var connection = this.connection;
      var sharedConnection = connectable._connection;
      this.connection = null;

      if (sharedConnection && (!connection || sharedConnection === connection)) {
        sharedConnection.unsubscribe();
      }
    };

    return RefCountSubscriber;
  }(Subscriber);

  /** PURE_IMPORTS_START tslib,.._Subject,.._Observable,.._Subscriber,.._Subscription,.._.._internal_operators_refCount PURE_IMPORTS_END */
  /**
   * @class ConnectableObservable<T>
   */

  var ConnectableObservable =
  /*@__PURE__*/
  function (_super) {
    __extends(ConnectableObservable, _super);

    function ConnectableObservable(source, subjectFactory) {
      var _this = _super.call(this) || this;

      _this.source = source;
      _this.subjectFactory = subjectFactory;
      _this._refCount = 0;
      /** @internal */

      _this._isComplete = false;
      return _this;
    }

    ConnectableObservable.prototype._subscribe = function (subscriber) {
      return this.getSubject().subscribe(subscriber);
    };

    ConnectableObservable.prototype.getSubject = function () {
      var subject = this._subject;

      if (!subject || subject.isStopped) {
        this._subject = this.subjectFactory();
      }

      return this._subject;
    };

    ConnectableObservable.prototype.connect = function () {
      var connection = this._connection;

      if (!connection) {
        this._isComplete = false;
        connection = this._connection = new Subscription();
        connection.add(this.source.subscribe(new ConnectableSubscriber(this.getSubject(), this)));

        if (connection.closed) {
          this._connection = null;
          connection = Subscription.EMPTY;
        } else {
          this._connection = connection;
        }
      }

      return connection;
    };

    ConnectableObservable.prototype.refCount = function () {
      return refCount()(this);
    };

    return ConnectableObservable;
  }(Observable);

  var ConnectableSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(ConnectableSubscriber, _super);

    function ConnectableSubscriber(destination, connectable) {
      var _this = _super.call(this, destination) || this;

      _this.connectable = connectable;
      return _this;
    }

    ConnectableSubscriber.prototype._error = function (err) {
      this._unsubscribe();

      _super.prototype._error.call(this, err);
    };

    ConnectableSubscriber.prototype._complete = function () {
      this.connectable._isComplete = true;

      this._unsubscribe();

      _super.prototype._complete.call(this);
    };

    ConnectableSubscriber.prototype._unsubscribe = function () {
      var connectable = this.connectable;

      if (connectable) {
        this.connectable = null;
        var connection = connectable._connection;
        connectable._refCount = 0;
        connectable._subject = null;
        connectable._connection = null;

        if (connection) {
          connection.unsubscribe();
        }
      }
    };

    return ConnectableSubscriber;
  }(SubjectSubscriber);

  var RefCountSubscriber$1 =
  /*@__PURE__*/
  function (_super) {
    __extends(RefCountSubscriber, _super);

    function RefCountSubscriber(destination, connectable) {
      var _this = _super.call(this, destination) || this;

      _this.connectable = connectable;
      return _this;
    }

    RefCountSubscriber.prototype._unsubscribe = function () {
      var connectable = this.connectable;

      if (!connectable) {
        this.connection = null;
        return;
      }

      this.connectable = null;
      var refCount$$1 = connectable._refCount;

      if (refCount$$1 <= 0) {
        this.connection = null;
        return;
      }

      connectable._refCount = refCount$$1 - 1;

      if (refCount$$1 > 1) {
        this.connection = null;
        return;
      } ///
      // Compare the local RefCountSubscriber's connection Subscription to the
      // connection Subscription on the shared ConnectableObservable. In cases
      // where the ConnectableObservable source synchronously emits values, and
      // the RefCountSubscriber's downstream Observers synchronously unsubscribe,
      // execution continues to here before the RefCountOperator has a chance to
      // supply the RefCountSubscriber with the shared connection Subscription.
      // For example:
      // ```
      // Observable.range(0, 10)
      //   .publish()
      //   .refCount()
      //   .take(5)
      //   .subscribe();
      // ```
      // In order to account for this case, RefCountSubscriber should only dispose
      // the ConnectableObservable's shared connection Subscription if the
      // connection Subscription exists, *and* either:
      //   a. RefCountSubscriber doesn't have a reference to the shared connection
      //      Subscription yet, or,
      //   b. RefCountSubscriber's connection Subscription reference is identical
      //      to the shared connection Subscription
      ///


      var connection = this.connection;
      var sharedConnection = connectable._connection;
      this.connection = null;

      if (sharedConnection && (!connection || sharedConnection === connection)) {
        sharedConnection.unsubscribe();
      }
    };

    return RefCountSubscriber;
  }(Subscriber);

  /** PURE_IMPORTS_START .._observable_ConnectableObservable PURE_IMPORTS_END */

  /** PURE_IMPORTS_START tslib,.._Subscriber,.._Notification PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */

  var ObserveOnSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(ObserveOnSubscriber, _super);

    function ObserveOnSubscriber(destination, scheduler, delay) {
      if (delay === void 0) {
        delay = 0;
      }

      var _this = _super.call(this, destination) || this;

      _this.scheduler = scheduler;
      _this.delay = delay;
      return _this;
    }

    ObserveOnSubscriber.dispatch = function (arg) {
      var notification = arg.notification,
          destination = arg.destination;
      notification.observe(destination);
      this.unsubscribe();
    };

    ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {
      this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
    };

    ObserveOnSubscriber.prototype._next = function (value) {
      this.scheduleMessage(Notification.createNext(value));
    };

    ObserveOnSubscriber.prototype._error = function (err) {
      this.scheduleMessage(Notification.createError(err));
    };

    ObserveOnSubscriber.prototype._complete = function () {
      this.scheduleMessage(Notification.createComplete());
    };

    return ObserveOnSubscriber;
  }(Subscriber);

  var ObserveOnMessage =
  /*@__PURE__*/

  /*@__PURE__*/
  function () {
    function ObserveOnMessage(notification, destination) {
      this.notification = notification;
      this.destination = destination;
    }

    return ObserveOnMessage;
  }();

  /** PURE_IMPORTS_START tslib,.._Subscriber PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var PairwiseSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(PairwiseSubscriber, _super);

    function PairwiseSubscriber(destination) {
      var _this = _super.call(this, destination) || this;

      _this.hasPrev = false;
      return _this;
    }

    PairwiseSubscriber.prototype._next = function (value) {
      if (this.hasPrev) {
        this.destination.next([this.prev, value]);
      } else {
        this.hasPrev = true;
      }

      this.prev = value;
    };

    return PairwiseSubscriber;
  }(Subscriber);

  /** PURE_IMPORTS_START  PURE_IMPORTS_END */

  /** PURE_IMPORTS_START .._util_not,._filter PURE_IMPORTS_END */

  /** PURE_IMPORTS_START ._map PURE_IMPORTS_END */

  /** PURE_IMPORTS_START .._Subject,._multicast PURE_IMPORTS_END */

  /** PURE_IMPORTS_START tslib,._Subject,._util_ObjectUnsubscribedError PURE_IMPORTS_END */
  /**
   * @class BehaviorSubject<T>
   */

  var BehaviorSubject =
  /*@__PURE__*/
  function (_super) {
    __extends(BehaviorSubject, _super);

    function BehaviorSubject(_value) {
      var _this = _super.call(this) || this;

      _this._value = _value;
      return _this;
    }

    Object.defineProperty(BehaviorSubject.prototype, "value", {
      get: function get() {
        return this.getValue();
      },
      enumerable: true,
      configurable: true
    });

    BehaviorSubject.prototype._subscribe = function (subscriber) {
      var subscription = _super.prototype._subscribe.call(this, subscriber);

      if (subscription && !subscription.closed) {
        subscriber.next(this._value);
      }

      return subscription;
    };

    BehaviorSubject.prototype.getValue = function () {
      if (this.hasError) {
        throw this.thrownError;
      } else if (this.closed) {
        throw new ObjectUnsubscribedError();
      } else {
        return this._value;
      }
    };

    BehaviorSubject.prototype.next = function (value) {
      _super.prototype.next.call(this, this._value = value);
    };

    return BehaviorSubject;
  }(Subject);

  /** PURE_IMPORTS_START .._BehaviorSubject,._multicast PURE_IMPORTS_END */

  /** PURE_IMPORTS_START tslib,._Subject,._Subscription PURE_IMPORTS_END */
  /**
   * @class AsyncSubject<T>
   */

  var AsyncSubject =
  /*@__PURE__*/
  function (_super) {
    __extends(AsyncSubject, _super);

    function AsyncSubject() {
      var _this = _super !== null && _super.apply(this, arguments) || this;

      _this.value = null;
      _this.hasNext = false;
      _this.hasCompleted = false;
      return _this;
    }

    AsyncSubject.prototype._subscribe = function (subscriber) {
      if (this.hasError) {
        subscriber.error(this.thrownError);
        return Subscription.EMPTY;
      } else if (this.hasCompleted && this.hasNext) {
        subscriber.next(this.value);
        subscriber.complete();
        return Subscription.EMPTY;
      }

      return _super.prototype._subscribe.call(this, subscriber);
    };

    AsyncSubject.prototype.next = function (value) {
      if (!this.hasCompleted) {
        this.value = value;
        this.hasNext = true;
      }
    };

    AsyncSubject.prototype.error = function (error) {
      if (!this.hasCompleted) {
        _super.prototype.error.call(this, error);
      }
    };

    AsyncSubject.prototype.complete = function () {
      this.hasCompleted = true;

      if (this.hasNext) {
        _super.prototype.next.call(this, this.value);
      }

      _super.prototype.complete.call(this);
    };

    return AsyncSubject;
  }(Subject);

  /** PURE_IMPORTS_START .._AsyncSubject,._multicast PURE_IMPORTS_END */

  /** PURE_IMPORTS_START tslib,._AsyncAction PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */

  var QueueAction =
  /*@__PURE__*/
  function (_super) {
    __extends(QueueAction, _super);

    function QueueAction(scheduler, work) {
      var _this = _super.call(this, scheduler, work) || this;

      _this.scheduler = scheduler;
      _this.work = work;
      return _this;
    }

    QueueAction.prototype.schedule = function (state, delay) {
      if (delay === void 0) {
        delay = 0;
      }

      if (delay > 0) {
        return _super.prototype.schedule.call(this, state, delay);
      }

      this.delay = delay;
      this.state = state;
      this.scheduler.flush(this);
      return this;
    };

    QueueAction.prototype.execute = function (state, delay) {
      return delay > 0 || this.closed ? _super.prototype.execute.call(this, state, delay) : this._execute(state, delay);
    };

    QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {
      if (delay === void 0) {
        delay = 0;
      } // If delay exists and is greater than 0, or if the delay is null (the
      // action wasn't rescheduled) but was originally scheduled as an async
      // action, then recycle as an async action.


      if (delay !== null && delay > 0 || delay === null && this.delay > 0) {
        return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
      } // Otherwise flush the scheduler starting with this action.


      return scheduler.flush(this);
    };

    return QueueAction;
  }(AsyncAction);

  /** PURE_IMPORTS_START tslib,._AsyncScheduler PURE_IMPORTS_END */

  var QueueScheduler =
  /*@__PURE__*/
  function (_super) {
    __extends(QueueScheduler, _super);

    function QueueScheduler() {
      return _super !== null && _super.apply(this, arguments) || this;
    }

    return QueueScheduler;
  }(AsyncScheduler);

  /** PURE_IMPORTS_START ._QueueAction,._QueueScheduler PURE_IMPORTS_END */
  /**
   *
   * Queue Scheduler
   *
   * <span class="informal">Put every next task on a queue, instead of executing it immediately</span>
   *
   * `queue` scheduler, when used with delay, behaves the same as {@link async} scheduler.
   *
   * When used without delay, it schedules given task synchronously - executes it right when
   * it is scheduled. However when called recursively, that is when inside the scheduled task,
   * another task is scheduled with queue scheduler, instead of executing immediately as well,
   * that task will be put on a queue and wait for current one to finish.
   *
   * This means that when you execute task with `queue` scheduler, you are sure it will end
   * before any other task scheduled with that scheduler will start.
   *
   * @examples <caption>Schedule recursively first, then do something</caption>
   *
   * Rx.Scheduler.queue.schedule(() => {
   *   Rx.Scheduler.queue.schedule(() => console.log('second')); // will not happen now, but will be put on a queue
   *
   *   console.log('first');
   * });
   *
   * // Logs:
   * // "first"
   * // "second"
   *
   *
   * @example <caption>Reschedule itself recursively</caption>
   *
   * Rx.Scheduler.queue.schedule(function(state) {
   *   if (state !== 0) {
   *     console.log('before', state);
   *     this.schedule(state - 1); // `this` references currently executing Action,
   *                               // which we reschedule with new state
   *     console.log('after', state);
   *   }
   * }, 0, 3);
   *
   * // In scheduler that runs recursively, you would expect:
   * // "before", 3
   * // "before", 2
   * // "before", 1
   * // "after", 1
   * // "after", 2
   * // "after", 3
   *
   * // But with queue it logs:
   * // "before", 3
   * // "after", 3
   * // "before", 2
   * // "after", 2
   * // "before", 1
   * // "after", 1
   *
   *
   * @static true
   * @name queue
   * @owner Scheduler
   */

  var queue$1 =
  /*@__PURE__*/
  new QueueScheduler(QueueAction);

  /** PURE_IMPORTS_START tslib,._Subject,._scheduler_queue,._Subscription,._operators_observeOn,._util_ObjectUnsubscribedError,._SubjectSubscription PURE_IMPORTS_END */
  /**
   * @class ReplaySubject<T>
   */

  var ReplaySubject =
  /*@__PURE__*/
  function (_super) {
    __extends(ReplaySubject, _super);

    function ReplaySubject(bufferSize, windowTime, scheduler) {
      if (bufferSize === void 0) {
        bufferSize = Number.POSITIVE_INFINITY;
      }

      if (windowTime === void 0) {
        windowTime = Number.POSITIVE_INFINITY;
      }

      var _this = _super.call(this) || this;

      _this.scheduler = scheduler;
      _this._events = [];
      _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
      _this._windowTime = windowTime < 1 ? 1 : windowTime;
      return _this;
    }

    ReplaySubject.prototype.next = function (value) {
      var now = this._getNow();

      this._events.push(new ReplayEvent(now, value));

      this._trimBufferThenGetEvents();

      _super.prototype.next.call(this, value);
    };

    ReplaySubject.prototype._subscribe = function (subscriber) {
      var _events = this._trimBufferThenGetEvents();

      var scheduler = this.scheduler;
      var subscription;

      if (this.closed) {
        throw new ObjectUnsubscribedError();
      } else if (this.hasError) {
        subscription = Subscription.EMPTY;
      } else if (this.isStopped) {
        subscription = Subscription.EMPTY;
      } else {
        this.observers.push(subscriber);
        subscription = new SubjectSubscription(this, subscriber);
      }

      if (scheduler) {
        subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler));
      }

      var len = _events.length;

      for (var i = 0; i < len && !subscriber.closed; i++) {
        subscriber.next(_events[i].value);
      }

      if (this.hasError) {
        subscriber.error(this.thrownError);
      } else if (this.isStopped) {
        subscriber.complete();
      }

      return subscription;
    };

    ReplaySubject.prototype._getNow = function () {
      return (this.scheduler || queue$1).now();
    };

    ReplaySubject.prototype._trimBufferThenGetEvents = function () {
      var now = this._getNow();

      var _bufferSize = this._bufferSize;
      var _windowTime = this._windowTime;
      var _events = this._events;
      var eventsCount = _events.length;
      var spliceCount = 0; // Trim events that fall out of the time window.
      // Start at the front of the list. Break early once
      // we encounter an event that falls within the window.

      while (spliceCount < eventsCount) {
        if (now - _events[spliceCount].time < _windowTime) {
          break;
        }

        spliceCount++;
      }

      if (eventsCount > _bufferSize) {
        spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
      }

      if (spliceCount > 0) {
        _events.splice(0, spliceCount);
      }

      return _events;
    };

    return ReplaySubject;
  }(Subject);

  var ReplayEvent =
  /*@__PURE__*/

  /*@__PURE__*/
  function () {
    function ReplayEvent(time, value) {
      this.time = time;
      this.value = value;
    }

    return ReplayEvent;
  }();

  /** PURE_IMPORTS_START .._ReplaySubject,._multicast PURE_IMPORTS_END */

  /** PURE_IMPORTS_START tslib,.._Subscriber,.._observable_empty PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var RepeatSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(RepeatSubscriber, _super);

    function RepeatSubscriber(destination, count, source) {
      var _this = _super.call(this, destination) || this;

      _this.count = count;
      _this.source = source;
      return _this;
    }

    RepeatSubscriber.prototype.complete = function () {
      if (!this.isStopped) {
        var _a = this,
            source = _a.source,
            count = _a.count;

        if (count === 0) {
          return _super.prototype.complete.call(this);
        } else if (count > -1) {
          this.count = count - 1;
        }

        source.subscribe(this._unsubscribeAndRecycle());
      }
    };

    return RepeatSubscriber;
  }(Subscriber);

  /** PURE_IMPORTS_START tslib,.._Subject,.._util_tryCatch,.._util_errorObject,.._OuterSubscriber,.._util_subscribeToResult PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var RepeatWhenSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(RepeatWhenSubscriber, _super);

    function RepeatWhenSubscriber(destination, notifier, source) {
      var _this = _super.call(this, destination) || this;

      _this.notifier = notifier;
      _this.source = source;
      _this.sourceIsBeingSubscribedTo = true;
      return _this;
    }

    RepeatWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
      this.sourceIsBeingSubscribedTo = true;
      this.source.subscribe(this);
    };

    RepeatWhenSubscriber.prototype.notifyComplete = function (innerSub) {
      if (this.sourceIsBeingSubscribedTo === false) {
        return _super.prototype.complete.call(this);
      }
    };

    RepeatWhenSubscriber.prototype.complete = function () {
      this.sourceIsBeingSubscribedTo = false;

      if (!this.isStopped) {
        if (!this.retries) {
          this.subscribeToRetries();
        } else if (this.retriesSubscription.closed) {
          return _super.prototype.complete.call(this);
        }

        this._unsubscribeAndRecycle();

        this.notifications.next();
      }
    };

    RepeatWhenSubscriber.prototype._unsubscribe = function () {
      var _a = this,
          notifications = _a.notifications,
          retriesSubscription = _a.retriesSubscription;

      if (notifications) {
        notifications.unsubscribe();
        this.notifications = null;
      }

      if (retriesSubscription) {
        retriesSubscription.unsubscribe();
        this.retriesSubscription = null;
      }

      this.retries = null;
    };

    RepeatWhenSubscriber.prototype._unsubscribeAndRecycle = function () {
      var _a = this,
          notifications = _a.notifications,
          retries = _a.retries,
          retriesSubscription = _a.retriesSubscription;

      this.notifications = null;
      this.retries = null;
      this.retriesSubscription = null;

      _super.prototype._unsubscribeAndRecycle.call(this);

      this.notifications = notifications;
      this.retries = retries;
      this.retriesSubscription = retriesSubscription;
      return this;
    };

    RepeatWhenSubscriber.prototype.subscribeToRetries = function () {
      this.notifications = new Subject();
      var retries = tryCatch(this.notifier)(this.notifications);

      if (retries === errorObject) {
        return _super.prototype.complete.call(this);
      }

      this.retries = retries;
      this.retriesSubscription = subscribeToResult(this, retries);
    };

    return RepeatWhenSubscriber;
  }(OuterSubscriber);

  /** PURE_IMPORTS_START tslib,.._Subscriber PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var RetrySubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(RetrySubscriber, _super);

    function RetrySubscriber(destination, count, source) {
      var _this = _super.call(this, destination) || this;

      _this.count = count;
      _this.source = source;
      return _this;
    }

    RetrySubscriber.prototype.error = function (err) {
      if (!this.isStopped) {
        var _a = this,
            source = _a.source,
            count = _a.count;

        if (count === 0) {
          return _super.prototype.error.call(this, err);
        } else if (count > -1) {
          this.count = count - 1;
        }

        source.subscribe(this._unsubscribeAndRecycle());
      }
    };

    return RetrySubscriber;
  }(Subscriber);

  /** PURE_IMPORTS_START tslib,.._Subject,.._util_tryCatch,.._util_errorObject,.._OuterSubscriber,.._util_subscribeToResult PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var RetryWhenSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(RetryWhenSubscriber, _super);

    function RetryWhenSubscriber(destination, notifier, source) {
      var _this = _super.call(this, destination) || this;

      _this.notifier = notifier;
      _this.source = source;
      return _this;
    }

    RetryWhenSubscriber.prototype.error = function (err) {
      if (!this.isStopped) {
        var errors = this.errors;
        var retries = this.retries;
        var retriesSubscription = this.retriesSubscription;

        if (!retries) {
          errors = new Subject();
          retries = tryCatch(this.notifier)(errors);

          if (retries === errorObject) {
            return _super.prototype.error.call(this, errorObject.e);
          }

          retriesSubscription = subscribeToResult(this, retries);
        } else {
          this.errors = null;
          this.retriesSubscription = null;
        }

        this._unsubscribeAndRecycle();

        this.errors = errors;
        this.retries = retries;
        this.retriesSubscription = retriesSubscription;
        errors.next(err);
      }
    };

    RetryWhenSubscriber.prototype._unsubscribe = function () {
      var _a = this,
          errors = _a.errors,
          retriesSubscription = _a.retriesSubscription;

      if (errors) {
        errors.unsubscribe();
        this.errors = null;
      }

      if (retriesSubscription) {
        retriesSubscription.unsubscribe();
        this.retriesSubscription = null;
      }

      this.retries = null;
    };

    RetryWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
      var _a = this,
          errors = _a.errors,
          retries = _a.retries,
          retriesSubscription = _a.retriesSubscription;

      this.errors = null;
      this.retries = null;
      this.retriesSubscription = null;

      this._unsubscribeAndRecycle();

      this.errors = errors;
      this.retries = retries;
      this.retriesSubscription = retriesSubscription;
      this.source.subscribe(this);
    };

    return RetryWhenSubscriber;
  }(OuterSubscriber);

  /** PURE_IMPORTS_START tslib,.._OuterSubscriber,.._util_subscribeToResult PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var SampleSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(SampleSubscriber, _super);

    function SampleSubscriber() {
      var _this = _super !== null && _super.apply(this, arguments) || this;

      _this.hasValue = false;
      return _this;
    }

    SampleSubscriber.prototype._next = function (value) {
      this.value = value;
      this.hasValue = true;
    };

    SampleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
      this.emitValue();
    };

    SampleSubscriber.prototype.notifyComplete = function () {
      this.emitValue();
    };

    SampleSubscriber.prototype.emitValue = function () {
      if (this.hasValue) {
        this.hasValue = false;
        this.destination.next(this.value);
      }
    };

    return SampleSubscriber;
  }(OuterSubscriber);

  /** PURE_IMPORTS_START tslib,.._Subscriber,.._scheduler_async PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var SampleTimeSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(SampleTimeSubscriber, _super);

    function SampleTimeSubscriber(destination, period, scheduler) {
      var _this = _super.call(this, destination) || this;

      _this.period = period;
      _this.scheduler = scheduler;
      _this.hasValue = false;

      _this.add(scheduler.schedule(dispatchNotification, period, {
        subscriber: _this,
        period: period
      }));

      return _this;
    }

    SampleTimeSubscriber.prototype._next = function (value) {
      this.lastValue = value;
      this.hasValue = true;
    };

    SampleTimeSubscriber.prototype.notifyNext = function () {
      if (this.hasValue) {
        this.hasValue = false;
        this.destination.next(this.lastValue);
      }
    };

    return SampleTimeSubscriber;
  }(Subscriber);

  function dispatchNotification(state) {
    var subscriber = state.subscriber,
        period = state.period;
    subscriber.notifyNext();
    this.schedule(state, period);
  }

  /** PURE_IMPORTS_START tslib,.._Subscriber,.._util_tryCatch,.._util_errorObject PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */

  var SequenceEqualSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(SequenceEqualSubscriber, _super);

    function SequenceEqualSubscriber(destination, compareTo, comparor) {
      var _this = _super.call(this, destination) || this;

      _this.compareTo = compareTo;
      _this.comparor = comparor;
      _this._a = [];
      _this._b = [];
      _this._oneComplete = false;

      _this.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, _this)));

      return _this;
    }

    SequenceEqualSubscriber.prototype._next = function (value) {
      if (this._oneComplete && this._b.length === 0) {
        this.emit(false);
      } else {
        this._a.push(value);

        this.checkValues();
      }
    };

    SequenceEqualSubscriber.prototype._complete = function () {
      if (this._oneComplete) {
        this.emit(this._a.length === 0 && this._b.length === 0);
      } else {
        this._oneComplete = true;
      }
    };

    SequenceEqualSubscriber.prototype.checkValues = function () {
      var _c = this,
          _a = _c._a,
          _b = _c._b,
          comparor = _c.comparor;

      while (_a.length > 0 && _b.length > 0) {
        var a = _a.shift();

        var b = _b.shift();

        var areEqual = false;

        if (comparor) {
          areEqual = tryCatch(comparor)(a, b);

          if (areEqual === errorObject) {
            this.destination.error(errorObject.e);
          }
        } else {
          areEqual = a === b;
        }

        if (!areEqual) {
          this.emit(false);
        }
      }
    };

    SequenceEqualSubscriber.prototype.emit = function (value) {
      var destination = this.destination;
      destination.next(value);
      destination.complete();
    };

    SequenceEqualSubscriber.prototype.nextB = function (value) {
      if (this._oneComplete && this._a.length === 0) {
        this.emit(false);
      } else {
        this._b.push(value);

        this.checkValues();
      }
    };

    return SequenceEqualSubscriber;
  }(Subscriber);

  var SequenceEqualCompareToSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(SequenceEqualCompareToSubscriber, _super);

    function SequenceEqualCompareToSubscriber(destination, parent) {
      var _this = _super.call(this, destination) || this;

      _this.parent = parent;
      return _this;
    }

    SequenceEqualCompareToSubscriber.prototype._next = function (value) {
      this.parent.nextB(value);
    };

    SequenceEqualCompareToSubscriber.prototype._error = function (err) {
      this.parent.error(err);
    };

    SequenceEqualCompareToSubscriber.prototype._complete = function () {
      this.parent._complete();
    };

    return SequenceEqualCompareToSubscriber;
  }(Subscriber);

  /** PURE_IMPORTS_START ._multicast,._refCount,.._Subject PURE_IMPORTS_END */

  /** PURE_IMPORTS_START .._ReplaySubject PURE_IMPORTS_END */

  /** PURE_IMPORTS_START tslib,.._Subscriber,.._util_EmptyError PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var SingleSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(SingleSubscriber, _super);

    function SingleSubscriber(destination, predicate, source) {
      var _this = _super.call(this, destination) || this;

      _this.predicate = predicate;
      _this.source = source;
      _this.seenValue = false;
      _this.index = 0;
      return _this;
    }

    SingleSubscriber.prototype.applySingleValue = function (value) {
      if (this.seenValue) {
        this.destination.error('Sequence contains more than one element');
      } else {
        this.seenValue = true;
        this.singleValue = value;
      }
    };

    SingleSubscriber.prototype._next = function (value) {
      var index = this.index++;

      if (this.predicate) {
        this.tryNext(value, index);
      } else {
        this.applySingleValue(value);
      }
    };

    SingleSubscriber.prototype.tryNext = function (value, index) {
      try {
        if (this.predicate(value, index, this.source)) {
          this.applySingleValue(value);
        }
      } catch (err) {
        this.destination.error(err);
      }
    };

    SingleSubscriber.prototype._complete = function () {
      var destination = this.destination;

      if (this.index > 0) {
        destination.next(this.seenValue ? this.singleValue : undefined);
        destination.complete();
      } else {
        destination.error(new EmptyError());
      }
    };

    return SingleSubscriber;
  }(Subscriber);

  /** PURE_IMPORTS_START tslib,.._Subscriber PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var SkipSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(SkipSubscriber, _super);

    function SkipSubscriber(destination, total) {
      var _this = _super.call(this, destination) || this;

      _this.total = total;
      _this.count = 0;
      return _this;
    }

    SkipSubscriber.prototype._next = function (x) {
      if (++this.count > this.total) {
        this.destination.next(x);
      }
    };

    return SkipSubscriber;
  }(Subscriber);

  /** PURE_IMPORTS_START tslib,.._Subscriber,.._util_ArgumentOutOfRangeError PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var SkipLastSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(SkipLastSubscriber, _super);

    function SkipLastSubscriber(destination, _skipCount) {
      var _this = _super.call(this, destination) || this;

      _this._skipCount = _skipCount;
      _this._count = 0;
      _this._ring = new Array(_skipCount);
      return _this;
    }

    SkipLastSubscriber.prototype._next = function (value) {
      var skipCount = this._skipCount;
      var count = this._count++;

      if (count < skipCount) {
        this._ring[count] = value;
      } else {
        var currentIndex = count % skipCount;
        var ring = this._ring;
        var oldValue = ring[currentIndex];
        ring[currentIndex] = value;
        this.destination.next(oldValue);
      }
    };

    return SkipLastSubscriber;
  }(Subscriber);

  /** PURE_IMPORTS_START tslib,.._OuterSubscriber,.._util_subscribeToResult PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var SkipUntilSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(SkipUntilSubscriber, _super);

    function SkipUntilSubscriber(destination, notifier) {
      var _this = _super.call(this, destination) || this;

      _this.hasValue = false;
      _this.isInnerStopped = false;

      _this.add(subscribeToResult(_this, notifier));

      return _this;
    }

    SkipUntilSubscriber.prototype._next = function (value) {
      if (this.hasValue) {
        _super.prototype._next.call(this, value);
      }
    };

    SkipUntilSubscriber.prototype._complete = function () {
      if (this.isInnerStopped) {
        _super.prototype._complete.call(this);
      } else {
        this.unsubscribe();
      }
    };

    SkipUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
      this.hasValue = true;
    };

    SkipUntilSubscriber.prototype.notifyComplete = function () {
      this.isInnerStopped = true;

      if (this.isStopped) {
        _super.prototype._complete.call(this);
      }
    };

    return SkipUntilSubscriber;
  }(OuterSubscriber);

  /** PURE_IMPORTS_START tslib,.._Subscriber PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var SkipWhileSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(SkipWhileSubscriber, _super);

    function SkipWhileSubscriber(destination, predicate) {
      var _this = _super.call(this, destination) || this;

      _this.predicate = predicate;
      _this.skipping = true;
      _this.index = 0;
      return _this;
    }

    SkipWhileSubscriber.prototype._next = function (value) {
      var destination = this.destination;

      if (this.skipping) {
        this.tryCallPredicate(value);
      }

      if (!this.skipping) {
        destination.next(value);
      }
    };

    SkipWhileSubscriber.prototype.tryCallPredicate = function (value) {
      try {
        var result = this.predicate(value, this.index++);
        this.skipping = Boolean(result);
      } catch (err) {
        this.destination.error(err);
      }
    };

    return SkipWhileSubscriber;
  }(Subscriber);

  /** PURE_IMPORTS_START .._symbol_observable PURE_IMPORTS_END */

  /** PURE_IMPORTS_START .._symbol_iterator PURE_IMPORTS_END */

  /** PURE_IMPORTS_START .._Observable,.._Subscription,.._util_subscribeToPromise PURE_IMPORTS_END */

  /** PURE_IMPORTS_START .._Observable,.._Subscription,.._symbol_iterator,.._util_subscribeToIterable PURE_IMPORTS_END */

  /** PURE_IMPORTS_START .._Observable,.._Subscription,.._symbol_observable,.._util_subscribeToObservable PURE_IMPORTS_END */

  /** PURE_IMPORTS_START .._Observable,.._util_isPromise,.._util_isArrayLike,.._util_isObservable,.._util_isIterable,._fromArray,._fromPromise,._fromIterable,._fromObservable,.._util_subscribeTo PURE_IMPORTS_END */

  /** PURE_IMPORTS_START .._util_isScheduler,._of,._from,.._.._internal_operators_concatAll PURE_IMPORTS_END */

  /** PURE_IMPORTS_START .._observable_fromArray,.._observable_scalar,.._observable_empty,.._observable_concat,.._util_isScheduler PURE_IMPORTS_END */

  /** PURE_IMPORTS_START tslib,.._OuterSubscriber,.._util_subscribeToResult PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var SwitchMapSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(SwitchMapSubscriber, _super);

    function SwitchMapSubscriber(destination, project) {
      var _this = _super.call(this, destination) || this;

      _this.project = project;
      _this.index = 0;
      return _this;
    }

    SwitchMapSubscriber.prototype._next = function (value) {
      var result;
      var index = this.index++;

      try {
        result = this.project(value, index);
      } catch (error) {
        this.destination.error(error);
        return;
      }

      this._innerSub(result, value, index);
    };

    SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {
      var innerSubscription = this.innerSubscription;

      if (innerSubscription) {
        innerSubscription.unsubscribe();
      }

      this.add(this.innerSubscription = subscribeToResult(this, result, value, index));
    };

    SwitchMapSubscriber.prototype._complete = function () {
      var innerSubscription = this.innerSubscription;

      if (!innerSubscription || innerSubscription.closed) {
        _super.prototype._complete.call(this);
      }
    };

    SwitchMapSubscriber.prototype._unsubscribe = function () {
      this.innerSubscription = null;
    };

    SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {
      this.remove(innerSub);
      this.innerSubscription = null;

      if (this.isStopped) {
        _super.prototype._complete.call(this);
      }
    };

    SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
      this.destination.next(innerValue);
    };

    return SwitchMapSubscriber;
  }(OuterSubscriber);

  /** PURE_IMPORTS_START ._switchMap,.._util_identity PURE_IMPORTS_END */

  /** PURE_IMPORTS_START tslib,.._OuterSubscriber,.._util_subscribeToResult PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var SwitchMapToSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(SwitchMapToSubscriber, _super);

    function SwitchMapToSubscriber(destination, inner) {
      var _this = _super.call(this, destination) || this;

      _this.inner = inner;
      _this.index = 0;
      return _this;
    }

    SwitchMapToSubscriber.prototype._next = function (value) {
      var innerSubscription = this.innerSubscription;

      if (innerSubscription) {
        innerSubscription.unsubscribe();
      }

      this.add(this.innerSubscription = subscribeToResult(this, this.inner, value, this.index++));
    };

    SwitchMapToSubscriber.prototype._complete = function () {
      var innerSubscription = this.innerSubscription;

      if (!innerSubscription || innerSubscription.closed) {
        _super.prototype._complete.call(this);
      }
    };

    SwitchMapToSubscriber.prototype._unsubscribe = function () {
      this.innerSubscription = null;
    };

    SwitchMapToSubscriber.prototype.notifyComplete = function (innerSub) {
      this.remove(innerSub);
      this.innerSubscription = null;

      if (this.isStopped) {
        _super.prototype._complete.call(this);
      }
    };

    SwitchMapToSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
      this.destination.next(innerValue);
    };

    return SwitchMapToSubscriber;
  }(OuterSubscriber);

  /** PURE_IMPORTS_START tslib,.._Subscriber,.._util_ArgumentOutOfRangeError,.._observable_empty PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var TakeSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(TakeSubscriber, _super);

    function TakeSubscriber(destination, total) {
      var _this = _super.call(this, destination) || this;

      _this.total = total;
      _this.count = 0;
      return _this;
    }

    TakeSubscriber.prototype._next = function (value) {
      var total = this.total;
      var count = ++this.count;

      if (count <= total) {
        this.destination.next(value);

        if (count === total) {
          this.destination.complete();
          this.unsubscribe();
        }
      }
    };

    return TakeSubscriber;
  }(Subscriber);

  /** PURE_IMPORTS_START tslib,.._OuterSubscriber,.._util_subscribeToResult PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var TakeUntilSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(TakeUntilSubscriber, _super);

    function TakeUntilSubscriber(destination, notifier) {
      var _this = _super.call(this, destination) || this;

      _this.notifier = notifier;

      _this.add(subscribeToResult(_this, notifier));

      return _this;
    }

    TakeUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
      this.complete();
    };

    TakeUntilSubscriber.prototype.notifyComplete = function () {// noop
    };

    return TakeUntilSubscriber;
  }(OuterSubscriber);

  /** PURE_IMPORTS_START tslib,.._Subscriber PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var TakeWhileSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(TakeWhileSubscriber, _super);

    function TakeWhileSubscriber(destination, predicate) {
      var _this = _super.call(this, destination) || this;

      _this.predicate = predicate;
      _this.index = 0;
      return _this;
    }

    TakeWhileSubscriber.prototype._next = function (value) {
      var destination = this.destination;
      var result;

      try {
        result = this.predicate(value, this.index++);
      } catch (err) {
        destination.error(err);
        return;
      }

      this.nextOrComplete(value, result);
    };

    TakeWhileSubscriber.prototype.nextOrComplete = function (value, predicateResult) {
      var destination = this.destination;

      if (Boolean(predicateResult)) {
        destination.next(value);
      } else {
        destination.complete();
      }
    };

    return TakeWhileSubscriber;
  }(Subscriber);

  /** PURE_IMPORTS_START tslib,.._Subscriber,.._util_noop,.._util_isFunction PURE_IMPORTS_END */
  /* tslint:enable:max-line-length */

  /**
   * Perform a side effect for every emission on the source Observable, but return
   * an Observable that is identical to the source.
   *
   * <span class="informal">Intercepts each emission on the source and runs a
   * function, but returns an output which is identical to the source as long as errors don't occur.</span>
   *
   * <img src="./img/do.png" width="100%">
   *
   * Returns a mirrored Observable of the source Observable, but modified so that
   * the provided Observer is called to perform a side effect for every value,
   * error, and completion emitted by the source. Any errors that are thrown in
   * the aforementioned Observer or handlers are safely sent down the error path
   * of the output Observable.
   *
   * This operator is useful for debugging your Observables for the correct values
   * or performing other side effects.
   *
   * Note: this is different to a `subscribe` on the Observable. If the Observable
   * returned by `do` is not subscribed, the side effects specified by the
   * Observer will never happen. `do` therefore simply spies on existing
   * execution, it does not trigger an execution to happen like `subscribe` does.
   *
   * @example <caption>Map every click to the clientX position of that click, while also logging the click event</caption>
   * var clicks = Rx.Observable.fromEvent(document, 'click');
   * var positions = clicks
   *   .do(ev => console.log(ev))
   *   .map(ev => ev.clientX);
   * positions.subscribe(x => console.log(x));
   *
   * @see {@link map}
   * @see {@link subscribe}
   *
   * @param {Observer|function} [nextOrObserver] A normal Observer object or a
   * callback for `next`.
   * @param {function} [error] Callback for errors in the source.
   * @param {function} [complete] Callback for the completion of the source.
   * @return {Observable} An Observable identical to the source, but runs the
   * specified Observer or callback(s) for each item.
   * @name tap
   */

  function tap(nextOrObserver, error, complete) {
    return function tapOperatorFunction(source) {
      return source.lift(new DoOperator(nextOrObserver, error, complete));
    };
  }

  var DoOperator =
  /*@__PURE__*/

  /*@__PURE__*/
  function () {
    function DoOperator(nextOrObserver, error, complete) {
      this.nextOrObserver = nextOrObserver;
      this.error = error;
      this.complete = complete;
    }

    DoOperator.prototype.call = function (subscriber, source) {
      return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
    };

    return DoOperator;
  }();
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var TapSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(TapSubscriber, _super);

    function TapSubscriber(destination, observerOrNext, error, complete) {
      var _this = _super.call(this, destination) || this;

      _this._tapNext = noop;
      _this._tapError = noop;
      _this._tapComplete = noop;
      _this._tapError = error || noop;
      _this._tapComplete = complete || noop;

      if (isFunction(observerOrNext)) {
        _this._context = _this;
        _this._tapNext = observerOrNext;
      } else if (observerOrNext) {
        _this._context = observerOrNext;
        _this._tapNext = observerOrNext.next || noop;
        _this._tapError = observerOrNext.error || noop;
        _this._tapComplete = observerOrNext.complete || noop;
      }

      return _this;
    }

    TapSubscriber.prototype._next = function (value) {
      try {
        this._tapNext.call(this._context, value);
      } catch (err) {
        this.destination.error(err);
        return;
      }

      this.destination.next(value);
    };

    TapSubscriber.prototype._error = function (err) {
      try {
        this._tapError.call(this._context, err);
      } catch (err) {
        this.destination.error(err);
        return;
      }

      this.destination.error(err);
    };

    TapSubscriber.prototype._complete = function () {
      try {
        this._tapComplete.call(this._context);
      } catch (err) {
        this.destination.error(err);
        return;
      }

      return this.destination.complete();
    };

    return TapSubscriber;
  }(Subscriber);

  /** PURE_IMPORTS_START tslib,.._OuterSubscriber,.._util_subscribeToResult PURE_IMPORTS_END */
  var defaultThrottleConfig = {
    leading: true,
    trailing: false
  };
  /**
   * We need this JSDoc comment for affecting ESDoc
   * @ignore
   * @extends {Ignored}
   */


  var ThrottleSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(ThrottleSubscriber, _super);

    function ThrottleSubscriber(destination, durationSelector, _leading, _trailing) {
      var _this = _super.call(this, destination) || this;

      _this.destination = destination;
      _this.durationSelector = durationSelector;
      _this._leading = _leading;
      _this._trailing = _trailing;
      _this._hasTrailingValue = false;
      return _this;
    }

    ThrottleSubscriber.prototype._next = function (value) {
      if (this.throttled) {
        if (this._trailing) {
          this._hasTrailingValue = true;
          this._trailingValue = value;
        }
      } else {
        var duration = this.tryDurationSelector(value);

        if (duration) {
          this.add(this.throttled = subscribeToResult(this, duration));
        }

        if (this._leading) {
          this.destination.next(value);

          if (this._trailing) {
            this._hasTrailingValue = true;
            this._trailingValue = value;
          }
        }
      }
    };

    ThrottleSubscriber.prototype.tryDurationSelector = function (value) {
      try {
        return this.durationSelector(value);
      } catch (err) {
        this.destination.error(err);
        return null;
      }
    };

    ThrottleSubscriber.prototype._unsubscribe = function () {
      var _a = this,
          throttled = _a.throttled,
          _trailingValue = _a._trailingValue,
          _hasTrailingValue = _a._hasTrailingValue,
          _trailing = _a._trailing;

      this._trailingValue = null;
      this._hasTrailingValue = false;

      if (throttled) {
        this.remove(throttled);
        this.throttled = null;
        throttled.unsubscribe();
      }
    };

    ThrottleSubscriber.prototype._sendTrailing = function () {
      var _a = this,
          destination = _a.destination,
          throttled = _a.throttled,
          _trailing = _a._trailing,
          _trailingValue = _a._trailingValue,
          _hasTrailingValue = _a._hasTrailingValue;

      if (throttled && _trailing && _hasTrailingValue) {
        destination.next(_trailingValue);
        this._trailingValue = null;
        this._hasTrailingValue = false;
      }
    };

    ThrottleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
      this._sendTrailing();

      this._unsubscribe();
    };

    ThrottleSubscriber.prototype.notifyComplete = function () {
      this._sendTrailing();

      this._unsubscribe();
    };

    return ThrottleSubscriber;
  }(OuterSubscriber);

  /** PURE_IMPORTS_START tslib,.._Subscriber,.._scheduler_async,._throttle PURE_IMPORTS_END */
  /**
   * Emits a value from the source Observable, then ignores subsequent source
   * values for `duration` milliseconds, then repeats this process.
   *
   * <span class="informal">Lets a value pass, then ignores source values for the
   * next `duration` milliseconds.</span>
   *
   * <img src="./img/throttleTime.png" width="100%">
   *
   * `throttleTime` emits the source Observable values on the output Observable
   * when its internal timer is disabled, and ignores source values when the timer
   * is enabled. Initially, the timer is disabled. As soon as the first source
   * value arrives, it is forwarded to the output Observable, and then the timer
   * is enabled. After `duration` milliseconds (or the time unit determined
   * internally by the optional `scheduler`) has passed, the timer is disabled,
   * and this process repeats for the next source value. Optionally takes a
   * {@link IScheduler} for managing timers.
   *
   * @example <caption>Emit clicks at a rate of at most one click per second</caption>
   * var clicks = Rx.Observable.fromEvent(document, 'click');
   * var result = clicks.throttleTime(1000);
   * result.subscribe(x => console.log(x));
   *
   * @see {@link auditTime}
   * @see {@link debounceTime}
   * @see {@link delay}
   * @see {@link sampleTime}
   * @see {@link throttle}
   *
   * @param {number} duration Time to wait before emitting another value after
   * emitting the last value, measured in milliseconds or the time unit determined
   * internally by the optional `scheduler`.
   * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
   * managing the timers that handle the throttling.
   * @return {Observable<T>} An Observable that performs the throttle operation to
   * limit the rate of emissions from the source.
   * @method throttleTime
   * @owner Observable
   */

  function throttleTime(duration, scheduler, config) {
    if (scheduler === void 0) {
      scheduler = async;
    }

    if (config === void 0) {
      config = defaultThrottleConfig;
    }

    return function (source) {
      return source.lift(new ThrottleTimeOperator(duration, scheduler, config.leading, config.trailing));
    };
  }

  var ThrottleTimeOperator =
  /*@__PURE__*/

  /*@__PURE__*/
  function () {
    function ThrottleTimeOperator(duration, scheduler, leading, trailing) {
      this.duration = duration;
      this.scheduler = scheduler;
      this.leading = leading;
      this.trailing = trailing;
    }

    ThrottleTimeOperator.prototype.call = function (subscriber, source) {
      return source.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing));
    };

    return ThrottleTimeOperator;
  }();
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var ThrottleTimeSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(ThrottleTimeSubscriber, _super);

    function ThrottleTimeSubscriber(destination, duration, scheduler, leading, trailing) {
      var _this = _super.call(this, destination) || this;

      _this.duration = duration;
      _this.scheduler = scheduler;
      _this.leading = leading;
      _this.trailing = trailing;
      _this._hasTrailingValue = false;
      _this._trailingValue = null;
      return _this;
    }

    ThrottleTimeSubscriber.prototype._next = function (value) {
      if (this.throttled) {
        if (this.trailing) {
          this._trailingValue = value;
          this._hasTrailingValue = true;
        }
      } else {
        this.add(this.throttled = this.scheduler.schedule(dispatchNext$1, this.duration, {
          subscriber: this
        }));

        if (this.leading) {
          this.destination.next(value);
        }
      }
    };

    ThrottleTimeSubscriber.prototype.clearThrottle = function () {
      var throttled = this.throttled;

      if (throttled) {
        if (this.trailing && this._hasTrailingValue) {
          this.destination.next(this._trailingValue);
          this._trailingValue = null;
          this._hasTrailingValue = false;
        }

        throttled.unsubscribe();
        this.remove(throttled);
        this.throttled = null;
      }
    };

    return ThrottleTimeSubscriber;
  }(Subscriber);

  function dispatchNext$1(arg) {
    var subscriber = arg.subscriber;
    subscriber.clearThrottle();
  }

  /** PURE_IMPORTS_START ._tap,.._util_EmptyError PURE_IMPORTS_END */

  /** PURE_IMPORTS_START tslib,.._Subscriber,.._scheduler_async PURE_IMPORTS_END */

  var TimeInterval =
  /*@__PURE__*/

  /*@__PURE__*/
  function () {
    function TimeInterval(value, interval) {
      this.value = value;
      this.interval = interval;
    }

    return TimeInterval;
  }();
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var TimeIntervalSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(TimeIntervalSubscriber, _super);

    function TimeIntervalSubscriber(destination, scheduler) {
      var _this = _super.call(this, destination) || this;

      _this.scheduler = scheduler;
      _this.lastTime = 0;
      _this.lastTime = scheduler.now();
      return _this;
    }

    TimeIntervalSubscriber.prototype._next = function (value) {
      var now = this.scheduler.now();
      var span = now - this.lastTime;
      this.lastTime = now;
      this.destination.next(new TimeInterval(value, span));
    };

    return TimeIntervalSubscriber;
  }(Subscriber);

  /** PURE_IMPORTS_START tslib PURE_IMPORTS_END */
  /**
   * An error thrown when duetime elapses.
   *
   * @see {@link timeout}
   *
   * @class TimeoutError
   */

  var TimeoutError =
  /*@__PURE__*/
  function (_super) {
    __extends(TimeoutError, _super);

    function TimeoutError() {
      var _this = _super.call(this, 'Timeout has occurred') || this;

      Object.setPrototypeOf(_this, TimeoutError.prototype);
      return _this;
    }

    return TimeoutError;
  }(Error);

  /** PURE_IMPORTS_START tslib,.._scheduler_async,.._util_isDate,.._Subscriber,.._util_TimeoutError PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var TimeoutSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(TimeoutSubscriber, _super);

    function TimeoutSubscriber(destination, absoluteTimeout, waitFor, scheduler, errorInstance) {
      var _this = _super.call(this, destination) || this;

      _this.absoluteTimeout = absoluteTimeout;
      _this.waitFor = waitFor;
      _this.scheduler = scheduler;
      _this.errorInstance = errorInstance;
      _this.action = null;

      _this.scheduleTimeout();

      return _this;
    }

    TimeoutSubscriber.dispatchTimeout = function (subscriber) {
      subscriber.error(subscriber.errorInstance);
    };

    TimeoutSubscriber.prototype.scheduleTimeout = function () {
      var action = this.action;

      if (action) {
        // Recycle the action if we've already scheduled one. All the production
        // Scheduler Actions mutate their state/delay time and return themeselves.
        // VirtualActions are immutable, so they create and return a clone. In this
        // case, we need to set the action reference to the most recent VirtualAction,
        // to ensure that's the one we clone from next time.
        this.action = action.schedule(this, this.waitFor);
      } else {
        this.add(this.action = this.scheduler.schedule(TimeoutSubscriber.dispatchTimeout, this.waitFor, this));
      }
    };

    TimeoutSubscriber.prototype._next = function (value) {
      if (!this.absoluteTimeout) {
        this.scheduleTimeout();
      }

      _super.prototype._next.call(this, value);
    };

    TimeoutSubscriber.prototype._unsubscribe = function () {
      this.action = null;
      this.scheduler = null;
      this.errorInstance = null;
    };

    return TimeoutSubscriber;
  }(Subscriber);

  /** PURE_IMPORTS_START tslib,.._scheduler_async,.._util_isDate,.._OuterSubscriber,.._util_subscribeToResult PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var TimeoutWithSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(TimeoutWithSubscriber, _super);

    function TimeoutWithSubscriber(destination, absoluteTimeout, waitFor, withObservable, scheduler) {
      var _this = _super.call(this, destination) || this;

      _this.absoluteTimeout = absoluteTimeout;
      _this.waitFor = waitFor;
      _this.withObservable = withObservable;
      _this.scheduler = scheduler;
      _this.action = null;

      _this.scheduleTimeout();

      return _this;
    }

    TimeoutWithSubscriber.dispatchTimeout = function (subscriber) {
      var withObservable = subscriber.withObservable;

      subscriber._unsubscribeAndRecycle();

      subscriber.add(subscribeToResult(subscriber, withObservable));
    };

    TimeoutWithSubscriber.prototype.scheduleTimeout = function () {
      var action = this.action;

      if (action) {
        // Recycle the action if we've already scheduled one. All the production
        // Scheduler Actions mutate their state/delay time and return themeselves.
        // VirtualActions are immutable, so they create and return a clone. In this
        // case, we need to set the action reference to the most recent VirtualAction,
        // to ensure that's the one we clone from next time.
        this.action = action.schedule(this, this.waitFor);
      } else {
        this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this));
      }
    };

    TimeoutWithSubscriber.prototype._next = function (value) {
      if (!this.absoluteTimeout) {
        this.scheduleTimeout();
      }

      _super.prototype._next.call(this, value);
    };

    TimeoutWithSubscriber.prototype._unsubscribe = function () {
      this.action = null;
      this.scheduler = null;
      this.withObservable = null;
    };

    return TimeoutWithSubscriber;
  }(OuterSubscriber);

  /** PURE_IMPORTS_START .._scheduler_async,._map PURE_IMPORTS_END */

  /** PURE_IMPORTS_START ._reduce PURE_IMPORTS_END */

  /** PURE_IMPORTS_START tslib,.._Subject,.._OuterSubscriber,.._util_subscribeToResult PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var WindowSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(WindowSubscriber, _super);

    function WindowSubscriber(destination) {
      var _this = _super.call(this, destination) || this;

      _this.window = new Subject();
      destination.next(_this.window);
      return _this;
    }

    WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
      this.openWindow();
    };

    WindowSubscriber.prototype.notifyError = function (error, innerSub) {
      this._error(error);
    };

    WindowSubscriber.prototype.notifyComplete = function (innerSub) {
      this._complete();
    };

    WindowSubscriber.prototype._next = function (value) {
      this.window.next(value);
    };

    WindowSubscriber.prototype._error = function (err) {
      this.window.error(err);
      this.destination.error(err);
    };

    WindowSubscriber.prototype._complete = function () {
      this.window.complete();
      this.destination.complete();
    };

    WindowSubscriber.prototype._unsubscribe = function () {
      this.window = null;
    };

    WindowSubscriber.prototype.openWindow = function () {
      var prevWindow = this.window;

      if (prevWindow) {
        prevWindow.complete();
      }

      var destination = this.destination;
      var newWindow = this.window = new Subject();
      destination.next(newWindow);
    };

    return WindowSubscriber;
  }(OuterSubscriber);

  /** PURE_IMPORTS_START tslib,.._Subscriber,.._Subject PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var WindowCountSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(WindowCountSubscriber, _super);

    function WindowCountSubscriber(destination, windowSize, startWindowEvery) {
      var _this = _super.call(this, destination) || this;

      _this.destination = destination;
      _this.windowSize = windowSize;
      _this.startWindowEvery = startWindowEvery;
      _this.windows = [new Subject()];
      _this.count = 0;
      destination.next(_this.windows[0]);
      return _this;
    }

    WindowCountSubscriber.prototype._next = function (value) {
      var startWindowEvery = this.startWindowEvery > 0 ? this.startWindowEvery : this.windowSize;
      var destination = this.destination;
      var windowSize = this.windowSize;
      var windows = this.windows;
      var len = windows.length;

      for (var i = 0; i < len && !this.closed; i++) {
        windows[i].next(value);
      }

      var c = this.count - windowSize + 1;

      if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {
        windows.shift().complete();
      }

      if (++this.count % startWindowEvery === 0 && !this.closed) {
        var window_1 = new Subject();
        windows.push(window_1);
        destination.next(window_1);
      }
    };

    WindowCountSubscriber.prototype._error = function (err) {
      var windows = this.windows;

      if (windows) {
        while (windows.length > 0 && !this.closed) {
          windows.shift().error(err);
        }
      }

      this.destination.error(err);
    };

    WindowCountSubscriber.prototype._complete = function () {
      var windows = this.windows;

      if (windows) {
        while (windows.length > 0 && !this.closed) {
          windows.shift().complete();
        }
      }

      this.destination.complete();
    };

    WindowCountSubscriber.prototype._unsubscribe = function () {
      this.count = 0;
      this.windows = null;
    };

    return WindowCountSubscriber;
  }(Subscriber);

  /** PURE_IMPORTS_START tslib,.._Subject,.._scheduler_async,.._Subscriber,.._util_isNumeric,.._util_isScheduler PURE_IMPORTS_END */

  var CountedSubject =
  /*@__PURE__*/
  function (_super) {
    __extends(CountedSubject, _super);

    function CountedSubject() {
      var _this = _super !== null && _super.apply(this, arguments) || this;

      _this._numberOfNextedValues = 0;
      return _this;
    }

    CountedSubject.prototype.next = function (value) {
      this._numberOfNextedValues++;

      _super.prototype.next.call(this, value);
    };

    Object.defineProperty(CountedSubject.prototype, "numberOfNextedValues", {
      get: function get() {
        return this._numberOfNextedValues;
      },
      enumerable: true,
      configurable: true
    });
    return CountedSubject;
  }(Subject);
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var WindowTimeSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(WindowTimeSubscriber, _super);

    function WindowTimeSubscriber(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
      var _this = _super.call(this, destination) || this;

      _this.destination = destination;
      _this.windowTimeSpan = windowTimeSpan;
      _this.windowCreationInterval = windowCreationInterval;
      _this.maxWindowSize = maxWindowSize;
      _this.scheduler = scheduler;
      _this.windows = [];

      var window = _this.openWindow();

      if (windowCreationInterval !== null && windowCreationInterval >= 0) {
        var closeState = {
          subscriber: _this,
          window: window,
          context: null
        };
        var creationState = {
          windowTimeSpan: windowTimeSpan,
          windowCreationInterval: windowCreationInterval,
          subscriber: _this,
          scheduler: scheduler
        };

        _this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));

        _this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));
      } else {
        var timeSpanOnlyState = {
          subscriber: _this,
          window: window,
          windowTimeSpan: windowTimeSpan
        };

        _this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));
      }

      return _this;
    }

    WindowTimeSubscriber.prototype._next = function (value) {
      var windows = this.windows;
      var len = windows.length;

      for (var i = 0; i < len; i++) {
        var window_1 = windows[i];

        if (!window_1.closed) {
          window_1.next(value);

          if (window_1.numberOfNextedValues >= this.maxWindowSize) {
            this.closeWindow(window_1);
          }
        }
      }
    };

    WindowTimeSubscriber.prototype._error = function (err) {
      var windows = this.windows;

      while (windows.length > 0) {
        windows.shift().error(err);
      }

      this.destination.error(err);
    };

    WindowTimeSubscriber.prototype._complete = function () {
      var windows = this.windows;

      while (windows.length > 0) {
        var window_2 = windows.shift();

        if (!window_2.closed) {
          window_2.complete();
        }
      }

      this.destination.complete();
    };

    WindowTimeSubscriber.prototype.openWindow = function () {
      var window = new CountedSubject();
      this.windows.push(window);
      var destination = this.destination;
      destination.next(window);
      return window;
    };

    WindowTimeSubscriber.prototype.closeWindow = function (window) {
      window.complete();
      var windows = this.windows;
      windows.splice(windows.indexOf(window), 1);
    };

    return WindowTimeSubscriber;
  }(Subscriber);

  function dispatchWindowTimeSpanOnly(state) {
    var subscriber = state.subscriber,
        windowTimeSpan = state.windowTimeSpan,
        window = state.window;

    if (window) {
      subscriber.closeWindow(window);
    }

    state.window = subscriber.openWindow();
    this.schedule(state, windowTimeSpan);
  }

  function dispatchWindowCreation(state) {
    var windowTimeSpan = state.windowTimeSpan,
        subscriber = state.subscriber,
        scheduler = state.scheduler,
        windowCreationInterval = state.windowCreationInterval;
    var window = subscriber.openWindow();
    var action = this;
    var context = {
      action: action,
      subscription: null
    };
    var timeSpanState = {
      subscriber: subscriber,
      window: window,
      context: context
    };
    context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);
    action.add(context.subscription);
    action.schedule(state, windowCreationInterval);
  }

  function dispatchWindowClose(state) {
    var subscriber = state.subscriber,
        window = state.window,
        context = state.context;

    if (context && context.action && context.subscription) {
      context.action.remove(context.subscription);
    }

    subscriber.closeWindow(window);
  }

  /** PURE_IMPORTS_START tslib,.._Subject,.._Subscription,.._util_tryCatch,.._util_errorObject,.._OuterSubscriber,.._util_subscribeToResult PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var WindowToggleSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(WindowToggleSubscriber, _super);

    function WindowToggleSubscriber(destination, openings, closingSelector) {
      var _this = _super.call(this, destination) || this;

      _this.openings = openings;
      _this.closingSelector = closingSelector;
      _this.contexts = [];

      _this.add(_this.openSubscription = subscribeToResult(_this, openings, openings));

      return _this;
    }

    WindowToggleSubscriber.prototype._next = function (value) {
      var contexts = this.contexts;

      if (contexts) {
        var len = contexts.length;

        for (var i = 0; i < len; i++) {
          contexts[i].window.next(value);
        }
      }
    };

    WindowToggleSubscriber.prototype._error = function (err) {
      var contexts = this.contexts;
      this.contexts = null;

      if (contexts) {
        var len = contexts.length;
        var index = -1;

        while (++index < len) {
          var context_1 = contexts[index];
          context_1.window.error(err);
          context_1.subscription.unsubscribe();
        }
      }

      _super.prototype._error.call(this, err);
    };

    WindowToggleSubscriber.prototype._complete = function () {
      var contexts = this.contexts;
      this.contexts = null;

      if (contexts) {
        var len = contexts.length;
        var index = -1;

        while (++index < len) {
          var context_2 = contexts[index];
          context_2.window.complete();
          context_2.subscription.unsubscribe();
        }
      }

      _super.prototype._complete.call(this);
    };

    WindowToggleSubscriber.prototype._unsubscribe = function () {
      var contexts = this.contexts;
      this.contexts = null;

      if (contexts) {
        var len = contexts.length;
        var index = -1;

        while (++index < len) {
          var context_3 = contexts[index];
          context_3.window.unsubscribe();
          context_3.subscription.unsubscribe();
        }
      }
    };

    WindowToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
      if (outerValue === this.openings) {
        var closingSelector = this.closingSelector;
        var closingNotifier = tryCatch(closingSelector)(innerValue);

        if (closingNotifier === errorObject) {
          return this.error(errorObject.e);
        } else {
          var window_1 = new Subject();
          var subscription = new Subscription();
          var context_4 = {
            window: window_1,
            subscription: subscription
          };
          this.contexts.push(context_4);
          var innerSubscription = subscribeToResult(this, closingNotifier, context_4);

          if (innerSubscription.closed) {
            this.closeWindow(this.contexts.length - 1);
          } else {
            innerSubscription.context = context_4;
            subscription.add(innerSubscription);
          }

          this.destination.next(window_1);
        }
      } else {
        this.closeWindow(this.contexts.indexOf(outerValue));
      }
    };

    WindowToggleSubscriber.prototype.notifyError = function (err) {
      this.error(err);
    };

    WindowToggleSubscriber.prototype.notifyComplete = function (inner) {
      if (inner !== this.openSubscription) {
        this.closeWindow(this.contexts.indexOf(inner.context));
      }
    };

    WindowToggleSubscriber.prototype.closeWindow = function (index) {
      if (index === -1) {
        return;
      }

      var contexts = this.contexts;
      var context = contexts[index];
      var window = context.window,
          subscription = context.subscription;
      contexts.splice(index, 1);
      window.complete();
      subscription.unsubscribe();
    };

    return WindowToggleSubscriber;
  }(OuterSubscriber);

  /** PURE_IMPORTS_START tslib,.._Subject,.._util_tryCatch,.._util_errorObject,.._OuterSubscriber,.._util_subscribeToResult PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var WindowSubscriber$1 =
  /*@__PURE__*/
  function (_super) {
    __extends(WindowSubscriber, _super);

    function WindowSubscriber(destination, closingSelector) {
      var _this = _super.call(this, destination) || this;

      _this.destination = destination;
      _this.closingSelector = closingSelector;

      _this.openWindow();

      return _this;
    }

    WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
      this.openWindow(innerSub);
    };

    WindowSubscriber.prototype.notifyError = function (error, innerSub) {
      this._error(error);
    };

    WindowSubscriber.prototype.notifyComplete = function (innerSub) {
      this.openWindow(innerSub);
    };

    WindowSubscriber.prototype._next = function (value) {
      this.window.next(value);
    };

    WindowSubscriber.prototype._error = function (err) {
      this.window.error(err);
      this.destination.error(err);
      this.unsubscribeClosingNotification();
    };

    WindowSubscriber.prototype._complete = function () {
      this.window.complete();
      this.destination.complete();
      this.unsubscribeClosingNotification();
    };

    WindowSubscriber.prototype.unsubscribeClosingNotification = function () {
      if (this.closingNotification) {
        this.closingNotification.unsubscribe();
      }
    };

    WindowSubscriber.prototype.openWindow = function (innerSub) {
      if (innerSub === void 0) {
        innerSub = null;
      }

      if (innerSub) {
        this.remove(innerSub);
        innerSub.unsubscribe();
      }

      var prevWindow = this.window;

      if (prevWindow) {
        prevWindow.complete();
      }

      var window = this.window = new Subject();
      this.destination.next(window);
      var closingNotifier = tryCatch(this.closingSelector)();

      if (closingNotifier === errorObject) {
        var err = errorObject.e;
        this.destination.error(err);
        this.window.error(err);
      } else {
        this.add(this.closingNotification = subscribeToResult(this, closingNotifier));
      }
    };

    return WindowSubscriber;
  }(OuterSubscriber);

  /** PURE_IMPORTS_START tslib,.._OuterSubscriber,.._util_subscribeToResult PURE_IMPORTS_END */
  /* tslint:enable:max-line-length */

  /**
   * Combines the source Observable with other Observables to create an Observable
   * whose values are calculated from the latest values of each, only when the
   * source emits.
   *
   * <span class="informal">Whenever the source Observable emits a value, it
   * computes a formula using that value plus the latest values from other input
   * Observables, then emits the output of that formula.</span>
   *
   * <img src="./img/withLatestFrom.png" width="100%">
   *
   * `withLatestFrom` combines each value from the source Observable (the
   * instance) with the latest values from the other input Observables only when
   * the source emits a value, optionally using a `project` function to determine
   * the value to be emitted on the output Observable. All input Observables must
   * emit at least one value before the output Observable will emit a value.
   *
   * @example <caption>On every click event, emit an array with the latest timer event plus the click event</caption>
   * var clicks = Rx.Observable.fromEvent(document, 'click');
   * var timer = Rx.Observable.interval(1000);
   * var result = clicks.withLatestFrom(timer);
   * result.subscribe(x => console.log(x));
   *
   * @see {@link combineLatest}
   *
   * @param {ObservableInput} other An input Observable to combine with the source
   * Observable. More than one input Observables may be given as argument.
   * @param {Function} [project] Projection function for combining values
   * together. Receives all values in order of the Observables passed, where the
   * first parameter is a value from the source Observable. (e.g.
   * `a.withLatestFrom(b, c, (a1, b1, c1) => a1 + b1 + c1)`). If this is not
   * passed, arrays will be emitted on the output Observable.
   * @return {Observable} An Observable of projected values from the most recent
   * values from each input Observable, or an array of the most recent values from
   * each input Observable.
   * @method withLatestFrom
   * @owner Observable
   */

  function withLatestFrom() {
    var args = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }

    return function (source) {
      var project;

      if (typeof args[args.length - 1] === 'function') {
        project = args.pop();
      }

      var observables = args;
      return source.lift(new WithLatestFromOperator(observables, project));
    };
  }

  var WithLatestFromOperator =
  /*@__PURE__*/

  /*@__PURE__*/
  function () {
    function WithLatestFromOperator(observables, project) {
      this.observables = observables;
      this.project = project;
    }

    WithLatestFromOperator.prototype.call = function (subscriber, source) {
      return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));
    };

    return WithLatestFromOperator;
  }();
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var WithLatestFromSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(WithLatestFromSubscriber, _super);

    function WithLatestFromSubscriber(destination, observables, project) {
      var _this = _super.call(this, destination) || this;

      _this.observables = observables;
      _this.project = project;
      _this.toRespond = [];
      var len = observables.length;
      _this.values = new Array(len);

      for (var i = 0; i < len; i++) {
        _this.toRespond.push(i);
      }

      for (var i = 0; i < len; i++) {
        var observable = observables[i];

        _this.add(subscribeToResult(_this, observable, observable, i));
      }

      return _this;
    }

    WithLatestFromSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
      this.values[outerIndex] = innerValue;
      var toRespond = this.toRespond;

      if (toRespond.length > 0) {
        var found = toRespond.indexOf(outerIndex);

        if (found !== -1) {
          toRespond.splice(found, 1);
        }
      }
    };

    WithLatestFromSubscriber.prototype.notifyComplete = function () {// noop
    };

    WithLatestFromSubscriber.prototype._next = function (value) {
      if (this.toRespond.length === 0) {
        var args = [value].concat(this.values);

        if (this.project) {
          this._tryProject(args);
        } else {
          this.destination.next(args);
        }
      }
    };

    WithLatestFromSubscriber.prototype._tryProject = function (args) {
      var result;

      try {
        result = this.project.apply(this, args);
      } catch (err) {
        this.destination.error(err);
        return;
      }

      this.destination.next(result);
    };

    return WithLatestFromSubscriber;
  }(OuterSubscriber);

  /** PURE_IMPORTS_START tslib,._fromArray,.._util_isArray,.._Subscriber,.._OuterSubscriber,.._util_subscribeToResult,.._.._internal_symbol_iterator PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */

  var ZipSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(ZipSubscriber, _super);

    function ZipSubscriber(destination, project, values) {
      if (values === void 0) {
        values = Object.create(null);
      }

      var _this = _super.call(this, destination) || this;

      _this.iterators = [];
      _this.active = 0;
      _this.project = typeof project === 'function' ? project : null;
      _this.values = values;
      return _this;
    }

    ZipSubscriber.prototype._next = function (value) {
      var iterators = this.iterators;

      if (isArray(value)) {
        iterators.push(new StaticArrayIterator(value));
      } else if (typeof value[iterator] === 'function') {
        iterators.push(new StaticIterator(value[iterator]()));
      } else {
        iterators.push(new ZipBufferIterator(this.destination, this, value));
      }
    };

    ZipSubscriber.prototype._complete = function () {
      var iterators = this.iterators;
      var len = iterators.length;

      if (len === 0) {
        this.destination.complete();
        return;
      }

      this.active = len;

      for (var i = 0; i < len; i++) {
        var iterator$$1 = iterators[i];

        if (iterator$$1.stillUnsubscribed) {
          this.add(iterator$$1.subscribe(iterator$$1, i));
        } else {
          this.active--; // not an observable
        }
      }
    };

    ZipSubscriber.prototype.notifyInactive = function () {
      this.active--;

      if (this.active === 0) {
        this.destination.complete();
      }
    };

    ZipSubscriber.prototype.checkIterators = function () {
      var iterators = this.iterators;
      var len = iterators.length;
      var destination = this.destination; // abort if not all of them have values

      for (var i = 0; i < len; i++) {
        var iterator$$1 = iterators[i];

        if (typeof iterator$$1.hasValue === 'function' && !iterator$$1.hasValue()) {
          return;
        }
      }

      var shouldComplete = false;
      var args = [];

      for (var i = 0; i < len; i++) {
        var iterator$$1 = iterators[i];
        var result = iterator$$1.next(); // check to see if it's completed now that you've gotten
        // the next value.

        if (iterator$$1.hasCompleted()) {
          shouldComplete = true;
        }

        if (result.done) {
          destination.complete();
          return;
        }

        args.push(result.value);
      }

      if (this.project) {
        this._tryProject(args);
      } else {
        destination.next(args);
      }

      if (shouldComplete) {
        destination.complete();
      }
    };

    ZipSubscriber.prototype._tryProject = function (args) {
      var result;

      try {
        result = this.project.apply(this, args);
      } catch (err) {
        this.destination.error(err);
        return;
      }

      this.destination.next(result);
    };

    return ZipSubscriber;
  }(Subscriber);

  var StaticIterator =
  /*@__PURE__*/

  /*@__PURE__*/
  function () {
    function StaticIterator(iterator$$1) {
      this.iterator = iterator$$1;
      this.nextResult = iterator$$1.next();
    }

    StaticIterator.prototype.hasValue = function () {
      return true;
    };

    StaticIterator.prototype.next = function () {
      var result = this.nextResult;
      this.nextResult = this.iterator.next();
      return result;
    };

    StaticIterator.prototype.hasCompleted = function () {
      var nextResult = this.nextResult;
      return nextResult && nextResult.done;
    };

    return StaticIterator;
  }();

  var StaticArrayIterator =
  /*@__PURE__*/

  /*@__PURE__*/
  function () {
    function StaticArrayIterator(array) {
      this.array = array;
      this.index = 0;
      this.length = 0;
      this.length = array.length;
    }

    StaticArrayIterator.prototype[iterator] = function () {
      return this;
    };

    StaticArrayIterator.prototype.next = function (value) {
      var i = this.index++;
      var array = this.array;
      return i < this.length ? {
        value: array[i],
        done: false
      } : {
        value: null,
        done: true
      };
    };

    StaticArrayIterator.prototype.hasValue = function () {
      return this.array.length > this.index;
    };

    StaticArrayIterator.prototype.hasCompleted = function () {
      return this.array.length === this.index;
    };

    return StaticArrayIterator;
  }();
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */


  var ZipBufferIterator =
  /*@__PURE__*/
  function (_super) {
    __extends(ZipBufferIterator, _super);

    function ZipBufferIterator(destination, parent, observable) {
      var _this = _super.call(this, destination) || this;

      _this.parent = parent;
      _this.observable = observable;
      _this.stillUnsubscribed = true;
      _this.buffer = [];
      _this.isComplete = false;
      return _this;
    }

    ZipBufferIterator.prototype[iterator] = function () {
      return this;
    }; // NOTE: there is actually a name collision here with Subscriber.next and Iterator.next
    //    this is legit because `next()` will never be called by a subscription in this case.


    ZipBufferIterator.prototype.next = function () {
      var buffer = this.buffer;

      if (buffer.length === 0 && this.isComplete) {
        return {
          value: null,
          done: true
        };
      } else {
        return {
          value: buffer.shift(),
          done: false
        };
      }
    };

    ZipBufferIterator.prototype.hasValue = function () {
      return this.buffer.length > 0;
    };

    ZipBufferIterator.prototype.hasCompleted = function () {
      return this.buffer.length === 0 && this.isComplete;
    };

    ZipBufferIterator.prototype.notifyComplete = function () {
      if (this.buffer.length > 0) {
        this.isComplete = true;
        this.parent.notifyInactive();
      } else {
        this.destination.complete();
      }
    };

    ZipBufferIterator.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
      this.buffer.push(innerValue);
      this.parent.checkIterators();
    };

    ZipBufferIterator.prototype.subscribe = function (value, index) {
      return subscribeToResult(this, this.observable, this, index);
    };

    return ZipBufferIterator;
  }(OuterSubscriber);

  /** PURE_IMPORTS_START .._observable_zip PURE_IMPORTS_END */

  /* Operator exports */

  var isFunction_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    function isFunction(x) {
      return typeof x === 'function';
    }

    exports.isFunction = isFunction; 
  });
  unwrapExports(isFunction_1);
  var isFunction_2 = isFunction_1.isFunction;

  var Observer$1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.empty = {
      closed: true,
      next: function next(value) {},
      error: function error(err) {
        throw err;
      },
      complete: function complete() {}
    }; 
  });
  unwrapExports(Observer$1);
  var Observer_1 = Observer$1.empty;

  var isArray$1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    exports.isArray = Array.isArray || function (x) {
      return x && typeof x.length === 'number';
    }; 

  });
  unwrapExports(isArray$1);
  var isArray_1 = isArray$1.isArray;

  var isObject_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    function isObject(x) {
      return x != null && typeof x === 'object';
    }

    exports.isObject = isObject; 
  });
  unwrapExports(isObject_1);
  var isObject_2 = isObject_1.isObject;

  var errorObject$1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    }); // typeof any so that it we don't have to cast when comparing a result to the error object

    exports.errorObject = {
      e: {}
    }; 
  });
  unwrapExports(errorObject$1);
  var errorObject_1 = errorObject$1.errorObject;

  var tryCatch_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var tryCatchTarget;

    function tryCatcher() {
      try {
        return tryCatchTarget.apply(this, arguments);
      } catch (e) {
        errorObject$1.errorObject.e = e;
        return errorObject$1.errorObject;
      }
    }

    function tryCatch(fn) {
      tryCatchTarget = fn;
      return tryCatcher;
    }

    exports.tryCatch = tryCatch; 
  });
  unwrapExports(tryCatch_1);
  var tryCatch_2 = tryCatch_1.tryCatch;

  var UnsubscriptionError_1 = createCommonjsModule(function (module, exports) {

    var __extends = commonjsGlobal && commonjsGlobal.__extends || function () {
      var extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (b.hasOwnProperty(p)) d[p] = b[p];
        }
      };

      return function (d, b) {
        extendStatics(d, b);

        function __() {
          this.constructor = d;
        }

        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /**
     * An error thrown when one or more errors have occurred during the
     * `unsubscribe` of a {@link Subscription}.
     */

    var UnsubscriptionError =
    /** @class */
    function (_super) {
      __extends(UnsubscriptionError, _super);

      function UnsubscriptionError(errors) {
        var _this = _super.call(this, errors ? errors.length + " errors occurred during unsubscription:\n  " + errors.map(function (err, i) {
          return i + 1 + ") " + err.toString();
        }).join('\n  ') : '') || this;

        _this.errors = errors;
        _this.name = 'UnsubscriptionError';
        Object.setPrototypeOf(_this, UnsubscriptionError.prototype);
        return _this;
      }

      return UnsubscriptionError;
    }(Error);

    exports.UnsubscriptionError = UnsubscriptionError; 
  });
  unwrapExports(UnsubscriptionError_1);
  var UnsubscriptionError_2 = UnsubscriptionError_1.UnsubscriptionError;

  var Subscription_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /**
     * Represents a disposable resource, such as the execution of an Observable. A
     * Subscription has one important method, `unsubscribe`, that takes no argument
     * and just disposes the resource held by the subscription.
     *
     * Additionally, subscriptions may be grouped together through the `add()`
     * method, which will attach a child Subscription to the current Subscription.
     * When a Subscription is unsubscribed, all its children (and its grandchildren)
     * will be unsubscribed as well.
     *
     * @class Subscription
     */

    var Subscription =
    /** @class */
    function () {
      /**
       * @param {function(): void} [unsubscribe] A function describing how to
       * perform the disposal of resources when the `unsubscribe` method is called.
       */
      function Subscription(unsubscribe) {
        /**
         * A flag to indicate whether this Subscription has already been unsubscribed.
         * @type {boolean}
         */
        this.closed = false;
        /** @internal */

        this._parent = null;
        /** @internal */

        this._parents = null;
        /** @internal */

        this._subscriptions = null;

        if (unsubscribe) {
          this._unsubscribe = unsubscribe;
        }
      }
      /**
       * Disposes the resources held by the subscription. May, for instance, cancel
       * an ongoing Observable execution or cancel any other type of work that
       * started when the Subscription was created.
       * @return {void}
       */


      Subscription.prototype.unsubscribe = function () {
        var hasErrors = false;
        var errors;

        if (this.closed) {
          return;
        }

        var _a = this,
            _parent = _a._parent,
            _parents = _a._parents,
            _unsubscribe = _a._unsubscribe,
            _subscriptions = _a._subscriptions;

        this.closed = true;
        this._parent = null;
        this._parents = null; // null out _subscriptions first so any child subscriptions that attempt
        // to remove themselves from this subscription will noop

        this._subscriptions = null;
        var index = -1;
        var len = _parents ? _parents.length : 0; // if this._parent is null, then so is this._parents, and we
        // don't have to remove ourselves from any parent subscriptions.

        while (_parent) {
          _parent.remove(this); // if this._parents is null or index >= len,
          // then _parent is set to null, and the loop exits


          _parent = ++index < len && _parents[index] || null;
        }

        if (isFunction_1.isFunction(_unsubscribe)) {
          var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);

          if (trial === errorObject$1.errorObject) {
            hasErrors = true;
            errors = errors || (errorObject$1.errorObject.e instanceof UnsubscriptionError_1.UnsubscriptionError ? flattenUnsubscriptionErrors(errorObject$1.errorObject.e.errors) : [errorObject$1.errorObject.e]);
          }
        }

        if (isArray$1.isArray(_subscriptions)) {
          index = -1;
          len = _subscriptions.length;

          while (++index < len) {
            var sub = _subscriptions[index];

            if (isObject_1.isObject(sub)) {
              var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);

              if (trial === errorObject$1.errorObject) {
                hasErrors = true;
                errors = errors || [];
                var err = errorObject$1.errorObject.e;

                if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
                  errors = errors.concat(flattenUnsubscriptionErrors(err.errors));
                } else {
                  errors.push(err);
                }
              }
            }
          }
        }

        if (hasErrors) {
          throw new UnsubscriptionError_1.UnsubscriptionError(errors);
        }
      };
      /**
       * Adds a tear down to be called during the unsubscribe() of this
       * Subscription.
       *
       * If the tear down being added is a subscription that is already
       * unsubscribed, is the same reference `add` is being called on, or is
       * `Subscription.EMPTY`, it will not be added.
       *
       * If this subscription is already in an `closed` state, the passed
       * tear down logic will be executed immediately.
       *
       * @param {TeardownLogic} teardown The additional logic to execute on
       * teardown.
       * @return {Subscription} Returns the Subscription used or created to be
       * added to the inner subscriptions list. This Subscription can be used with
       * `remove()` to remove the passed teardown logic from the inner subscriptions
       * list.
       */


      Subscription.prototype.add = function (teardown) {
        if (!teardown || teardown === Subscription.EMPTY) {
          return Subscription.EMPTY;
        }

        if (teardown === this) {
          return this;
        }

        var subscription = teardown;

        switch (typeof teardown) {
          case 'function':
            subscription = new Subscription(teardown);

          case 'object':
            if (subscription.closed || typeof subscription.unsubscribe !== 'function') {
              return subscription;
            } else if (this.closed) {
              subscription.unsubscribe();
              return subscription;
            } else if (typeof subscription._addParent !== 'function'
            /* quack quack */
            ) {
                var tmp = subscription;
                subscription = new Subscription();
                subscription._subscriptions = [tmp];
              }

            break;

          default:
            throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
        }

        var subscriptions = this._subscriptions || (this._subscriptions = []);
        subscriptions.push(subscription);

        subscription._addParent(this);

        return subscription;
      };
      /**
       * Removes a Subscription from the internal list of subscriptions that will
       * unsubscribe during the unsubscribe process of this Subscription.
       * @param {Subscription} subscription The subscription to remove.
       * @return {void}
       */


      Subscription.prototype.remove = function (subscription) {
        var subscriptions = this._subscriptions;

        if (subscriptions) {
          var subscriptionIndex = subscriptions.indexOf(subscription);

          if (subscriptionIndex !== -1) {
            subscriptions.splice(subscriptionIndex, 1);
          }
        }
      };
      /** @internal */


      Subscription.prototype._addParent = function (parent) {
        var _a = this,
            _parent = _a._parent,
            _parents = _a._parents;

        if (!_parent || _parent === parent) {
          // If we don't have a parent, or the new parent is the same as the
          // current parent, then set this._parent to the new parent.
          this._parent = parent;
        } else if (!_parents) {
          // If there's already one parent, but not multiple, allocate an Array to
          // store the rest of the parent Subscriptions.
          this._parents = [parent];
        } else if (_parents.indexOf(parent) === -1) {
          // Only add the new parent to the _parents list if it's not already there.
          _parents.push(parent);
        }
      };

      Subscription.EMPTY = function (empty) {
        empty.closed = true;
        return empty;
      }(new Subscription());

      return Subscription;
    }();

    exports.Subscription = Subscription;

    function flattenUnsubscriptionErrors(errors) {
      return errors.reduce(function (errs, err) {
        return errs.concat(err instanceof UnsubscriptionError_1.UnsubscriptionError ? err.errors : err);
      }, []);
    } 

  });
  unwrapExports(Subscription_1);
  var Subscription_2 = Subscription_1.Subscription;

  var rxSubscriber$1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.rxSubscriber = typeof Symbol === 'function' && typeof Symbol.for === 'function' ? Symbol.for('rxSubscriber') : '@@rxSubscriber';
    /**
     * @deprecated use rxSubscriber instead
     */

    exports.$$rxSubscriber = exports.rxSubscriber; 
  });
  unwrapExports(rxSubscriber$1);
  var rxSubscriber_1 = rxSubscriber$1.rxSubscriber;
  var rxSubscriber_2 = rxSubscriber$1.$$rxSubscriber;

  var Subscriber_1 = createCommonjsModule(function (module, exports) {

    var __extends = commonjsGlobal && commonjsGlobal.__extends || function () {
      var extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (b.hasOwnProperty(p)) d[p] = b[p];
        }
      };

      return function (d, b) {
        extendStatics(d, b);

        function __() {
          this.constructor = d;
        }

        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /**
     * Implements the {@link Observer} interface and extends the
     * {@link Subscription} class. While the {@link Observer} is the public API for
     * consuming the values of an {@link Observable}, all Observers get converted to
     * a Subscriber, in order to provide Subscription-like capabilities such as
     * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for
     * implementing operators, but it is rarely used as a public API.
     *
     * @class Subscriber<T>
     */

    var Subscriber =
    /** @class */
    function (_super) {
      __extends(Subscriber, _super);
      /**
       * @param {Observer|function(value: T): void} [destinationOrNext] A partially
       * defined Observer or a `next` callback function.
       * @param {function(e: ?any): void} [error] The `error` callback of an
       * Observer.
       * @param {function(): void} [complete] The `complete` callback of an
       * Observer.
       */


      function Subscriber(destinationOrNext, error, complete) {
        var _this = _super.call(this) || this;

        _this.isStopped = false;

        switch (arguments.length) {
          case 0:
            _this.destination = Observer$1.empty;
            break;

          case 1:
            if (!destinationOrNext) {
              _this.destination = Observer$1.empty;
              break;
            }

            if (typeof destinationOrNext === 'object') {
              if (destinationOrNext instanceof Subscriber) {
                _this.destination = destinationOrNext;

                _this.destination.add(_this);
              } else {
                _this.destination = new SafeSubscriber(destinationOrNext);
              }

              break;
            }

          default:
            _this.destination = new SafeSubscriber(destinationOrNext, error, complete);
            break;
        }

        return _this;
      }

      Subscriber.prototype[rxSubscriber$1.rxSubscriber] = function () {
        return this;
      };
      /**
       * A static factory for a Subscriber, given a (potentially partial) definition
       * of an Observer.
       * @param {function(x: ?T): void} [next] The `next` callback of an Observer.
       * @param {function(e: ?any): void} [error] The `error` callback of an
       * Observer.
       * @param {function(): void} [complete] The `complete` callback of an
       * Observer.
       * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)
       * Observer represented by the given arguments.
       */


      Subscriber.create = function (next, error, complete) {
        var subscriber = new Subscriber(next, error, complete);
        return subscriber;
      };
      /**
       * The {@link Observer} callback to receive notifications of type `next` from
       * the Observable, with a value. The Observable may call this method 0 or more
       * times.
       * @param {T} [value] The `next` value.
       * @return {void}
       */


      Subscriber.prototype.next = function (value) {
        if (!this.isStopped) {
          this._next(value);
        }
      };
      /**
       * The {@link Observer} callback to receive notifications of type `error` from
       * the Observable, with an attached {@link Error}. Notifies the Observer that
       * the Observable has experienced an error condition.
       * @param {any} [err] The `error` exception.
       * @return {void}
       */


      Subscriber.prototype.error = function (err) {
        if (!this.isStopped) {
          this.isStopped = true;

          this._error(err);
        }
      };
      /**
       * The {@link Observer} callback to receive a valueless notification of type
       * `complete` from the Observable. Notifies the Observer that the Observable
       * has finished sending push-based notifications.
       * @return {void}
       */


      Subscriber.prototype.complete = function () {
        if (!this.isStopped) {
          this.isStopped = true;

          this._complete();
        }
      };

      Subscriber.prototype.unsubscribe = function () {
        if (this.closed) {
          return;
        }

        this.isStopped = true;

        _super.prototype.unsubscribe.call(this);
      };

      Subscriber.prototype._next = function (value) {
        this.destination.next(value);
      };

      Subscriber.prototype._error = function (err) {
        this.destination.error(err);
        this.unsubscribe();
      };

      Subscriber.prototype._complete = function () {
        this.destination.complete();
        this.unsubscribe();
      };

      Subscriber.prototype._unsubscribeAndRecycle = function () {
        var _a = this,
            _parent = _a._parent,
            _parents = _a._parents;

        this._parent = null;
        this._parents = null;
        this.unsubscribe();
        this.closed = false;
        this.isStopped = false;
        this._parent = _parent;
        this._parents = _parents;
        return this;
      };

      return Subscriber;
    }(Subscription_1.Subscription);

    exports.Subscriber = Subscriber;
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */

    var SafeSubscriber =
    /** @class */
    function (_super) {
      __extends(SafeSubscriber, _super);

      function SafeSubscriber(observerOrNext, error, complete) {
        var _this = _super.call(this) || this;

        var next;
        var context = _this;

        if (isFunction_1.isFunction(observerOrNext)) {
          next = observerOrNext;
        } else if (observerOrNext) {
          next = observerOrNext.next;
          error = observerOrNext.error;
          complete = observerOrNext.complete;

          if (observerOrNext !== Observer$1.empty) {
            context = Object.create(observerOrNext);

            if (isFunction_1.isFunction(context.unsubscribe)) {
              _this.add(context.unsubscribe.bind(context));
            }

            context.unsubscribe = _this.unsubscribe.bind(_this);
          }
        }

        _this._context = context;
        _this._next = next;
        _this._error = error;
        _this._complete = complete;
        return _this;
      }

      SafeSubscriber.prototype.next = function (value) {
        if (!this.isStopped && this._next) {
          try {
            this._next.call(this._context, value);
          } catch (err) {
            this._hostReportError(err);

            this.unsubscribe();
          }
        }
      };

      SafeSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
          if (this._error) {
            try {
              this._error.call(this._context, err);
            } catch (err) {
              this._hostReportError(err);
            }
          } else {
            this._hostReportError(err);
          }

          this.unsubscribe();
        }
      };

      SafeSubscriber.prototype.complete = function () {
        if (!this.isStopped) {
          if (this._complete) {
            try {
              this._complete.call(this._context);
            } catch (err) {
              this._hostReportError(err);
            }
          }

          this.unsubscribe();
        }
      };

      SafeSubscriber.prototype._unsubscribe = function () {
        this._context = null;
      };

      SafeSubscriber.prototype._hostReportError = function (err) {
        setTimeout(function () {
          throw err;
        });
      };

      return SafeSubscriber;
    }(Subscriber); 

  });
  unwrapExports(Subscriber_1);
  var Subscriber_2 = Subscriber_1.Subscriber;

  var toSubscriber_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    function toSubscriber(nextOrObserver, error, complete) {
      if (nextOrObserver) {
        if (nextOrObserver instanceof Subscriber_1.Subscriber) {
          return nextOrObserver;
        }

        if (nextOrObserver[rxSubscriber$1.rxSubscriber]) {
          return nextOrObserver[rxSubscriber$1.rxSubscriber]();
        }
      }

      if (!nextOrObserver && !error && !complete) {
        return new Subscriber_1.Subscriber(Observer$1.empty);
      }

      return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
    }

    exports.toSubscriber = toSubscriber; 
  });
  unwrapExports(toSubscriber_1);
  var toSubscriber_2 = toSubscriber_1.toSubscriber;

  var observable$1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /** Symbol.observable or a string "@@observable". Used for interop */

    exports.observable = typeof Symbol === 'function' && Symbol.observable || '@@observable'; 
  });
  unwrapExports(observable$1);
  var observable_1 = observable$1.observable;

  var noop_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /* tslint:disable:no-empty */

    function noop() {}

    exports.noop = noop; 
  });
  unwrapExports(noop_1);
  var noop_2 = noop_1.noop;

  var pipe_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /* tslint:enable:max-line-length */

    function pipe() {
      var fns = [];

      for (var _i = 0; _i < arguments.length; _i++) {
        fns[_i] = arguments[_i];
      }

      return pipeFromArray(fns);
    }

    exports.pipe = pipe;
    /* @internal */

    function pipeFromArray(fns) {
      if (!fns) {
        return noop_1.noop;
      }

      if (fns.length === 1) {
        return fns[0];
      }

      return function piped(input) {
        return fns.reduce(function (prev, fn) {
          return fn(prev);
        }, input);
      };
    }

    exports.pipeFromArray = pipeFromArray; 
  });
  unwrapExports(pipe_1);
  var pipe_2 = pipe_1.pipe;
  var pipe_3 = pipe_1.pipeFromArray;

  var config$1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /**
     * The global configuration object for RxJS, used to configure things
     * like what Promise contructor should used to create Promises
     */

    exports.config = {
      /**
       * The promise constructor used by default for methods such as
       * {@link toPromise} and {@link forEach}
       */
      Promise: Promise
    }; 
  });
  unwrapExports(config$1);
  var config_1 = config$1.config;

  var Observable_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /**
     * A representation of any set of values over any amount of time. This is the most basic building block
     * of RxJS.
     *
     * @class Observable<T>
     */

    var Observable =
    /** @class */
    function () {
      /**
       * @constructor
       * @param {Function} subscribe the function that is called when the Observable is
       * initially subscribed to. This function is given a Subscriber, to which new values
       * can be `next`ed, or an `error` method can be called to raise an error, or
       * `complete` can be called to notify of a successful completion.
       */
      function Observable(subscribe) {
        /** @internal */
        this._isScalar = false;

        if (subscribe) {
          this._subscribe = subscribe;
        }
      }
      /**
       * Creates a new Observable, with this Observable as the source, and the passed
       * operator defined as the new observable's operator.
       * @method lift
       * @param {Operator} operator the operator defining the operation to take on the observable
       * @return {Observable} a new observable with the Operator applied
       */


      Observable.prototype.lift = function (operator) {
        var observable = new Observable();
        observable.source = this;
        observable.operator = operator;
        return observable;
      };
      /**
       * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.
       *
       * <span class="informal">Use it when you have all these Observables, but still nothing is happening.</span>
       *
       * `subscribe` is not a regular operator, but a method that calls Observable's internal `subscribe` function. It
       * might be for example a function that you passed to a {@link create} static factory, but most of the time it is
       * a library implementation, which defines what and when will be emitted by an Observable. This means that calling
       * `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often
       * thought.
       *
       * Apart from starting the execution of an Observable, this method allows you to listen for values
       * that an Observable emits, as well as for when it completes or errors. You can achieve this in two
       * following ways.
       *
       * The first way is creating an object that implements {@link Observer} interface. It should have methods
       * defined by that interface, but note that it should be just a regular JavaScript object, which you can create
       * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular do
       * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also
       * that your object does not have to implement all methods. If you find yourself creating a method that doesn't
       * do anything, you can simply omit it. Note however, that if `error` method is not provided, all errors will
       * be left uncaught.
       *
       * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.
       * This means you can provide three functions as arguments to `subscribe`, where first function is equivalent
       * of a `next` method, second of an `error` method and third of a `complete` method. Just as in case of Observer,
       * if you do not need to listen for something, you can omit a function, preferably by passing `undefined` or `null`,
       * since `subscribe` recognizes these functions by where they were placed in function call. When it comes
       * to `error` function, just as before, if not provided, errors emitted by an Observable will be thrown.
       *
       * Whatever style of calling `subscribe` you use, in both cases it returns a Subscription object.
       * This object allows you to call `unsubscribe` on it, which in turn will stop work that an Observable does and will clean
       * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback
       * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.
       *
       * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.
       * It is an Observable itself that decides when these functions will be called. For example {@link of}
       * by default emits all its values synchronously. Always check documentation for how given Observable
       * will behave when subscribed and if its default behavior can be modified with a {@link Scheduler}.
       *
       * @example <caption>Subscribe with an Observer</caption>
       * const sumObserver = {
       *   sum: 0,
       *   next(value) {
       *     console.log('Adding: ' + value);
       *     this.sum = this.sum + value;
       *   },
       *   error() { // We actually could just remove this method,
       *   },        // since we do not really care about errors right now.
       *   complete() {
       *     console.log('Sum equals: ' + this.sum);
       *   }
       * };
       *
       * Rx.Observable.of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.
       * .subscribe(sumObserver);
       *
       * // Logs:
       * // "Adding: 1"
       * // "Adding: 2"
       * // "Adding: 3"
       * // "Sum equals: 6"
       *
       *
       * @example <caption>Subscribe with functions</caption>
       * let sum = 0;
       *
       * Rx.Observable.of(1, 2, 3)
       * .subscribe(
       *   function(value) {
       *     console.log('Adding: ' + value);
       *     sum = sum + value;
       *   },
       *   undefined,
       *   function() {
       *     console.log('Sum equals: ' + sum);
       *   }
       * );
       *
       * // Logs:
       * // "Adding: 1"
       * // "Adding: 2"
       * // "Adding: 3"
       * // "Sum equals: 6"
       *
       *
       * @example <caption>Cancel a subscription</caption>
       * const subscription = Rx.Observable.interval(1000).subscribe(
       *   num => console.log(num),
       *   undefined,
       *   () => console.log('completed!') // Will not be called, even
       * );                                // when cancelling subscription
       *
       *
       * setTimeout(() => {
       *   subscription.unsubscribe();
       *   console.log('unsubscribed!');
       * }, 2500);
       *
       * // Logs:
       * // 0 after 1s
       * // 1 after 2s
       * // "unsubscribed!" after 2.5s
       *
       *
       * @param {Observer|Function} observerOrNext (optional) Either an observer with methods to be called,
       *  or the first of three possible handlers, which is the handler for each value emitted from the subscribed
       *  Observable.
       * @param {Function} error (optional) A handler for a terminal event resulting from an error. If no error handler is provided,
       *  the error will be thrown as unhandled.
       * @param {Function} complete (optional) A handler for a terminal event resulting from successful completion.
       * @return {ISubscription} a subscription reference to the registered handlers
       * @method subscribe
       */


      Observable.prototype.subscribe = function (observerOrNext, error, complete) {
        var operator = this.operator;
        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);

        if (operator) {
          operator.call(sink, this.source);
        } else {
          sink.add(this.source ? this._subscribe(sink) : this._trySubscribe(sink));
        }

        return sink;
      };

      Observable.prototype._trySubscribe = function (sink) {
        try {
          return this._subscribe(sink);
        } catch (err) {
          sink.error(err);
        }
      };
      /**
       * @method forEach
       * @param {Function} next a handler for each value emitted by the observable
       * @param {PromiseConstructor} [promiseCtor] a constructor function used to instantiate the Promise
       * @return {Promise} a promise that either resolves on observable completion or
       *  rejects with the handled error
       */


      Observable.prototype.forEach = function (next, promiseCtor) {
        var _this = this;

        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function (resolve, reject) {
          // Must be declared in a separate statement to avoid a RefernceError when
          // accessing subscription below in the closure due to Temporal Dead Zone.
          var subscription;
          subscription = _this.subscribe(function (value) {
            try {
              next(value);
            } catch (err) {
              reject(err);

              if (subscription) {
                subscription.unsubscribe();
              }
            }
          }, reject, resolve);
        });
      };
      /** @internal */


      Observable.prototype._subscribe = function (subscriber) {
        return this.source.subscribe(subscriber);
      };
      /**
       * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable
       * @method Symbol.observable
       * @return {Observable} this instance of the observable
       */


      Observable.prototype[observable$1.observable] = function () {
        return this;
      };
      /* tslint:enable:max-line-length */

      /**
       * Used to stitch together functional operators into a chain.
       * @method pipe
       * @return {Observable} the Observable result of all of the operators having
       * been called in the order they were passed in.
       *
       * @example
       *
       * import { map, filter, scan } from 'rxjs/internal/operators';
       *
       * Rx.Observable.interval(1000)
       *   .pipe(
       *     filter(x => x % 2 === 0),
       *     map(x => x + x),
       *     scan((acc, x) => acc + x)
       *   )
       *   .subscribe(x => console.log(x))
       */


      Observable.prototype.pipe = function () {
        var operations = [];

        for (var _i = 0; _i < arguments.length; _i++) {
          operations[_i] = arguments[_i];
        }

        if (operations.length === 0) {
          return this;
        }

        return pipe_1.pipeFromArray(operations)(this);
      };
      /* tslint:enable:max-line-length */


      Observable.prototype.toPromise = function (promiseCtor) {
        var _this = this;

        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function (resolve, reject) {
          var value;

          _this.subscribe(function (x) {
            return value = x;
          }, function (err) {
            return reject(err);
          }, function () {
            return resolve(value);
          });
        });
      }; // HACK: Since TypeScript inherits static properties too, we have to
      // fight against TypeScript here so Subject can have a different static create signature

      /**
       * Creates a new cold Observable by calling the Observable constructor
       * @static true
       * @owner Observable
       * @method create
       * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
       * @return {Observable} a new cold observable
       */


      Observable.create = function (subscribe) {
        return new Observable(subscribe);
      };

      return Observable;
    }();

    exports.Observable = Observable;
    /**
     * Decides between a passed promise constructor from consuming code,
     * A default configured promise constructor, and the native promise
     * constructor and returns it. If nothing can be found, it will throw
     * an error.
     * @param promiseCtor The optional promise constructor to passed by consuming code
     */

    function getPromiseCtor(promiseCtor) {
      if (!promiseCtor) {
        promiseCtor = config$1.config.Promise || Promise;
      }

      if (!promiseCtor) {
        throw new Error('no Promise impl found');
      }

      return promiseCtor;
    } 

  });
  unwrapExports(Observable_1);
  var Observable_2 = Observable_1.Observable;

  var ObjectUnsubscribedError_1 = createCommonjsModule(function (module, exports) {

    var __extends = commonjsGlobal && commonjsGlobal.__extends || function () {
      var extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (b.hasOwnProperty(p)) d[p] = b[p];
        }
      };

      return function (d, b) {
        extendStatics(d, b);

        function __() {
          this.constructor = d;
        }

        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /**
     * An error thrown when an action is invalid because the object has been
     * unsubscribed.
     *
     * @see {@link Subject}
     * @see {@link BehaviorSubject}
     *
     * @class ObjectUnsubscribedError
     */

    var ObjectUnsubscribedError =
    /** @class */
    function (_super) {
      __extends(ObjectUnsubscribedError, _super);

      function ObjectUnsubscribedError() {
        var _this = _super.call(this, 'object unsubscribed') || this;

        _this.name = 'ObjectUnsubscribedError';
        Object.setPrototypeOf(_this, ObjectUnsubscribedError.prototype);
        return _this;
      }

      return ObjectUnsubscribedError;
    }(Error);

    exports.ObjectUnsubscribedError = ObjectUnsubscribedError; 
  });
  unwrapExports(ObjectUnsubscribedError_1);
  var ObjectUnsubscribedError_2 = ObjectUnsubscribedError_1.ObjectUnsubscribedError;

  var SubjectSubscription_1 = createCommonjsModule(function (module, exports) {

    var __extends = commonjsGlobal && commonjsGlobal.__extends || function () {
      var extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (b.hasOwnProperty(p)) d[p] = b[p];
        }
      };

      return function (d, b) {
        extendStatics(d, b);

        function __() {
          this.constructor = d;
        }

        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */

    var SubjectSubscription =
    /** @class */
    function (_super) {
      __extends(SubjectSubscription, _super);

      function SubjectSubscription(subject, subscriber) {
        var _this = _super.call(this) || this;

        _this.subject = subject;
        _this.subscriber = subscriber;
        _this.closed = false;
        return _this;
      }

      SubjectSubscription.prototype.unsubscribe = function () {
        if (this.closed) {
          return;
        }

        this.closed = true;
        var subject = this.subject;
        var observers = subject.observers;
        this.subject = null;

        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
          return;
        }

        var subscriberIndex = observers.indexOf(this.subscriber);

        if (subscriberIndex !== -1) {
          observers.splice(subscriberIndex, 1);
        }
      };

      return SubjectSubscription;
    }(Subscription_1.Subscription);

    exports.SubjectSubscription = SubjectSubscription; 
  });
  unwrapExports(SubjectSubscription_1);
  var SubjectSubscription_2 = SubjectSubscription_1.SubjectSubscription;

  var Subject_1 = createCommonjsModule(function (module, exports) {

    var __extends = commonjsGlobal && commonjsGlobal.__extends || function () {
      var extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (b.hasOwnProperty(p)) d[p] = b[p];
        }
      };

      return function (d, b) {
        extendStatics(d, b);

        function __() {
          this.constructor = d;
        }

        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /**
     * @class SubjectSubscriber<T>
     */

    var SubjectSubscriber =
    /** @class */
    function (_super) {
      __extends(SubjectSubscriber, _super);

      function SubjectSubscriber(destination) {
        var _this = _super.call(this, destination) || this;

        _this.destination = destination;
        return _this;
      }

      return SubjectSubscriber;
    }(Subscriber_1.Subscriber);

    exports.SubjectSubscriber = SubjectSubscriber;
    /**
     * @class Subject<T>
     */

    var Subject =
    /** @class */
    function (_super) {
      __extends(Subject, _super);

      function Subject() {
        var _this = _super.call(this) || this;

        _this.observers = [];
        _this.closed = false;
        _this.isStopped = false;
        _this.hasError = false;
        _this.thrownError = null;
        return _this;
      }

      Subject.prototype[rxSubscriber$1.rxSubscriber] = function () {
        return new SubjectSubscriber(this);
      };

      Subject.prototype.lift = function (operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
      };

      Subject.prototype.next = function (value) {
        if (this.closed) {
          throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }

        if (!this.isStopped) {
          var observers = this.observers;
          var len = observers.length;
          var copy = observers.slice();

          for (var i = 0; i < len; i++) {
            copy[i].next(value);
          }
        }
      };

      Subject.prototype.error = function (err) {
        if (this.closed) {
          throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }

        this.hasError = true;
        this.thrownError = err;
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();

        for (var i = 0; i < len; i++) {
          copy[i].error(err);
        }

        this.observers.length = 0;
      };

      Subject.prototype.complete = function () {
        if (this.closed) {
          throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }

        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();

        for (var i = 0; i < len; i++) {
          copy[i].complete();
        }

        this.observers.length = 0;
      };

      Subject.prototype.unsubscribe = function () {
        this.isStopped = true;
        this.closed = true;
        this.observers = null;
      };

      Subject.prototype._trySubscribe = function (subscriber) {
        if (this.closed) {
          throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        } else {
          return _super.prototype._trySubscribe.call(this, subscriber);
        }
      };

      Subject.prototype._subscribe = function (subscriber) {
        if (this.closed) {
          throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        } else if (this.hasError) {
          subscriber.error(this.thrownError);
          return Subscription_1.Subscription.EMPTY;
        } else if (this.isStopped) {
          subscriber.complete();
          return Subscription_1.Subscription.EMPTY;
        } else {
          this.observers.push(subscriber);
          return new SubjectSubscription_1.SubjectSubscription(this, subscriber);
        }
      };

      Subject.prototype.asObservable = function () {
        var observable = new Observable_1.Observable();
        observable.source = this;
        return observable;
      };

      Subject.create = function (destination, source) {
        return new AnonymousSubject(destination, source);
      };

      return Subject;
    }(Observable_1.Observable);

    exports.Subject = Subject;
    /**
     * @class AnonymousSubject<T>
     */

    var AnonymousSubject =
    /** @class */
    function (_super) {
      __extends(AnonymousSubject, _super);

      function AnonymousSubject(destination, source) {
        var _this = _super.call(this) || this;

        _this.destination = destination;
        _this.source = source;
        return _this;
      }

      AnonymousSubject.prototype.next = function (value) {
        var destination = this.destination;

        if (destination && destination.next) {
          destination.next(value);
        }
      };

      AnonymousSubject.prototype.error = function (err) {
        var destination = this.destination;

        if (destination && destination.error) {
          this.destination.error(err);
        }
      };

      AnonymousSubject.prototype.complete = function () {
        var destination = this.destination;

        if (destination && destination.complete) {
          this.destination.complete();
        }
      };

      AnonymousSubject.prototype._subscribe = function (subscriber) {
        var source = this.source;

        if (source) {
          return this.source.subscribe(subscriber);
        } else {
          return Subscription_1.Subscription.EMPTY;
        }
      };

      return AnonymousSubject;
    }(Subject);

    exports.AnonymousSubject = AnonymousSubject; 
  });
  unwrapExports(Subject_1);
  var Subject_2 = Subject_1.SubjectSubscriber;
  var Subject_3 = Subject_1.Subject;
  var Subject_4 = Subject_1.AnonymousSubject;

  var refCount_1 = createCommonjsModule(function (module, exports) {

    var __extends = commonjsGlobal && commonjsGlobal.__extends || function () {
      var extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (b.hasOwnProperty(p)) d[p] = b[p];
        }
      };

      return function (d, b) {
        extendStatics(d, b);

        function __() {
          this.constructor = d;
        }

        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    function refCount() {
      return function refCountOperatorFunction(source) {
        return source.lift(new RefCountOperator(source));
      };
    }

    exports.refCount = refCount;

    var RefCountOperator =
    /** @class */
    function () {
      function RefCountOperator(connectable) {
        this.connectable = connectable;
      }

      RefCountOperator.prototype.call = function (subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber(subscriber, connectable);
        var subscription = source.subscribe(refCounter);

        if (!refCounter.closed) {
          refCounter.connection = connectable.connect();
        }

        return subscription;
      };

      return RefCountOperator;
    }();

    var RefCountSubscriber =
    /** @class */
    function (_super) {
      __extends(RefCountSubscriber, _super);

      function RefCountSubscriber(destination, connectable) {
        var _this = _super.call(this, destination) || this;

        _this.connectable = connectable;
        return _this;
      }

      RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;

        if (!connectable) {
          this.connection = null;
          return;
        }

        this.connectable = null;
        var refCount = connectable._refCount;

        if (refCount <= 0) {
          this.connection = null;
          return;
        }

        connectable._refCount = refCount - 1;

        if (refCount > 1) {
          this.connection = null;
          return;
        } ///
        // Compare the local RefCountSubscriber's connection Subscription to the
        // connection Subscription on the shared ConnectableObservable. In cases
        // where the ConnectableObservable source synchronously emits values, and
        // the RefCountSubscriber's downstream Observers synchronously unsubscribe,
        // execution continues to here before the RefCountOperator has a chance to
        // supply the RefCountSubscriber with the shared connection Subscription.
        // For example:
        // ```
        // Observable.range(0, 10)
        //   .publish()
        //   .refCount()
        //   .take(5)
        //   .subscribe();
        // ```
        // In order to account for this case, RefCountSubscriber should only dispose
        // the ConnectableObservable's shared connection Subscription if the
        // connection Subscription exists, *and* either:
        //   a. RefCountSubscriber doesn't have a reference to the shared connection
        //      Subscription yet, or,
        //   b. RefCountSubscriber's connection Subscription reference is identical
        //      to the shared connection Subscription
        ///


        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;

        if (sharedConnection && (!connection || sharedConnection === connection)) {
          sharedConnection.unsubscribe();
        }
      };

      return RefCountSubscriber;
    }(Subscriber_1.Subscriber); 

  });
  unwrapExports(refCount_1);
  var refCount_2 = refCount_1.refCount;

  var ConnectableObservable_1 = createCommonjsModule(function (module, exports) {

    var __extends = commonjsGlobal && commonjsGlobal.__extends || function () {
      var extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (b.hasOwnProperty(p)) d[p] = b[p];
        }
      };

      return function (d, b) {
        extendStatics(d, b);

        function __() {
          this.constructor = d;
        }

        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /**
     * @class ConnectableObservable<T>
     */

    var ConnectableObservable =
    /** @class */
    function (_super) {
      __extends(ConnectableObservable, _super);

      function ConnectableObservable(source, subjectFactory) {
        var _this = _super.call(this) || this;

        _this.source = source;
        _this.subjectFactory = subjectFactory;
        _this._refCount = 0;
        /** @internal */

        _this._isComplete = false;
        return _this;
      }

      ConnectableObservable.prototype._subscribe = function (subscriber) {
        return this.getSubject().subscribe(subscriber);
      };

      ConnectableObservable.prototype.getSubject = function () {
        var subject = this._subject;

        if (!subject || subject.isStopped) {
          this._subject = this.subjectFactory();
        }

        return this._subject;
      };

      ConnectableObservable.prototype.connect = function () {
        var connection = this._connection;

        if (!connection) {
          this._isComplete = false;
          connection = this._connection = new Subscription_1.Subscription();
          connection.add(this.source.subscribe(new ConnectableSubscriber(this.getSubject(), this)));

          if (connection.closed) {
            this._connection = null;
            connection = Subscription_1.Subscription.EMPTY;
          } else {
            this._connection = connection;
          }
        }

        return connection;
      };

      ConnectableObservable.prototype.refCount = function () {
        return refCount_1.refCount()(this);
      };

      return ConnectableObservable;
    }(Observable_1.Observable);

    exports.ConnectableObservable = ConnectableObservable;
    var connectableProto = ConnectableObservable.prototype;
    exports.connectableObservableDescriptor = {
      operator: {
        value: null
      },
      _refCount: {
        value: 0,
        writable: true
      },
      _subject: {
        value: null,
        writable: true
      },
      _connection: {
        value: null,
        writable: true
      },
      _subscribe: {
        value: connectableProto._subscribe
      },
      _isComplete: {
        value: connectableProto._isComplete,
        writable: true
      },
      getSubject: {
        value: connectableProto.getSubject
      },
      connect: {
        value: connectableProto.connect
      },
      refCount: {
        value: connectableProto.refCount
      }
    };

    var ConnectableSubscriber =
    /** @class */
    function (_super) {
      __extends(ConnectableSubscriber, _super);

      function ConnectableSubscriber(destination, connectable) {
        var _this = _super.call(this, destination) || this;

        _this.connectable = connectable;
        return _this;
      }

      ConnectableSubscriber.prototype._error = function (err) {
        this._unsubscribe();

        _super.prototype._error.call(this, err);
      };

      ConnectableSubscriber.prototype._complete = function () {
        this.connectable._isComplete = true;

        this._unsubscribe();

        _super.prototype._complete.call(this);
      };

      ConnectableSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;

        if (connectable) {
          this.connectable = null;
          var connection = connectable._connection;
          connectable._refCount = 0;
          connectable._subject = null;
          connectable._connection = null;

          if (connection) {
            connection.unsubscribe();
          }
        }
      };

      return ConnectableSubscriber;
    }(Subject_1.SubjectSubscriber);

    var RefCountSubscriber =
    /** @class */
    function (_super) {
      __extends(RefCountSubscriber, _super);

      function RefCountSubscriber(destination, connectable) {
        var _this = _super.call(this, destination) || this;

        _this.connectable = connectable;
        return _this;
      }

      RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;

        if (!connectable) {
          this.connection = null;
          return;
        }

        this.connectable = null;
        var refCount = connectable._refCount;

        if (refCount <= 0) {
          this.connection = null;
          return;
        }

        connectable._refCount = refCount - 1;

        if (refCount > 1) {
          this.connection = null;
          return;
        } ///
        // Compare the local RefCountSubscriber's connection Subscription to the
        // connection Subscription on the shared ConnectableObservable. In cases
        // where the ConnectableObservable source synchronously emits values, and
        // the RefCountSubscriber's downstream Observers synchronously unsubscribe,
        // execution continues to here before the RefCountOperator has a chance to
        // supply the RefCountSubscriber with the shared connection Subscription.
        // For example:
        // ```
        // Observable.range(0, 10)
        //   .publish()
        //   .refCount()
        //   .take(5)
        //   .subscribe();
        // ```
        // In order to account for this case, RefCountSubscriber should only dispose
        // the ConnectableObservable's shared connection Subscription if the
        // connection Subscription exists, *and* either:
        //   a. RefCountSubscriber doesn't have a reference to the shared connection
        //      Subscription yet, or,
        //   b. RefCountSubscriber's connection Subscription reference is identical
        //      to the shared connection Subscription
        ///


        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;

        if (sharedConnection && (!connection || sharedConnection === connection)) {
          sharedConnection.unsubscribe();
        }
      };

      return RefCountSubscriber;
    }(Subscriber_1.Subscriber); 

  });
  unwrapExports(ConnectableObservable_1);
  var ConnectableObservable_2 = ConnectableObservable_1.ConnectableObservable;
  var ConnectableObservable_3 = ConnectableObservable_1.connectableObservableDescriptor;

  var BehaviorSubject_1 = createCommonjsModule(function (module, exports) {

    var __extends = commonjsGlobal && commonjsGlobal.__extends || function () {
      var extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (b.hasOwnProperty(p)) d[p] = b[p];
        }
      };

      return function (d, b) {
        extendStatics(d, b);

        function __() {
          this.constructor = d;
        }

        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /**
     * @class BehaviorSubject<T>
     */

    var BehaviorSubject =
    /** @class */
    function (_super) {
      __extends(BehaviorSubject, _super);

      function BehaviorSubject(_value) {
        var _this = _super.call(this) || this;

        _this._value = _value;
        return _this;
      }

      Object.defineProperty(BehaviorSubject.prototype, "value", {
        get: function get() {
          return this.getValue();
        },
        enumerable: true,
        configurable: true
      });

      BehaviorSubject.prototype._subscribe = function (subscriber) {
        var subscription = _super.prototype._subscribe.call(this, subscriber);

        if (subscription && !subscription.closed) {
          subscriber.next(this._value);
        }

        return subscription;
      };

      BehaviorSubject.prototype.getValue = function () {
        if (this.hasError) {
          throw this.thrownError;
        } else if (this.closed) {
          throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        } else {
          return this._value;
        }
      };

      BehaviorSubject.prototype.next = function (value) {
        _super.prototype.next.call(this, this._value = value);
      };

      return BehaviorSubject;
    }(Subject_1.Subject);

    exports.BehaviorSubject = BehaviorSubject; 
  });
  unwrapExports(BehaviorSubject_1);
  var BehaviorSubject_2 = BehaviorSubject_1.BehaviorSubject;

  var Action_1 = createCommonjsModule(function (module, exports) {

    var __extends = commonjsGlobal && commonjsGlobal.__extends || function () {
      var extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (b.hasOwnProperty(p)) d[p] = b[p];
        }
      };

      return function (d, b) {
        extendStatics(d, b);

        function __() {
          this.constructor = d;
        }

        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /**
     * A unit of work to be executed in a {@link Scheduler}. An action is typically
     * created from within a Scheduler and an RxJS user does not need to concern
     * themselves about creating and manipulating an Action.
     *
     * ```ts
     * class Action<T> extends Subscription {
     *   new (scheduler: Scheduler, work: (state?: T) => void);
     *   schedule(state?: T, delay: number = 0): Subscription;
     * }
     * ```
     *
     * @class Action<T>
     */

    var Action =
    /** @class */
    function (_super) {
      __extends(Action, _super);

      function Action(scheduler, work) {
        return _super.call(this) || this;
      }
      /**
       * Schedules this action on its parent Scheduler for execution. May be passed
       * some context object, `state`. May happen at some point in the future,
       * according to the `delay` parameter, if specified.
       * @param {T} [state] Some contextual data that the `work` function uses when
       * called by the Scheduler.
       * @param {number} [delay] Time to wait before executing the work, where the
       * time unit is implicit and defined by the Scheduler.
       * @return {void}
       */


      Action.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
          delay = 0;
        }

        return this;
      };

      return Action;
    }(Subscription_1.Subscription);

    exports.Action = Action; 
  });
  unwrapExports(Action_1);
  var Action_2 = Action_1.Action;

  var AsyncAction_1 = createCommonjsModule(function (module, exports) {

    var __extends = commonjsGlobal && commonjsGlobal.__extends || function () {
      var extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (b.hasOwnProperty(p)) d[p] = b[p];
        }
      };

      return function (d, b) {
        extendStatics(d, b);

        function __() {
          this.constructor = d;
        }

        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */

    var AsyncAction =
    /** @class */
    function (_super) {
      __extends(AsyncAction, _super);

      function AsyncAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;

        _this.scheduler = scheduler;
        _this.work = work;
        _this.pending = false;
        return _this;
      }

      AsyncAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
          delay = 0;
        }

        if (this.closed) {
          return this;
        } // Always replace the current state with the new state.


        this.state = state;
        var id = this.id;
        var scheduler = this.scheduler; //
        // Important implementation note:
        //
        // Actions only execute once by default, unless rescheduled from within the
        // scheduled callback. This allows us to implement single and repeat
        // actions via the same code path, without adding API surface area, as well
        // as mimic traditional recursion but across asynchronous boundaries.
        //
        // However, JS runtimes and timers distinguish between intervals achieved by
        // serial `setTimeout` calls vs. a single `setInterval` call. An interval of
        // serial `setTimeout` calls can be individually delayed, which delays
        // scheduling the next `setTimeout`, and so on. `setInterval` attempts to
        // guarantee the interval callback will be invoked more precisely to the
        // interval period, regardless of load.
        //
        // Therefore, we use `setInterval` to schedule single and repeat actions.
        // If the action reschedules itself with the same delay, the interval is not
        // canceled. If the action doesn't reschedule, or reschedules with a
        // different delay, the interval will be canceled after scheduled callback
        // execution.
        //

        if (id != null) {
          this.id = this.recycleAsyncId(scheduler, id, delay);
        } // Set the pending flag indicating that this action has been scheduled, or
        // has recursively rescheduled itself.


        this.pending = true;
        this.delay = delay; // If this action has already an async Id, don't request a new one.

        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
        return this;
      };

      AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
          delay = 0;
        }

        return setInterval(scheduler.flush.bind(scheduler, this), delay);
      };

      AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
          delay = 0;
        } // If this action is rescheduled with the same delay time, don't clear the interval id.


        if (delay !== null && this.delay === delay && this.pending === false) {
          return id;
        } // Otherwise, if the action's delay time is different from the current delay,
        // or the action has been rescheduled before it's executed, clear the interval id


        return clearInterval(id) && undefined || undefined;
      };
      /**
       * Immediately executes this action and the `work` it contains.
       * @return {any}
       */


      AsyncAction.prototype.execute = function (state, delay) {
        if (this.closed) {
          return new Error('executing a cancelled action');
        }

        this.pending = false;

        var error = this._execute(state, delay);

        if (error) {
          return error;
        } else if (this.pending === false && this.id != null) {
          // Dequeue if the action didn't reschedule itself. Don't call
          // unsubscribe(), because the action could reschedule later.
          // For example:
          // ```
          // scheduler.schedule(function doWork(counter) {
          //   /* ... I'm a busy worker bee ... */
          //   var originalAction = this;
          //   /* wait 100ms before rescheduling the action */
          //   setTimeout(function () {
          //     originalAction.schedule(counter + 1);
          //   }, 100);
          // }, 1000);
          // ```
          this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
      };

      AsyncAction.prototype._execute = function (state, delay) {
        var errored = false;
        var errorValue = undefined;

        try {
          this.work(state);
        } catch (e) {
          errored = true;
          errorValue = !!e && e || new Error(e);
        }

        if (errored) {
          this.unsubscribe();
          return errorValue;
        }
      };

      AsyncAction.prototype._unsubscribe = function () {
        var id = this.id;
        var scheduler = this.scheduler;
        var actions = scheduler.actions;
        var index = actions.indexOf(this);
        this.work = null;
        this.state = null;
        this.pending = false;
        this.scheduler = null;

        if (index !== -1) {
          actions.splice(index, 1);
        }

        if (id != null) {
          this.id = this.recycleAsyncId(scheduler, id, null);
        }

        this.delay = null;
      };

      return AsyncAction;
    }(Action_1.Action);

    exports.AsyncAction = AsyncAction; 
  });
  unwrapExports(AsyncAction_1);
  var AsyncAction_2 = AsyncAction_1.AsyncAction;

  var QueueAction_1 = createCommonjsModule(function (module, exports) {

    var __extends = commonjsGlobal && commonjsGlobal.__extends || function () {
      var extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (b.hasOwnProperty(p)) d[p] = b[p];
        }
      };

      return function (d, b) {
        extendStatics(d, b);

        function __() {
          this.constructor = d;
        }

        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */

    var QueueAction =
    /** @class */
    function (_super) {
      __extends(QueueAction, _super);

      function QueueAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;

        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
      }

      QueueAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
          delay = 0;
        }

        if (delay > 0) {
          return _super.prototype.schedule.call(this, state, delay);
        }

        this.delay = delay;
        this.state = state;
        this.scheduler.flush(this);
        return this;
      };

      QueueAction.prototype.execute = function (state, delay) {
        return delay > 0 || this.closed ? _super.prototype.execute.call(this, state, delay) : this._execute(state, delay);
      };

      QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
          delay = 0;
        } // If delay exists and is greater than 0, or if the delay is null (the
        // action wasn't rescheduled) but was originally scheduled as an async
        // action, then recycle as an async action.


        if (delay !== null && delay > 0 || delay === null && this.delay > 0) {
          return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        } // Otherwise flush the scheduler starting with this action.


        return scheduler.flush(this);
      };

      return QueueAction;
    }(AsyncAction_1.AsyncAction);

    exports.QueueAction = QueueAction; 
  });
  unwrapExports(QueueAction_1);
  var QueueAction_2 = QueueAction_1.QueueAction;

  var Scheduler_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /**
     * An execution context and a data structure to order tasks and schedule their
     * execution. Provides a notion of (potentially virtual) time, through the
     * `now()` getter method.
     *
     * Each unit of work in a Scheduler is called an {@link Action}.
     *
     * ```ts
     * class Scheduler {
     *   now(): number;
     *   schedule(work, delay?, state?): Subscription;
     * }
     * ```
     *
     * @class Scheduler
     */

    var Scheduler =
    /** @class */
    function () {
      function Scheduler(SchedulerAction, now) {
        if (now === void 0) {
          now = Scheduler.now;
        }

        this.SchedulerAction = SchedulerAction;
        this.now = now;
      }
      /**
       * Schedules a function, `work`, for execution. May happen at some point in
       * the future, according to the `delay` parameter, if specified. May be passed
       * some context object, `state`, which will be passed to the `work` function.
       *
       * The given arguments will be processed an stored as an Action object in a
       * queue of actions.
       *
       * @param {function(state: ?T): ?Subscription} work A function representing a
       * task, or some unit of work to be executed by the Scheduler.
       * @param {number} [delay] Time to wait before executing the work, where the
       * time unit is implicit and defined by the Scheduler itself.
       * @param {T} [state] Some contextual data that the `work` function uses when
       * called by the Scheduler.
       * @return {Subscription} A subscription in order to be able to unsubscribe
       * the scheduled work.
       */


      Scheduler.prototype.schedule = function (work, delay, state) {
        if (delay === void 0) {
          delay = 0;
        }

        return new this.SchedulerAction(this, work).schedule(state, delay);
      };

      Scheduler.now = Date.now ? Date.now : function () {
        return +new Date();
      };
      return Scheduler;
    }();

    exports.Scheduler = Scheduler; 
  });
  unwrapExports(Scheduler_1);
  var Scheduler_2 = Scheduler_1.Scheduler;

  var AsyncScheduler_1 = createCommonjsModule(function (module, exports) {

    var __extends = commonjsGlobal && commonjsGlobal.__extends || function () {
      var extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (b.hasOwnProperty(p)) d[p] = b[p];
        }
      };

      return function (d, b) {
        extendStatics(d, b);

        function __() {
          this.constructor = d;
        }

        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var AsyncScheduler =
    /** @class */
    function (_super) {
      __extends(AsyncScheduler, _super);

      function AsyncScheduler() {
        var _this = _super !== null && _super.apply(this, arguments) || this;

        _this.actions = [];
        /**
         * A flag to indicate whether the Scheduler is currently executing a batch of
         * queued actions.
         * @type {boolean}
         */

        _this.active = false;
        /**
         * An internal ID used to track the latest asynchronous task such as those
         * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and
         * others.
         * @type {any}
         */

        _this.scheduled = undefined;
        return _this;
      }

      AsyncScheduler.prototype.flush = function (action) {
        var actions = this.actions;

        if (this.active) {
          actions.push(action);
          return;
        }

        var error;
        this.active = true;

        do {
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        } while (action = actions.shift()); // exhaust the scheduler queue


        this.active = false;

        if (error) {
          while (action = actions.shift()) {
            action.unsubscribe();
          }

          throw error;
        }
      };

      return AsyncScheduler;
    }(Scheduler_1.Scheduler);

    exports.AsyncScheduler = AsyncScheduler; 
  });
  unwrapExports(AsyncScheduler_1);
  var AsyncScheduler_2 = AsyncScheduler_1.AsyncScheduler;

  var QueueScheduler_1 = createCommonjsModule(function (module, exports) {

    var __extends = commonjsGlobal && commonjsGlobal.__extends || function () {
      var extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (b.hasOwnProperty(p)) d[p] = b[p];
        }
      };

      return function (d, b) {
        extendStatics(d, b);

        function __() {
          this.constructor = d;
        }

        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var QueueScheduler =
    /** @class */
    function (_super) {
      __extends(QueueScheduler, _super);

      function QueueScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
      }

      return QueueScheduler;
    }(AsyncScheduler_1.AsyncScheduler);

    exports.QueueScheduler = QueueScheduler; 
  });
  unwrapExports(QueueScheduler_1);
  var QueueScheduler_2 = QueueScheduler_1.QueueScheduler;

  var queue$2 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /**
     *
     * Queue Scheduler
     *
     * <span class="informal">Put every next task on a queue, instead of executing it immediately</span>
     *
     * `queue` scheduler, when used with delay, behaves the same as {@link async} scheduler.
     *
     * When used without delay, it schedules given task synchronously - executes it right when
     * it is scheduled. However when called recursively, that is when inside the scheduled task,
     * another task is scheduled with queue scheduler, instead of executing immediately as well,
     * that task will be put on a queue and wait for current one to finish.
     *
     * This means that when you execute task with `queue` scheduler, you are sure it will end
     * before any other task scheduled with that scheduler will start.
     *
     * @examples <caption>Schedule recursively first, then do something</caption>
     *
     * Rx.Scheduler.queue.schedule(() => {
     *   Rx.Scheduler.queue.schedule(() => console.log('second')); // will not happen now, but will be put on a queue
     *
     *   console.log('first');
     * });
     *
     * // Logs:
     * // "first"
     * // "second"
     *
     *
     * @example <caption>Reschedule itself recursively</caption>
     *
     * Rx.Scheduler.queue.schedule(function(state) {
     *   if (state !== 0) {
     *     console.log('before', state);
     *     this.schedule(state - 1); // `this` references currently executing Action,
     *                               // which we reschedule with new state
     *     console.log('after', state);
     *   }
     * }, 0, 3);
     *
     * // In scheduler that runs recursively, you would expect:
     * // "before", 3
     * // "before", 2
     * // "before", 1
     * // "after", 1
     * // "after", 2
     * // "after", 3
     *
     * // But with queue it logs:
     * // "before", 3
     * // "after", 3
     * // "before", 2
     * // "after", 2
     * // "before", 1
     * // "after", 1
     *
     *
     * @static true
     * @name queue
     * @owner Scheduler
     */

    exports.queue = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction); 
  });
  unwrapExports(queue$2);
  var queue_1 = queue$2.queue;

  var empty_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /**
     * The same Observable instance returned by any call to {@link empty} without a
     * {@link Scheduler}. It is preferrable to use this over `empty()`.
     */

    exports.EMPTY = new Observable_1.Observable(function (subscriber) {
      return subscriber.complete();
    });
    /**
     * Creates an Observable that emits no items to the Observer and immediately
     * emits a complete notification.
     *
     * <span class="informal">Just emits 'complete', and nothing else.
     * </span>
     *
     * <img src="./img/empty.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that only
     * emits the complete notification. It can be used for composing with other
     * Observables, such as in a {@link mergeMap}.
     *
     * @example <caption>Emit the number 7, then complete.</caption>
     * var result = Rx.Observable.empty().startWith(7);
     * result.subscribe(x => console.log(x));
     *
     * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>
     * var interval = Rx.Observable.interval(1000);
     * var result = interval.mergeMap(x =>
     *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()
     * );
     * result.subscribe(x => console.log(x));
     *
     * // Results in the following to the console:
     * // x is equal to the count on the interval eg(0,1,2,3,...)
     * // x will occur every 1000ms
     * // if x % 2 is equal to 1 print abc
     * // if x % 2 is not equal to 1 nothing will be output
     *
     * @see {@link create}
     * @see {@link never}
     * @see {@link of}
     * @see {@link throw}
     *
     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
     * the emission of the complete notification.
     * @return {Observable} An "empty" Observable: emits only the complete
     * notification.
     * @static true
     * @name empty
     * @owner Observable
     */

    function empty(scheduler) {
      return scheduler ? emptyScheduled(scheduler) : exports.EMPTY;
    }

    exports.empty = empty;

    function emptyScheduled(scheduler) {
      return new Observable_1.Observable(function (subscriber) {
        return scheduler.schedule(function () {
          return subscriber.complete();
        });
      });
    }

    exports.emptyScheduled = emptyScheduled; 
  });
  unwrapExports(empty_1);
  var empty_2 = empty_1.EMPTY;
  var empty_3 = empty_1.empty;
  var empty_4 = empty_1.emptyScheduled;

  var isScheduler_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    function isScheduler(value) {
      return value && typeof value.schedule === 'function';
    }

    exports.isScheduler = isScheduler; 
  });
  unwrapExports(isScheduler_1);
  var isScheduler_2 = isScheduler_1.isScheduler;

  var subscribeToArray$1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /**
     * Subscribes to an ArrayLike with a subscriber
     * @param array The array or array-like to subscribe to
     * @param subscriber The subscriber to subscribe with.
     */

    exports.subscribeToArray = function (array) {
      return function (subscriber) {
        for (var i = 0, len = array.length; i < len && !subscriber.closed; i++) {
          subscriber.next(array[i]);
        }

        if (!subscriber.closed) {
          subscriber.complete();
        }
      };
    }; 

  });
  unwrapExports(subscribeToArray$1);
  var subscribeToArray_1 = subscribeToArray$1.subscribeToArray;

  var fromArray_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    function fromArray(input, scheduler) {
      if (!scheduler) {
        return new Observable_1.Observable(subscribeToArray$1.subscribeToArray(input));
      } else {
        return new Observable_1.Observable(function (subscriber) {
          var sub = new Subscription_1.Subscription();
          var i = 0;
          sub.add(scheduler.schedule(function () {
            if (i === input.length) {
              subscriber.complete();
              return;
            }

            subscriber.next(input[i++]);

            if (!subscriber.closed) {
              sub.add(this.schedule());
            }
          }));
          return sub;
        });
      }
    }

    exports.fromArray = fromArray; 
  });
  unwrapExports(fromArray_1);
  var fromArray_2 = fromArray_1.fromArray;

  var scalar_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    function scalar(value) {
      var result = new Observable_1.Observable(function (subscriber) {
        subscriber.next(value);
        subscriber.complete();
      });
      result._isScalar = true;
      result.value = value;
      return result;
    }

    exports.scalar = scalar; 
  });
  unwrapExports(scalar_1);
  var scalar_2 = scalar_1.scalar;

  var of_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    function of() {
      var args = [];

      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }

      var scheduler = args[args.length - 1];

      if (isScheduler_1.isScheduler(scheduler)) {
        args.pop();
      } else {
        scheduler = undefined;
      }

      switch (args.length) {
        case 0:
          return empty_1.empty(scheduler);

        case 1:
          return scheduler ? fromArray_1.fromArray(args, scheduler) : scalar_1.scalar(args[0]);

        default:
          return fromArray_1.fromArray(args, scheduler);
      }
    }

    exports.of = of; 
  });
  unwrapExports(of_1);
  var of_2 = of_1.of;

  var throwError_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /**
     * Creates an Observable that emits no items to the Observer and immediately
     * emits an error notification.
     *
     * <span class="informal">Just emits 'error', and nothing else.
     * </span>
     *
     * <img src="./img/throw.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that only
     * emits the error notification. It can be used for composing with other
     * Observables, such as in a {@link mergeMap}.
     *
     * @example <caption>Emit the number 7, then emit an error.</caption>
     * import { throwError, concat, of } from 'rxjs/create';
     *
     * const result = concat(of(7), throwError(new Error('oops!')));
     * result.subscribe(x => console.log(x), e => console.error(e));
     *
     * @example <caption>Map and flatten numbers to the sequence 'a', 'b', 'c', but throw an error for 13</caption>
     * import { throwError, interval, of } from 'rxjs/create';
     * import { mergeMap } from 'rxjs/operators';
     *
     * interval(1000).pipe(
     *   mergeMap(x => x === 13 ?
     *     throwError('Thirteens are bad') :
     *     of('a', 'b', 'c')
     *   )
     * ).subscribe(x => console.log(x), e => console.error(e));
     *
     * @see {@link create}
     * @see {@link empty}
     * @see {@link never}
     * @see {@link of}
     *
     * @param {any} error The particular Error to pass to the error notification.
     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
     * the emission of the error notification.
     * @return {Observable} An error Observable: emits only the error notification
     * using the given error argument.
     * @static true
     * @name throw
     * @owner Observable
     */

    function throwError(error, scheduler) {
      if (!scheduler) {
        return new Observable_1.Observable(function (subscriber) {
          return subscriber.error(error);
        });
      } else {
        return new Observable_1.Observable(function (subscriber) {
          return scheduler.schedule(dispatch, 0, {
            error: error,
            subscriber: subscriber
          });
        });
      }
    }

    exports.throwError = throwError;

    function dispatch(_a) {
      var error = _a.error,
          subscriber = _a.subscriber;
      subscriber.error(error);
    } 

  });
  unwrapExports(throwError_1);
  var throwError_2 = throwError_1.throwError;

  var Notification_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /**
     * Represents a push-based event or value that an {@link Observable} can emit.
     * This class is particularly useful for operators that manage notifications,
     * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and
     * others. Besides wrapping the actual delivered value, it also annotates it
     * with metadata of, for instance, what type of push message it is (`next`,
     * `error`, or `complete`).
     *
     * @see {@link materialize}
     * @see {@link dematerialize}
     * @see {@link observeOn}
     *
     * @class Notification<T>
     */

    var Notification =
    /** @class */
    function () {
      function Notification(kind, value, error) {
        this.kind = kind;
        this.value = value;
        this.error = error;
        this.hasValue = kind === 'N';
      }
      /**
       * Delivers to the given `observer` the value wrapped by this Notification.
       * @param {Observer} observer
       * @return
       */


      Notification.prototype.observe = function (observer) {
        switch (this.kind) {
          case 'N':
            return observer.next && observer.next(this.value);

          case 'E':
            return observer.error && observer.error(this.error);

          case 'C':
            return observer.complete && observer.complete();
        }
      };
      /**
       * Given some {@link Observer} callbacks, deliver the value represented by the
       * current Notification to the correctly corresponding callback.
       * @param {function(value: T): void} next An Observer `next` callback.
       * @param {function(err: any): void} [error] An Observer `error` callback.
       * @param {function(): void} [complete] An Observer `complete` callback.
       * @return {any}
       */


      Notification.prototype.do = function (next, error, complete) {
        var kind = this.kind;

        switch (kind) {
          case 'N':
            return next && next(this.value);

          case 'E':
            return error && error(this.error);

          case 'C':
            return complete && complete();
        }
      };
      /**
       * Takes an Observer or its individual callback functions, and calls `observe`
       * or `do` methods accordingly.
       * @param {Observer|function(value: T): void} nextOrObserver An Observer or
       * the `next` callback.
       * @param {function(err: any): void} [error] An Observer `error` callback.
       * @param {function(): void} [complete] An Observer `complete` callback.
       * @return {any}
       */


      Notification.prototype.accept = function (nextOrObserver, error, complete) {
        if (nextOrObserver && typeof nextOrObserver.next === 'function') {
          return this.observe(nextOrObserver);
        } else {
          return this.do(nextOrObserver, error, complete);
        }
      };
      /**
       * Returns a simple Observable that just delivers the notification represented
       * by this Notification instance.
       * @return {any}
       */


      Notification.prototype.toObservable = function () {
        var kind = this.kind;

        switch (kind) {
          case 'N':
            return of_1.of(this.value);

          case 'E':
            return throwError_1.throwError(this.error);

          case 'C':
            return empty_1.empty();
        }

        throw new Error('unexpected notification kind value');
      };
      /**
       * A shortcut to create a Notification instance of the type `next` from a
       * given value.
       * @param {T} value The `next` value.
       * @return {Notification<T>} The "next" Notification representing the
       * argument.
       */


      Notification.createNext = function (value) {
        if (typeof value !== 'undefined') {
          return new Notification('N', value);
        }

        return Notification.undefinedValueNotification;
      };
      /**
       * A shortcut to create a Notification instance of the type `error` from a
       * given error.
       * @param {any} [err] The `error` error.
       * @return {Notification<T>} The "error" Notification representing the
       * argument.
       */


      Notification.createError = function (err) {
        return new Notification('E', undefined, err);
      };
      /**
       * A shortcut to create a Notification instance of the type `complete`.
       * @return {Notification<any>} The valueless "complete" Notification.
       */


      Notification.createComplete = function () {
        return Notification.completeNotification;
      };

      Notification.completeNotification = new Notification('C');
      Notification.undefinedValueNotification = new Notification('N', undefined);
      return Notification;
    }();

    exports.Notification = Notification; 
  });
  unwrapExports(Notification_1);
  var Notification_2 = Notification_1.Notification;

  var observeOn_1 = createCommonjsModule(function (module, exports) {

    var __extends = commonjsGlobal && commonjsGlobal.__extends || function () {
      var extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (b.hasOwnProperty(p)) d[p] = b[p];
        }
      };

      return function (d, b) {
        extendStatics(d, b);

        function __() {
          this.constructor = d;
        }

        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /**
     *
     * Re-emits all notifications from source Observable with specified scheduler.
     *
     * <span class="informal">Ensure a specific scheduler is used, from outside of an Observable.</span>
     *
     * `observeOn` is an operator that accepts a scheduler as a first parameter, which will be used to reschedule
     * notifications emitted by the source Observable. It might be useful, if you do not have control over
     * internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.
     *
     * Returned Observable emits the same notifications (nexted values, complete and error events) as the source Observable,
     * but rescheduled with provided scheduler. Note that this doesn't mean that source Observables internal
     * scheduler will be replaced in any way. Original scheduler still will be used, but when the source Observable emits
     * notification, it will be immediately scheduled again - this time with scheduler passed to `observeOn`.
     * An anti-pattern would be calling `observeOn` on Observable that emits lots of values synchronously, to split
     * that emissions into asynchronous chunks. For this to happen, scheduler would have to be passed into the source
     * Observable directly (usually into the operator that creates it). `observeOn` simply delays notifications a
     * little bit more, to ensure that they are emitted at expected moments.
     *
     * As a matter of fact, `observeOn` accepts second parameter, which specifies in milliseconds with what delay notifications
     * will be emitted. The main difference between {@link delay} operator and `observeOn` is that `observeOn`
     * will delay all notifications - including error notifications - while `delay` will pass through error
     * from source Observable immediately when it is emitted. In general it is highly recommended to use `delay` operator
     * for any kind of delaying of values in the stream, while using `observeOn` to specify which scheduler should be used
     * for notification emissions in general.
     *
     * @example <caption>Ensure values in subscribe are called just before browser repaint.</caption>
     * const intervals = Rx.Observable.interval(10); // Intervals are scheduled
     *                                               // with async scheduler by default...
     *
     * intervals
     * .observeOn(Rx.Scheduler.animationFrame)       // ...but we will observe on animationFrame
     * .subscribe(val => {                           // scheduler to ensure smooth animation.
     *   someDiv.style.height = val + 'px';
     * });
     *
     * @see {@link delay}
     *
     * @param {SchedulerLike} scheduler Scheduler that will be used to reschedule notifications from source Observable.
     * @param {number} [delay] Number of milliseconds that states with what delay every notification should be rescheduled.
     * @return {Observable<T>} Observable that emits the same notifications as the source Observable,
     * but with provided scheduler.
     *
     * @method observeOn
     * @owner Observable
     */

    function observeOn(scheduler, delay) {
      if (delay === void 0) {
        delay = 0;
      }

      return function observeOnOperatorFunction(source) {
        return source.lift(new ObserveOnOperator(scheduler, delay));
      };
    }

    exports.observeOn = observeOn;

    var ObserveOnOperator =
    /** @class */
    function () {
      function ObserveOnOperator(scheduler, delay) {
        if (delay === void 0) {
          delay = 0;
        }

        this.scheduler = scheduler;
        this.delay = delay;
      }

      ObserveOnOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
      };

      return ObserveOnOperator;
    }();

    exports.ObserveOnOperator = ObserveOnOperator;
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */

    var ObserveOnSubscriber =
    /** @class */
    function (_super) {
      __extends(ObserveOnSubscriber, _super);

      function ObserveOnSubscriber(destination, scheduler, delay) {
        if (delay === void 0) {
          delay = 0;
        }

        var _this = _super.call(this, destination) || this;

        _this.scheduler = scheduler;
        _this.delay = delay;
        return _this;
      }

      ObserveOnSubscriber.dispatch = function (arg) {
        var notification = arg.notification,
            destination = arg.destination;
        notification.observe(destination);
        this.unsubscribe();
      };

      ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {
        this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
      };

      ObserveOnSubscriber.prototype._next = function (value) {
        this.scheduleMessage(Notification_1.Notification.createNext(value));
      };

      ObserveOnSubscriber.prototype._error = function (err) {
        this.scheduleMessage(Notification_1.Notification.createError(err));
      };

      ObserveOnSubscriber.prototype._complete = function () {
        this.scheduleMessage(Notification_1.Notification.createComplete());
      };

      return ObserveOnSubscriber;
    }(Subscriber_1.Subscriber);

    exports.ObserveOnSubscriber = ObserveOnSubscriber;

    var ObserveOnMessage =
    /** @class */
    function () {
      function ObserveOnMessage(notification, destination) {
        this.notification = notification;
        this.destination = destination;
      }

      return ObserveOnMessage;
    }();

    exports.ObserveOnMessage = ObserveOnMessage; 
  });
  unwrapExports(observeOn_1);
  var observeOn_2 = observeOn_1.observeOn;
  var observeOn_3 = observeOn_1.ObserveOnOperator;
  var observeOn_4 = observeOn_1.ObserveOnSubscriber;
  var observeOn_5 = observeOn_1.ObserveOnMessage;

  var ReplaySubject_1 = createCommonjsModule(function (module, exports) {

    var __extends = commonjsGlobal && commonjsGlobal.__extends || function () {
      var extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (b.hasOwnProperty(p)) d[p] = b[p];
        }
      };

      return function (d, b) {
        extendStatics(d, b);

        function __() {
          this.constructor = d;
        }

        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /**
     * @class ReplaySubject<T>
     */

    var ReplaySubject =
    /** @class */
    function (_super) {
      __extends(ReplaySubject, _super);

      function ReplaySubject(bufferSize, windowTime, scheduler) {
        if (bufferSize === void 0) {
          bufferSize = Number.POSITIVE_INFINITY;
        }

        if (windowTime === void 0) {
          windowTime = Number.POSITIVE_INFINITY;
        }

        var _this = _super.call(this) || this;

        _this.scheduler = scheduler;
        _this._events = [];
        _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
        _this._windowTime = windowTime < 1 ? 1 : windowTime;
        return _this;
      }

      ReplaySubject.prototype.next = function (value) {
        var now = this._getNow();

        this._events.push(new ReplayEvent(now, value));

        this._trimBufferThenGetEvents();

        _super.prototype.next.call(this, value);
      };

      ReplaySubject.prototype._subscribe = function (subscriber) {
        var _events = this._trimBufferThenGetEvents();

        var scheduler = this.scheduler;
        var subscription;

        if (this.closed) {
          throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        } else if (this.hasError) {
          subscription = Subscription_1.Subscription.EMPTY;
        } else if (this.isStopped) {
          subscription = Subscription_1.Subscription.EMPTY;
        } else {
          this.observers.push(subscriber);
          subscription = new SubjectSubscription_1.SubjectSubscription(this, subscriber);
        }

        if (scheduler) {
          subscriber.add(subscriber = new observeOn_1.ObserveOnSubscriber(subscriber, scheduler));
        }

        var len = _events.length;

        for (var i = 0; i < len && !subscriber.closed; i++) {
          subscriber.next(_events[i].value);
        }

        if (this.hasError) {
          subscriber.error(this.thrownError);
        } else if (this.isStopped) {
          subscriber.complete();
        }

        return subscription;
      };

      ReplaySubject.prototype._getNow = function () {
        return (this.scheduler || queue$2.queue).now();
      };

      ReplaySubject.prototype._trimBufferThenGetEvents = function () {
        var now = this._getNow();

        var _bufferSize = this._bufferSize;
        var _windowTime = this._windowTime;
        var _events = this._events;
        var eventsCount = _events.length;
        var spliceCount = 0; // Trim events that fall out of the time window.
        // Start at the front of the list. Break early once
        // we encounter an event that falls within the window.

        while (spliceCount < eventsCount) {
          if (now - _events[spliceCount].time < _windowTime) {
            break;
          }

          spliceCount++;
        }

        if (eventsCount > _bufferSize) {
          spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
        }

        if (spliceCount > 0) {
          _events.splice(0, spliceCount);
        }

        return _events;
      };

      return ReplaySubject;
    }(Subject_1.Subject);

    exports.ReplaySubject = ReplaySubject;

    var ReplayEvent =
    /** @class */
    function () {
      function ReplayEvent(time, value) {
        this.time = time;
        this.value = value;
      }

      return ReplayEvent;
    }(); 

  });
  unwrapExports(ReplaySubject_1);
  var ReplaySubject_2 = ReplaySubject_1.ReplaySubject;

  var AsyncSubject_1 = createCommonjsModule(function (module, exports) {

    var __extends = commonjsGlobal && commonjsGlobal.__extends || function () {
      var extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (b.hasOwnProperty(p)) d[p] = b[p];
        }
      };

      return function (d, b) {
        extendStatics(d, b);

        function __() {
          this.constructor = d;
        }

        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /**
     * @class AsyncSubject<T>
     */

    var AsyncSubject =
    /** @class */
    function (_super) {
      __extends(AsyncSubject, _super);

      function AsyncSubject() {
        var _this = _super !== null && _super.apply(this, arguments) || this;

        _this.value = null;
        _this.hasNext = false;
        _this.hasCompleted = false;
        return _this;
      }

      AsyncSubject.prototype._subscribe = function (subscriber) {
        if (this.hasError) {
          subscriber.error(this.thrownError);
          return Subscription_1.Subscription.EMPTY;
        } else if (this.hasCompleted && this.hasNext) {
          subscriber.next(this.value);
          subscriber.complete();
          return Subscription_1.Subscription.EMPTY;
        }

        return _super.prototype._subscribe.call(this, subscriber);
      };

      AsyncSubject.prototype.next = function (value) {
        if (!this.hasCompleted) {
          this.value = value;
          this.hasNext = true;
        }
      };

      AsyncSubject.prototype.error = function (error) {
        if (!this.hasCompleted) {
          _super.prototype.error.call(this, error);
        }
      };

      AsyncSubject.prototype.complete = function () {
        this.hasCompleted = true;

        if (this.hasNext) {
          _super.prototype.next.call(this, this.value);
        }

        _super.prototype.complete.call(this);
      };

      return AsyncSubject;
    }(Subject_1.Subject);

    exports.AsyncSubject = AsyncSubject; 
  });
  unwrapExports(AsyncSubject_1);
  var AsyncSubject_2 = AsyncSubject_1.AsyncSubject;

  var Immediate = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var nextHandle = 0;
    var tasksByHandle = {};

    function runIfPresent(handle) {
      var cb = tasksByHandle[handle];

      if (cb) {
        cb();
      }
    }

    exports.Immediate = {
      setImmediate: function setImmediate(cb) {
        var handle = nextHandle++;
        tasksByHandle[handle] = cb;
        Promise.resolve().then(function () {
          return runIfPresent(handle);
        });
        return handle;
      },
      clearImmediate: function clearImmediate(handle) {
        delete tasksByHandle[handle];
      }
    }; 
  });
  unwrapExports(Immediate);
  var Immediate_1 = Immediate.Immediate;

  var AsapAction_1 = createCommonjsModule(function (module, exports) {

    var __extends = commonjsGlobal && commonjsGlobal.__extends || function () {
      var extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (b.hasOwnProperty(p)) d[p] = b[p];
        }
      };

      return function (d, b) {
        extendStatics(d, b);

        function __() {
          this.constructor = d;
        }

        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */

    var AsapAction =
    /** @class */
    function (_super) {
      __extends(AsapAction, _super);

      function AsapAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;

        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
      }

      AsapAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
          delay = 0;
        } // If delay is greater than 0, request as an async action.


        if (delay !== null && delay > 0) {
          return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        } // Push the action to the end of the scheduler queue.


        scheduler.actions.push(this); // If a microtask has already been scheduled, don't schedule another
        // one. If a microtask hasn't been scheduled yet, schedule one now. Return
        // the current scheduled microtask id.

        return scheduler.scheduled || (scheduler.scheduled = Immediate.Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));
      };

      AsapAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
          delay = 0;
        } // If delay exists and is greater than 0, or if the delay is null (the
        // action wasn't rescheduled) but was originally scheduled as an async
        // action, then recycle as an async action.


        if (delay !== null && delay > 0 || delay === null && this.delay > 0) {
          return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        } // If the scheduler queue is empty, cancel the requested microtask and
        // set the scheduled flag to undefined so the next AsapAction will schedule
        // its own.


        if (scheduler.actions.length === 0) {
          Immediate.Immediate.clearImmediate(id);
          scheduler.scheduled = undefined;
        } // Return undefined so the action knows to request a new async id if it's rescheduled.


        return undefined;
      };

      return AsapAction;
    }(AsyncAction_1.AsyncAction);

    exports.AsapAction = AsapAction; 
  });
  unwrapExports(AsapAction_1);
  var AsapAction_2 = AsapAction_1.AsapAction;

  var AsapScheduler_1 = createCommonjsModule(function (module, exports) {

    var __extends = commonjsGlobal && commonjsGlobal.__extends || function () {
      var extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (b.hasOwnProperty(p)) d[p] = b[p];
        }
      };

      return function (d, b) {
        extendStatics(d, b);

        function __() {
          this.constructor = d;
        }

        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var AsapScheduler =
    /** @class */
    function (_super) {
      __extends(AsapScheduler, _super);

      function AsapScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
      }

      AsapScheduler.prototype.flush = function (action) {
        this.active = true;
        this.scheduled = undefined;
        var actions = this.actions;
        var error;
        var index = -1;
        var count = actions.length;
        action = action || actions.shift();

        do {
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        } while (++index < count && (action = actions.shift()));

        this.active = false;

        if (error) {
          while (++index < count && (action = actions.shift())) {
            action.unsubscribe();
          }

          throw error;
        }
      };

      return AsapScheduler;
    }(AsyncScheduler_1.AsyncScheduler);

    exports.AsapScheduler = AsapScheduler; 
  });
  unwrapExports(AsapScheduler_1);
  var AsapScheduler_2 = AsapScheduler_1.AsapScheduler;

  var asap = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /**
     *
     * Asap Scheduler
     *
     * <span class="informal">Perform task as fast as it can be performed asynchronously</span>
     *
     * `asap` scheduler behaves the same as {@link async} scheduler when you use it to delay task
     * in time. If however you set delay to `0`, `asap` will wait for current synchronously executing
     * code to end and then it will try to execute given task as fast as possible.
     *
     * `asap` scheduler will do its best to minimize time between end of currently executing code
     * and start of scheduled task. This makes it best candidate for performing so called "deferring".
     * Traditionally this was achieved by calling `setTimeout(deferredTask, 0)`, but that technique involves
     * some (although minimal) unwanted delay.
     *
     * Note that using `asap` scheduler does not necessarily mean that your task will be first to process
     * after currently executing code. In particular, if some task was also scheduled with `asap` before,
     * that task will execute first. That being said, if you need to schedule task asynchronously, but
     * as soon as possible, `asap` scheduler is your best bet.
     *
     * @example <caption>Compare async and asap scheduler</caption>
     *
     * Rx.Scheduler.async.schedule(() => console.log('async')); // scheduling 'async' first...
     * Rx.Scheduler.asap.schedule(() => console.log('asap'));
     *
     * // Logs:
     * // "asap"
     * // "async"
     * // ... but 'asap' goes first!
     *
     * @static true
     * @name asap
     * @owner Scheduler
     */

    exports.asap = new AsapScheduler_1.AsapScheduler(AsapAction_1.AsapAction); 
  });
  unwrapExports(asap);
  var asap_1 = asap.asap;

  var async$1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /**
     *
     * Async Scheduler
     *
     * <span class="informal">Schedule task as if you used setTimeout(task, duration)</span>
     *
     * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript
     * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating
     * in intervals.
     *
     * If you just want to "defer" task, that is to perform it right after currently
     * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),
     * better choice will be the {@link asap} scheduler.
     *
     * @example <caption>Use async scheduler to delay task</caption>
     * const task = () => console.log('it works!');
     *
     * Rx.Scheduler.async.schedule(task, 2000);
     *
     * // After 2 seconds logs:
     * // "it works!"
     *
     *
     * @example <caption>Use async scheduler to repeat task in intervals</caption>
     * function task(state) {
     *   console.log(state);
     *   this.schedule(state + 1, 1000); // `this` references currently executing Action,
     *                                   // which we reschedule with new state and delay
     * }
     *
     * Rx.Scheduler.async.schedule(task, 3000, 0);
     *
     * // Logs:
     * // 0 after 3s
     * // 1 after 4s
     * // 2 after 5s
     * // 3 after 6s
     *
     * @static true
     * @name async
     * @owner Scheduler
     */

    exports.async = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction); 
  });
  unwrapExports(async$1);
  var async_1 = async$1.async;

  var AnimationFrameAction_1 = createCommonjsModule(function (module, exports) {

    var __extends = commonjsGlobal && commonjsGlobal.__extends || function () {
      var extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (b.hasOwnProperty(p)) d[p] = b[p];
        }
      };

      return function (d, b) {
        extendStatics(d, b);

        function __() {
          this.constructor = d;
        }

        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */

    var AnimationFrameAction =
    /** @class */
    function (_super) {
      __extends(AnimationFrameAction, _super);

      function AnimationFrameAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;

        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
      }

      AnimationFrameAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
          delay = 0;
        } // If delay is greater than 0, request as an async action.


        if (delay !== null && delay > 0) {
          return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        } // Push the action to the end of the scheduler queue.


        scheduler.actions.push(this); // If an animation frame has already been requested, don't request another
        // one. If an animation frame hasn't been requested yet, request one. Return
        // the current animation frame request id.

        return scheduler.scheduled || (scheduler.scheduled = requestAnimationFrame(function () {
          return scheduler.flush(null);
        }));
      };

      AnimationFrameAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
          delay = 0;
        } // If delay exists and is greater than 0, or if the delay is null (the
        // action wasn't rescheduled) but was originally scheduled as an async
        // action, then recycle as an async action.


        if (delay !== null && delay > 0 || delay === null && this.delay > 0) {
          return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        } // If the scheduler queue is empty, cancel the requested animation frame and
        // set the scheduled flag to undefined so the next AnimationFrameAction will
        // request its own.


        if (scheduler.actions.length === 0) {
          cancelAnimationFrame(id);
          scheduler.scheduled = undefined;
        } // Return undefined so the action knows to request a new async id if it's rescheduled.


        return undefined;
      };

      return AnimationFrameAction;
    }(AsyncAction_1.AsyncAction);

    exports.AnimationFrameAction = AnimationFrameAction; 
  });
  unwrapExports(AnimationFrameAction_1);
  var AnimationFrameAction_2 = AnimationFrameAction_1.AnimationFrameAction;

  var AnimationFrameScheduler_1 = createCommonjsModule(function (module, exports) {

    var __extends = commonjsGlobal && commonjsGlobal.__extends || function () {
      var extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (b.hasOwnProperty(p)) d[p] = b[p];
        }
      };

      return function (d, b) {
        extendStatics(d, b);

        function __() {
          this.constructor = d;
        }

        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var AnimationFrameScheduler =
    /** @class */
    function (_super) {
      __extends(AnimationFrameScheduler, _super);

      function AnimationFrameScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
      }

      AnimationFrameScheduler.prototype.flush = function (action) {
        this.active = true;
        this.scheduled = undefined;
        var actions = this.actions;
        var error;
        var index = -1;
        var count = actions.length;
        action = action || actions.shift();

        do {
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        } while (++index < count && (action = actions.shift()));

        this.active = false;

        if (error) {
          while (++index < count && (action = actions.shift())) {
            action.unsubscribe();
          }

          throw error;
        }
      };

      return AnimationFrameScheduler;
    }(AsyncScheduler_1.AsyncScheduler);

    exports.AnimationFrameScheduler = AnimationFrameScheduler; 
  });
  unwrapExports(AnimationFrameScheduler_1);
  var AnimationFrameScheduler_2 = AnimationFrameScheduler_1.AnimationFrameScheduler;

  var animationFrame = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /**
     *
     * Animation Frame Scheduler
     *
     * <span class="informal">Perform task when `window.requestAnimationFrame` would fire</span>
     *
     * When `animationFrame` scheduler is used with delay, it will fall back to {@link async} scheduler
     * behaviour.
     *
     * Without delay, `animationFrame` scheduler can be used to create smooth browser animations.
     * It makes sure scheduled task will happen just before next browser content repaint,
     * thus performing animations as efficiently as possible.
     *
     * @example <caption>Schedule div height animation</caption>
     * const div = document.querySelector('.some-div');
     *
     * Rx.Scheduler.animationFrame.schedule(function(height) {
     *   div.style.height = height + "px";
     *
     *   this.schedule(height + 1);  // `this` references currently executing Action,
     *                               // which we reschedule with new state
     * }, 0, 0);
     *
     * // You will see .some-div element growing in height
     *
     *
     * @static true
     * @name animationFrame
     * @owner Scheduler
     */

    exports.animationFrame = new AnimationFrameScheduler_1.AnimationFrameScheduler(AnimationFrameAction_1.AnimationFrameAction); 
  });
  unwrapExports(animationFrame);
  var animationFrame_1 = animationFrame.animationFrame;

  var _strictMethod = function (method, arg) {
    return !!method && _fails(function () {
      // eslint-disable-next-line no-useless-call
      arg ? method.call(null, function () { /* empty */ }, 1) : method.call(null);
    });
  };

  var $sort = [].sort;
  var test = [1, 2, 3];

  _export(_export.P + _export.F * (_fails(function () {
    // IE8-
    test.sort(undefined);
  }) || !_fails(function () {
    // V8 bug
    test.sort(null);
    // Old WebKit
  }) || !_strictMethod($sort)), 'Array', {
    // 22.1.3.25 Array.prototype.sort(comparefn)
    sort: function sort(comparefn) {
      return comparefn === undefined
        ? $sort.call(_toObject(this))
        : $sort.call(_toObject(this), _aFunction(comparefn));
    }
  });

  var VirtualTimeScheduler_1 = createCommonjsModule(function (module, exports) {

    var __extends = commonjsGlobal && commonjsGlobal.__extends || function () {
      var extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (b.hasOwnProperty(p)) d[p] = b[p];
        }
      };

      return function (d, b) {
        extendStatics(d, b);

        function __() {
          this.constructor = d;
        }

        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var VirtualTimeScheduler =
    /** @class */
    function (_super) {
      __extends(VirtualTimeScheduler, _super);

      function VirtualTimeScheduler(SchedulerAction, maxFrames) {
        if (SchedulerAction === void 0) {
          SchedulerAction = VirtualAction;
        }

        if (maxFrames === void 0) {
          maxFrames = Number.POSITIVE_INFINITY;
        }

        var _this = _super.call(this, SchedulerAction, function () {
          return _this.frame;
        }) || this;

        _this.maxFrames = maxFrames;
        _this.frame = 0;
        _this.index = -1;
        return _this;
      }
      /**
       * Prompt the Scheduler to execute all of its queued actions, therefore
       * clearing its queue.
       * @return {void}
       */


      VirtualTimeScheduler.prototype.flush = function () {
        var _a = this,
            actions = _a.actions,
            maxFrames = _a.maxFrames;

        var error, action;

        while ((action = actions.shift()) && (this.frame = action.delay) <= maxFrames) {
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        }

        if (error) {
          while (action = actions.shift()) {
            action.unsubscribe();
          }

          throw error;
        }
      };

      VirtualTimeScheduler.frameTimeFactor = 10;
      return VirtualTimeScheduler;
    }(AsyncScheduler_1.AsyncScheduler);

    exports.VirtualTimeScheduler = VirtualTimeScheduler;
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */

    var VirtualAction =
    /** @class */
    function (_super) {
      __extends(VirtualAction, _super);

      function VirtualAction(scheduler, work, index) {
        if (index === void 0) {
          index = scheduler.index += 1;
        }

        var _this = _super.call(this, scheduler, work) || this;

        _this.scheduler = scheduler;
        _this.work = work;
        _this.index = index;
        _this.active = true;
        _this.index = scheduler.index = index;
        return _this;
      }

      VirtualAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
          delay = 0;
        }

        if (!this.id) {
          return _super.prototype.schedule.call(this, state, delay);
        }

        this.active = false; // If an action is rescheduled, we save allocations by mutating its state,
        // pushing it to the end of the scheduler queue, and recycling the action.
        // But since the VirtualTimeScheduler is used for testing, VirtualActions
        // must be immutable so they can be inspected later.

        var action = new VirtualAction(this.scheduler, this.work);
        this.add(action);
        return action.schedule(state, delay);
      };

      VirtualAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
          delay = 0;
        }

        this.delay = scheduler.frame + delay;
        var actions = scheduler.actions;
        actions.push(this);
        actions.sort(VirtualAction.sortActions);
        return true;
      };

      VirtualAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
          delay = 0;
        }

        return undefined;
      };

      VirtualAction.prototype._execute = function (state, delay) {
        if (this.active === true) {
          return _super.prototype._execute.call(this, state, delay);
        }
      };

      VirtualAction.sortActions = function (a, b) {
        if (a.delay === b.delay) {
          if (a.index === b.index) {
            return 0;
          } else if (a.index > b.index) {
            return 1;
          } else {
            return -1;
          }
        } else if (a.delay > b.delay) {
          return 1;
        } else {
          return -1;
        }
      };

      return VirtualAction;
    }(AsyncAction_1.AsyncAction);

    exports.VirtualAction = VirtualAction; 
  });
  unwrapExports(VirtualTimeScheduler_1);
  var VirtualTimeScheduler_2 = VirtualTimeScheduler_1.VirtualTimeScheduler;
  var VirtualTimeScheduler_3 = VirtualTimeScheduler_1.VirtualAction;

  var identity_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    function identity(x) {
      return x;
    }

    exports.identity = identity; 
  });
  unwrapExports(identity_1);
  var identity_2 = identity_1.identity;

  var ArgumentOutOfRangeError_1 = createCommonjsModule(function (module, exports) {

    var __extends = commonjsGlobal && commonjsGlobal.__extends || function () {
      var extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (b.hasOwnProperty(p)) d[p] = b[p];
        }
      };

      return function (d, b) {
        extendStatics(d, b);

        function __() {
          this.constructor = d;
        }

        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /**
     * An error thrown when an element was queried at a certain index of an
     * Observable, but no such index or position exists in that sequence.
     *
     * @see {@link elementAt}
     * @see {@link take}
     * @see {@link takeLast}
     *
     * @class ArgumentOutOfRangeError
     */

    var ArgumentOutOfRangeError =
    /** @class */
    function (_super) {
      __extends(ArgumentOutOfRangeError, _super);

      function ArgumentOutOfRangeError() {
        var _this = _super.call(this, 'argument out of range') || this;

        _this.name = 'ArgumentOutOfRangeError';
        Object.setPrototypeOf(_this, ArgumentOutOfRangeError.prototype);
        return _this;
      }

      return ArgumentOutOfRangeError;
    }(Error);

    exports.ArgumentOutOfRangeError = ArgumentOutOfRangeError; 
  });
  unwrapExports(ArgumentOutOfRangeError_1);
  var ArgumentOutOfRangeError_2 = ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;

  var EmptyError_1 = createCommonjsModule(function (module, exports) {

    var __extends = commonjsGlobal && commonjsGlobal.__extends || function () {
      var extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (b.hasOwnProperty(p)) d[p] = b[p];
        }
      };

      return function (d, b) {
        extendStatics(d, b);

        function __() {
          this.constructor = d;
        }

        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /**
     * An error thrown when an Observable or a sequence was queried but has no
     * elements.
     *
     * @see {@link first}
     * @see {@link last}
     * @see {@link single}
     *
     * @class EmptyError
     */

    var EmptyError =
    /** @class */
    function (_super) {
      __extends(EmptyError, _super);

      function EmptyError() {
        var _this = _super.call(this, 'no elements in sequence') || this;

        _this.name = 'EmptyError';
        Object.setPrototypeOf(_this, EmptyError.prototype);
        return _this;
      }

      return EmptyError;
    }(Error);

    exports.EmptyError = EmptyError; 
  });
  unwrapExports(EmptyError_1);
  var EmptyError_2 = EmptyError_1.EmptyError;

  var TimeoutError_1 = createCommonjsModule(function (module, exports) {

    var __extends = commonjsGlobal && commonjsGlobal.__extends || function () {
      var extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (b.hasOwnProperty(p)) d[p] = b[p];
        }
      };

      return function (d, b) {
        extendStatics(d, b);

        function __() {
          this.constructor = d;
        }

        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /**
     * An error thrown when duetime elapses.
     *
     * @see {@link timeout}
     *
     * @class TimeoutError
     */

    var TimeoutError =
    /** @class */
    function (_super) {
      __extends(TimeoutError, _super);

      function TimeoutError() {
        var _this = _super.call(this, 'Timeout has occurred') || this;

        Object.setPrototypeOf(_this, TimeoutError.prototype);
        return _this;
      }

      return TimeoutError;
    }(Error);

    exports.TimeoutError = TimeoutError; 
  });
  unwrapExports(TimeoutError_1);
  var TimeoutError_2 = TimeoutError_1.TimeoutError;

  var bindCallback_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    }); // tslint:enable:max-line-length

    /**
     * Converts a callback API to a function that returns an Observable.
     *
     * <span class="informal">Give it a function `f` of type `f(x, callback)` and
     * it will return a function `g` that when called as `g(x)` will output an
     * Observable.</span>
     *
     * `bindCallback` is not an operator because its input and output are not
     * Observables. The input is a function `func` with some parameters, the
     * last parameter must be a callback function that `func` calls when it is
     * done.
     *
     * The output of `bindCallback` is a function that takes the same parameters
     * as `func`, except the last one (the callback). When the output function
     * is called with arguments it will return an Observable. If function `func`
     * calls its callback with one argument the Observable will emit that value.
     * If on the other hand the callback is called with multiple values the resulting
     * Observable will emit an array with said values as arguments.
     *
     * It is very important to remember that input function `func` is not called
     * when the output function is, but rather when the Observable returned by the output
     * function is subscribed. This means if `func` makes an AJAX request, that request
     * will be made every time someone subscribes to the resulting Observable, but not before.
     *
     * The last optional parameter - {@link Scheduler} - can be used to control when the call
     * to `func` happens after someone subscribes to Observable, as well as when results
     * passed to callback will be emitted. By default, the subscription to  an Observable calls `func`
     * synchronously, but using `Scheduler.async` as the last parameter will defer the call to `func`,
     * just like wrapping the call in `setTimeout` with a timeout of `0` would. If you use the async Scheduler
     * and call `subscribe` on the output Observable all function calls that are currently executing
     * will end before `func` is invoked.
     *
     * By default results passed to the callback are emitted immediately after `func` invokes the callback.
     * In particular, if the callback is called synchronously the subscription of the resulting Observable
     * will call the `next` function synchronously as well.  If you want to defer that call,
     * you may use `Scheduler.async` just as before.  This means that by using `Scheduler.async` you can
     * ensure that `func` always calls its callback asynchronously, thus avoiding terrifying Zalgo.
     *
     * Note that the Observable created by the output function will always emit a single value
     * and then complete immediately. If `func` calls the callback multiple times, values from subsequent
     * calls will not appear in the stream. If you need to listen for multiple calls,
     *  you probably want to use {@link fromEvent} or {@link fromEventPattern} instead.
     *
     * If `func` depends on some context (`this` property) and is not already bound the context of `func`
     * will be the context that the output function has at call time. In particular, if `func`
     * is called as a method of some objec and if `func` is not already bound, in order to preserve the context
     * it is recommended that the context of the output function is set to that object as well.
     *
     * If the input function calls its callback in the "node style" (i.e. first argument to callback is
     * optional error parameter signaling whether the call failed or not), {@link bindNodeCallback}
     * provides convenient error handling and probably is a better choice.
     * `bindCallback` will treat such functions the same as any other and error parameters
     * (whether passed or not) will always be interpreted as regular callback argument.
     *
     *
     * @example <caption>Convert jQuery's getJSON to an Observable API</caption>
     * // Suppose we have jQuery.getJSON('/my/url', callback)
     * var getJSONAsObservable = bindCallback(jQuery.getJSON);
     * var result = getJSONAsObservable('/my/url');
     * result.subscribe(x => console.log(x), e => console.error(e));
     *
     *
     * @example <caption>Receive an array of arguments passed to a callback</caption>
     * someFunction((a, b, c) => {
     *   console.log(a); // 5
     *   console.log(b); // 'some string'
     *   console.log(c); // {someProperty: 'someValue'}
     * });
     *
     * const boundSomeFunction = bindCallback(someFunction);
     * boundSomeFunction().subscribe(values => {
     *   console.log(values) // [5, 'some string', {someProperty: 'someValue'}]
     * });
     *
     *
     * @example <caption>Compare behaviour with and without async Scheduler</caption>
     * function iCallMyCallbackSynchronously(cb) {
     *   cb();
     * }
     *
     * const boundSyncFn = bindCallback(iCallMyCallbackSynchronously);
     * const boundAsyncFn = bindCallback(iCallMyCallbackSynchronously, null, Rx.Scheduler.async);
     *
     * boundSyncFn().subscribe(() => console.log('I was sync!'));
     * boundAsyncFn().subscribe(() => console.log('I was async!'));
     * console.log('This happened...');
     *
     * // Logs:
     * // I was sync!
     * // This happened...
     * // I was async!
     *
     *
     * @example <caption>Use bindCallback on an object method</caption>
     * const boundMethod = bindCallback(someObject.methodWithCallback);
     * boundMethod.call(someObject) // make sure methodWithCallback has access to someObject
     * .subscribe(subscriber);
     *
     *
     * @see {@link bindNodeCallback}
     * @see {@link from}
     * @see {@link fromPromise}
     *
     * @param {function} func A function with a callback as the last parameter.
     * @param {Scheduler} [scheduler] The scheduler on which to schedule the
     * callbacks.
     * @return {function(...params: *): Observable} A function which returns the
     * Observable that delivers the same values the callback would deliver.
     * @name bindCallback
     */

    function bindCallback(callbackFunc, scheduler) {
      return function () {
        var args = [];

        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }

        var context = this;
        var subject;
        var params = {
          context: context,
          subject: subject,
          callbackFunc: callbackFunc,
          scheduler: scheduler
        };
        return new Observable_1.Observable(function (subscriber) {
          if (!scheduler) {
            if (!subject) {
              subject = new AsyncSubject_1.AsyncSubject();

              var handler = function handler() {
                var innerArgs = [];

                for (var _i = 0; _i < arguments.length; _i++) {
                  innerArgs[_i] = arguments[_i];
                }

                subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
                subject.complete();
              };

              try {
                callbackFunc.apply(context, args.concat([handler]));
              } catch (err) {
                subject.error(err);
              }
            }

            return subject.subscribe(subscriber);
          } else {
            var state = {
              args: args,
              subscriber: subscriber,
              params: params
            };
            return scheduler.schedule(dispatch, 0, state);
          }
        });
      };
    }

    exports.bindCallback = bindCallback;

    function dispatch(state) {
      var _this = this;
      var args = state.args,
          subscriber = state.subscriber,
          params = state.params;
      var callbackFunc = params.callbackFunc,
          context = params.context,
          scheduler = params.scheduler;
      var subject = params.subject;

      if (!subject) {
        subject = params.subject = new AsyncSubject_1.AsyncSubject();

        var handler = function handler() {
          var innerArgs = [];

          for (var _i = 0; _i < arguments.length; _i++) {
            innerArgs[_i] = arguments[_i];
          }

          var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;

          _this.add(scheduler.schedule(dispatchNext, 0, {
            value: value,
            subject: subject
          }));
        };

        try {
          callbackFunc.apply(context, args.concat([handler]));
        } catch (err) {
          subject.error(err);
        }
      }

      this.add(subject.subscribe(subscriber));
    }

    function dispatchNext(state) {
      var value = state.value,
          subject = state.subject;
      subject.next(value);
      subject.complete();
    }

  });
  unwrapExports(bindCallback_1);
  var bindCallback_2 = bindCallback_1.bindCallback;

  var bindNodeCallback_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /* tslint:enable:max-line-length */

    /**
     * Converts a Node.js-style callback API to a function that returns an
     * Observable.
     *
     * <span class="informal">It's just like {@link bindCallback}, but the
     * callback is expected to be of type `callback(error, result)`.</span>
     *
     * `bindNodeCallback` is not an operator because its input and output are not
     * Observables. The input is a function `func` with some parameters, but the
     * last parameter must be a callback function that `func` calls when it is
     * done. The callback function is expected to follow Node.js conventions,
     * where the first argument to the callback is an error object, signaling
     * whether call was successful. If that object is passed to callback, it means
     * something went wrong.
     *
     * The output of `bindNodeCallback` is a function that takes the same
     * parameters as `func`, except the last one (the callback). When the output
     * function is called with arguments, it will return an Observable.
     * If `func` calls its callback with error parameter present, Observable will
     * error with that value as well. If error parameter is not passed, Observable will emit
     * second parameter. If there are more parameters (third and so on),
     * Observable will emit an array with all arguments, except first error argument.
     *
     * Note that `func` will not be called at the same time output function is,
     * but rather whenever resulting Observable is subscribed. By default call to
     * `func` will happen synchronously after subscription, but that can be changed
     * with proper {@link Scheduler} provided as optional third parameter. Scheduler
     * can also control when values from callback will be emitted by Observable.
     * To find out more, check out documentation for {@link bindCallback}, where
     * Scheduler works exactly the same.
     *
     * As in {@link bindCallback}, context (`this` property) of input function will be set to context
     * of returned function, when it is called.
     *
     * After Observable emits value, it will complete immediately. This means
     * even if `func` calls callback again, values from second and consecutive
     * calls will never appear on the stream. If you need to handle functions
     * that call callbacks multiple times, check out {@link fromEvent} or
     * {@link fromEventPattern} instead.
     *
     * Note that `bindNodeCallback` can be used in non-Node.js environments as well.
     * "Node.js-style" callbacks are just a convention, so if you write for
     * browsers or any other environment and API you use implements that callback style,
     * `bindNodeCallback` can be safely used on that API functions as well.
     *
     * Remember that Error object passed to callback does not have to be an instance
     * of JavaScript built-in `Error` object. In fact, it does not even have to an object.
     * Error parameter of callback function is interpreted as "present", when value
     * of that parameter is truthy. It could be, for example, non-zero number, non-empty
     * string or boolean `true`. In all of these cases resulting Observable would error
     * with that value. This means usually regular style callbacks will fail very often when
     * `bindNodeCallback` is used. If your Observable errors much more often then you
     * would expect, check if callback really is called in Node.js-style and, if not,
     * switch to {@link bindCallback} instead.
     *
     * Note that even if error parameter is technically present in callback, but its value
     * is falsy, it still won't appear in array emitted by Observable.
     *
     *
     * @example <caption>Read a file from the filesystem and get the data as an Observable</caption>
     * import * as fs from 'fs';
     * var readFileAsObservable = bindNodeCallback(fs.readFile);
     * var result = readFileAsObservable('./roadNames.txt', 'utf8');
     * result.subscribe(x => console.log(x), e => console.error(e));
     *
     *
     * @example <caption>Use on function calling callback with multiple arguments</caption>
     * someFunction((err, a, b) => {
     *   console.log(err); // null
     *   console.log(a); // 5
     *   console.log(b); // "some string"
     * });
     * var boundSomeFunction = bindNodeCallback(someFunction);
     * boundSomeFunction()
     * .subscribe(value => {
     *   console.log(value); // [5, "some string"]
     * });
     *
     * @example <caption>Use on function calling callback in regular style</caption>
     * someFunction(a => {
     *   console.log(a); // 5
     * });
     * var boundSomeFunction = bindNodeCallback(someFunction);
     * boundSomeFunction()
     * .subscribe(
     *   value => {}             // never gets called
     *   err => console.log(err) // 5
     * );
     *
     *
     * @see {@link bindCallback}
     * @see {@link from}
     * @see {@link fromPromise}
     *
     * @param {function} func Function with a Node.js-style callback as the last parameter.
     * @param {Scheduler} [scheduler] The scheduler on which to schedule the
     * callbacks.
     * @return {function(...params: *): Observable} A function which returns the
     * Observable that delivers the same values the Node.js callback would
     * deliver.
     * @name bindNodeCallback
     */

    function bindNodeCallback(callbackFunc, scheduler) {
      return function () {
        var args = [];

        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }

        var params = {
          subject: undefined,
          args: args,
          callbackFunc: callbackFunc,
          scheduler: scheduler,
          context: this
        };
        return new Observable_1.Observable(function (subscriber) {
          var context = params.context;
          var subject = params.subject;

          if (!scheduler) {
            if (!subject) {
              subject = params.subject = new AsyncSubject_1.AsyncSubject();

              var handler = function handlerFn() {
                var innerArgs = [];

                for (var _i = 0; _i < arguments.length; _i++) {
                  innerArgs[_i] = arguments[_i];
                }

                var err = innerArgs.shift();

                if (err) {
                  subject.error(err);
                  return;
                }

                subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
                subject.complete();
              };

              try {
                callbackFunc.apply(context, args.concat([handler]));
              } catch (err) {
                subject.error(err);
              }
            }

            return subject.subscribe(subscriber);
          } else {
            return scheduler.schedule(dispatch, 0, {
              params: params,
              subscriber: subscriber,
              context: context
            });
          }
        });
      };
    }

    exports.bindNodeCallback = bindNodeCallback;

    function dispatch(state) {
      var _this = this;

      var params = state.params,
          subscriber = state.subscriber,
          context = state.context;
      var callbackFunc = params.callbackFunc,
          args = params.args,
          scheduler = params.scheduler;
      var subject = params.subject;

      if (!subject) {
        subject = params.subject = new AsyncSubject_1.AsyncSubject();

        var handler = function handler() {
          var innerArgs = [];

          for (var _i = 0; _i < arguments.length; _i++) {
            innerArgs[_i] = arguments[_i];
          }

          var err = innerArgs.shift();

          if (err) {
            _this.add(scheduler.schedule(dispatchError, 0, {
              err: err,
              subject: subject
            }));
          } else {
            var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;

            _this.add(scheduler.schedule(dispatchNext, 0, {
              value: value,
              subject: subject
            }));
          }
        };

        try {
          callbackFunc.apply(context, args.concat([handler]));
        } catch (err) {
          this.add(scheduler.schedule(dispatchError, 0, {
            err: err,
            subject: subject
          }));
        }
      }

      this.add(subject.subscribe(subscriber));
    }

    function dispatchNext(arg) {
      var value = arg.value,
          subject = arg.subject;
      subject.next(value);
      subject.complete();
    }

    function dispatchError(arg) {
      var err = arg.err,
          subject = arg.subject;
      subject.error(err);
    } 

  });
  unwrapExports(bindNodeCallback_1);
  var bindNodeCallback_2 = bindNodeCallback_1.bindNodeCallback;

  var OuterSubscriber_1 = createCommonjsModule(function (module, exports) {

    var __extends = commonjsGlobal && commonjsGlobal.__extends || function () {
      var extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (b.hasOwnProperty(p)) d[p] = b[p];
        }
      };

      return function (d, b) {
        extendStatics(d, b);

        function __() {
          this.constructor = d;
        }

        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */

    var OuterSubscriber =
    /** @class */
    function (_super) {
      __extends(OuterSubscriber, _super);

      function OuterSubscriber() {
        return _super !== null && _super.apply(this, arguments) || this;
      }

      OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
      };

      OuterSubscriber.prototype.notifyError = function (error, innerSub) {
        this.destination.error(error);
      };

      OuterSubscriber.prototype.notifyComplete = function (innerSub) {
        this.destination.complete();
      };

      return OuterSubscriber;
    }(Subscriber_1.Subscriber);

    exports.OuterSubscriber = OuterSubscriber; 
  });
  unwrapExports(OuterSubscriber_1);
  var OuterSubscriber_2 = OuterSubscriber_1.OuterSubscriber;

  var InnerSubscriber_1 = createCommonjsModule(function (module, exports) {

    var __extends = commonjsGlobal && commonjsGlobal.__extends || function () {
      var extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (b.hasOwnProperty(p)) d[p] = b[p];
        }
      };

      return function (d, b) {
        extendStatics(d, b);

        function __() {
          this.constructor = d;
        }

        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @internal
     * @ignore
     * @extends {Ignored}
     */

    var InnerSubscriber =
    /** @class */
    function (_super) {
      __extends(InnerSubscriber, _super);

      function InnerSubscriber(parent, outerValue, outerIndex) {
        var _this = _super.call(this) || this;

        _this.parent = parent;
        _this.outerValue = outerValue;
        _this.outerIndex = outerIndex;
        _this.index = 0;
        return _this;
      }

      InnerSubscriber.prototype._next = function (value) {
        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
      };

      InnerSubscriber.prototype._error = function (error) {
        this.parent.notifyError(error, this);
        this.unsubscribe();
      };

      InnerSubscriber.prototype._complete = function () {
        this.parent.notifyComplete(this);
        this.unsubscribe();
      };

      return InnerSubscriber;
    }(Subscriber_1.Subscriber);

    exports.InnerSubscriber = InnerSubscriber; 
  });
  unwrapExports(InnerSubscriber_1);
  var InnerSubscriber_2 = InnerSubscriber_1.InnerSubscriber;

  var subscribeToPromise$1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    exports.subscribeToPromise = function (promise) {
      return function (subscriber) {
        promise.then(function (value) {
          if (!subscriber.closed) {
            subscriber.next(value);
            subscriber.complete();
          }
        }, function (err) {
          return subscriber.error(err);
        }).then(null, function (err) {
          // Escaping the Promise trap: globally throw unhandled errors
          setTimeout(function () {
            throw err;
          });
        });
        return subscriber;
      };
    }; 

  });
  unwrapExports(subscribeToPromise$1);
  var subscribeToPromise_1 = subscribeToPromise$1.subscribeToPromise;

  var iterator$1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    function getSymbolIterator() {
      if (typeof Symbol !== 'function' || !Symbol.iterator) {
        return '@@iterator';
      }

      return Symbol.iterator;
    }

    exports.getSymbolIterator = getSymbolIterator;
    exports.iterator = getSymbolIterator();
    /**
     * @deprecated use {@link iterator} instead
     */

    exports.$$iterator = exports.iterator; 
  });
  unwrapExports(iterator$1);
  var iterator_1 = iterator$1.getSymbolIterator;
  var iterator_2 = iterator$1.iterator;
  var iterator_3 = iterator$1.$$iterator;

  var subscribeToIterable$1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    exports.subscribeToIterable = function (iterable) {
      return function (subscriber) {
        var iterator = iterable[iterator$1.iterator]();

        do {
          var item = iterator.next();

          if (item.done) {
            subscriber.complete();
            break;
          }

          subscriber.next(item.value);

          if (subscriber.closed) {
            break;
          }
        } while (true); // Finalize the iterator if it happens to be a Generator


        if (typeof iterator.return === 'function') {
          subscriber.add(function () {
            if (iterator.return) {
              iterator.return();
            }
          });
        }

        return subscriber;
      };
    }; 

  });
  unwrapExports(subscribeToIterable$1);
  var subscribeToIterable_1 = subscribeToIterable$1.subscribeToIterable;

  var subscribeToObservable$1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /**
     * Subscribes to an object that implements Symbol.observable with the given
     * Subscriber.
     * @param obj An object that implements Symbol.observable
     * @param subscriber The Subscriber to use to subscribe to the observable
     */

    exports.subscribeToObservable = function (obj) {
      return function (subscriber) {
        var obs = obj[observable$1.observable]();

        if (typeof obs.subscribe !== 'function') {
          // Should be caught by observable subscribe function error handling.
          throw new TypeError('Provided object does not correctly implement Symbol.observable');
        } else {
          return obs.subscribe(subscriber);
        }
      };
    }; 

  });
  unwrapExports(subscribeToObservable$1);
  var subscribeToObservable_1 = subscribeToObservable$1.subscribeToObservable;

  var isArrayLike$1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    exports.isArrayLike = function (x) {
      return x && typeof x.length === 'number';
    }; 

  });
  unwrapExports(isArrayLike$1);
  var isArrayLike_1 = isArrayLike$1.isArrayLike;

  var isPromise_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    function isPromise(value) {
      return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
    }

    exports.isPromise = isPromise; 
  });
  unwrapExports(isPromise_1);
  var isPromise_2 = isPromise_1.isPromise;

  var subscribeTo$1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    exports.subscribeTo = function (result) {
      if (result instanceof Observable_1.Observable) {
        return function (subscriber) {
          if (result._isScalar) {
            subscriber.next(result.value);
            subscriber.complete();
            return undefined;
          } else {
            return result.subscribe(subscriber);
          }
        };
      } else if (isArrayLike$1.isArrayLike(result)) {
        return subscribeToArray$1.subscribeToArray(result);
      } else if (isPromise_1.isPromise(result)) {
        return subscribeToPromise$1.subscribeToPromise(result);
      } else if (result && typeof result[iterator$1.iterator] === 'function') {
        return subscribeToIterable$1.subscribeToIterable(result);
      } else if (result && typeof result[observable$1.observable] === 'function') {
        return subscribeToObservable$1.subscribeToObservable(result);
      } else {
        var value = isObject_1.isObject(result) ? 'an invalid object' : "'" + result + "'";
        var msg = "You provided " + value + " where a stream was expected." + ' You can provide an Observable, Promise, Array, or Iterable.';
        throw new TypeError(msg);
      }
    }; 

  });
  unwrapExports(subscribeTo$1);
  var subscribeTo_1 = subscribeTo$1.subscribeTo;

  var subscribeToResult_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    function subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {
      var destination = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex);
      return subscribeTo$1.subscribeTo(result)(destination);
    }

    exports.subscribeToResult = subscribeToResult; 
  });
  unwrapExports(subscribeToResult_1);
  var subscribeToResult_2 = subscribeToResult_1.subscribeToResult;

  var combineLatest_1 = createCommonjsModule(function (module, exports) {

    var __extends = commonjsGlobal && commonjsGlobal.__extends || function () {
      var extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (b.hasOwnProperty(p)) d[p] = b[p];
        }
      };

      return function (d, b) {
        extendStatics(d, b);

        function __() {
          this.constructor = d;
        }

        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var NONE = {};
    /* tslint:enable:max-line-length */

    /**
     * Combines multiple Observables to create an Observable whose values are
     * calculated from the latest values of each of its input Observables.
     *
     * <span class="informal">Whenever any input Observable emits a value, it
     * computes a formula using the latest values from all the inputs, then emits
     * the output of that formula.</span>
     *
     * <img src="./img/combineLatest.png" width="100%">
     *
     * `combineLatest` combines the values from all the Observables passed as
     * arguments. This is done by subscribing to each Observable in order and,
     * whenever any Observable emits, collecting an array of the most recent
     * values from each Observable. So if you pass `n` Observables to operator,
     * returned Observable will always emit an array of `n` values, in order
     * corresponding to order of passed Observables (value from the first Observable
     * on the first place and so on).
     *
     * Static version of `combineLatest` accepts either an array of Observables
     * or each Observable can be put directly as an argument. Note that array of
     * Observables is good choice, if you don't know beforehand how many Observables
     * you will combine. Passing empty array will result in Observable that
     * completes immediately.
     *
     * To ensure output array has always the same length, `combineLatest` will
     * actually wait for all input Observables to emit at least once,
     * before it starts emitting results. This means if some Observable emits
     * values before other Observables started emitting, all that values but last
     * will be lost. On the other hand, is some Observable does not emit value but
     * completes, resulting Observable will complete at the same moment without
     * emitting anything, since it will be now impossible to include value from
     * completed Observable in resulting array. Also, if some input Observable does
     * not emit any value and never completes, `combineLatest` will also never emit
     * and never complete, since, again, it will wait for all streams to emit some
     * value.
     *
     * If at least one Observable was passed to `combineLatest` and all passed Observables
     * emitted something, resulting Observable will complete when all combined
     * streams complete. So even if some Observable completes, result of
     * `combineLatest` will still emit values when other Observables do. In case
     * of completed Observable, its value from now on will always be the last
     * emitted value. On the other hand, if any Observable errors, `combineLatest`
     * will error immediately as well, and all other Observables will be unsubscribed.
     *
     * `combineLatest` accepts as optional parameter `project` function, which takes
     * as arguments all values that would normally be emitted by resulting Observable.
     * `project` can return any kind of value, which will be then emitted by Observable
     * instead of default array. Note that `project` does not take as argument that array
     * of values, but values themselves. That means default `project` can be imagined
     * as function that takes all its arguments and puts them into an array.
     *
     *
     * @example <caption>Combine two timer Observables</caption>
     * const firstTimer = Rx.Observable.timer(0, 1000); // emit 0, 1, 2... after every second, starting from now
     * const secondTimer = Rx.Observable.timer(500, 1000); // emit 0, 1, 2... after every second, starting 0,5s from now
     * const combinedTimers = Rx.Observable.combineLatest(firstTimer, secondTimer);
     * combinedTimers.subscribe(value => console.log(value));
     * // Logs
     * // [0, 0] after 0.5s
     * // [1, 0] after 1s
     * // [1, 1] after 1.5s
     * // [2, 1] after 2s
     *
     *
     * @example <caption>Combine an array of Observables</caption>
     * const observables = [1, 5, 10].map(
     *   n => Rx.Observable.of(n).delay(n * 1000).startWith(0) // emit 0 and then emit n after n seconds
     * );
     * const combined = Rx.Observable.combineLatest(observables);
     * combined.subscribe(value => console.log(value));
     * // Logs
     * // [0, 0, 0] immediately
     * // [1, 0, 0] after 1s
     * // [1, 5, 0] after 5s
     * // [1, 5, 10] after 10s
     *
     *
     * @example <caption>Use project function to dynamically calculate the Body-Mass Index</caption>
     * var weight = Rx.Observable.of(70, 72, 76, 79, 75);
     * var height = Rx.Observable.of(1.76, 1.77, 1.78);
     * var bmi = Rx.Observable.combineLatest(weight, height, (w, h) => w / (h * h));
     * bmi.subscribe(x => console.log('BMI is ' + x));
     *
     * // With output to console:
     * // BMI is 24.212293388429753
     * // BMI is 23.93948099205209
     * // BMI is 23.671253629592222
     *
     *
     * @see {@link combineAll}
     * @see {@link merge}
     * @see {@link withLatestFrom}
     *
     * @param {ObservableInput} observable1 An input Observable to combine with other Observables.
     * @param {ObservableInput} observable2 An input Observable to combine with other Observables.
     * More than one input Observables may be given as arguments
     * or an array of Observables may be given as the first argument.
     * @param {function} [project] An optional function to project the values from
     * the combined latest values into a new value on the output Observable.
     * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to
     * each input Observable.
     * @return {Observable} An Observable of projected values from the most recent
     * values from each input Observable, or an array of the most recent values from
     * each input Observable.
     * @static true
     * @name combineLatest
     * @owner Observable
     */

    function combineLatest() {
      var observables = [];

      for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
      }

      var project = null;
      var scheduler = null;

      if (isScheduler_1.isScheduler(observables[observables.length - 1])) {
        scheduler = observables.pop();
      }

      if (typeof observables[observables.length - 1] === 'function') {
        project = observables.pop();
      } // if the first and only other argument besides the resultSelector is an array
      // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`


      if (observables.length === 1 && isArray$1.isArray(observables[0])) {
        observables = observables[0];
      }

      return fromArray_1.fromArray(observables, scheduler).lift(new CombineLatestOperator(project));
    }

    exports.combineLatest = combineLatest;

    var CombineLatestOperator =
    /** @class */
    function () {
      function CombineLatestOperator(project) {
        this.project = project;
      }

      CombineLatestOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CombineLatestSubscriber(subscriber, this.project));
      };

      return CombineLatestOperator;
    }();

    exports.CombineLatestOperator = CombineLatestOperator;
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */

    var CombineLatestSubscriber =
    /** @class */
    function (_super) {
      __extends(CombineLatestSubscriber, _super);

      function CombineLatestSubscriber(destination, project) {
        var _this = _super.call(this, destination) || this;

        _this.project = project;
        _this.active = 0;
        _this.values = [];
        _this.observables = [];
        return _this;
      }

      CombineLatestSubscriber.prototype._next = function (observable) {
        this.values.push(NONE);
        this.observables.push(observable);
      };

      CombineLatestSubscriber.prototype._complete = function () {
        var observables = this.observables;
        var len = observables.length;

        if (len === 0) {
          this.destination.complete();
        } else {
          this.active = len;
          this.toRespond = len;

          for (var i = 0; i < len; i++) {
            var observable = observables[i];
            this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));
          }
        }
      };

      CombineLatestSubscriber.prototype.notifyComplete = function (unused) {
        if ((this.active -= 1) === 0) {
          this.destination.complete();
        }
      };

      CombineLatestSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var values = this.values;
        var oldVal = values[outerIndex];
        var toRespond = !this.toRespond ? 0 : oldVal === NONE ? --this.toRespond : this.toRespond;
        values[outerIndex] = innerValue;

        if (toRespond === 0) {
          if (this.project) {
            this._tryProject(values);
          } else {
            this.destination.next(values.slice());
          }
        }
      };

      CombineLatestSubscriber.prototype._tryProject = function (values) {
        var result;

        try {
          result = this.project.apply(this, values);
        } catch (err) {
          this.destination.error(err);
          return;
        }

        this.destination.next(result);
      };

      return CombineLatestSubscriber;
    }(OuterSubscriber_1.OuterSubscriber);

    exports.CombineLatestSubscriber = CombineLatestSubscriber; 
  });
  unwrapExports(combineLatest_1);
  var combineLatest_2 = combineLatest_1.combineLatest;
  var combineLatest_3 = combineLatest_1.CombineLatestOperator;
  var combineLatest_4 = combineLatest_1.CombineLatestSubscriber;

  var isObservable_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /** Identifies an input as being Observable (but not necessary an Rx Observable) */

    function isObservable(input) {
      return input && typeof input[observable$1.observable] === 'function';
    }

    exports.isObservable = isObservable; 
  });
  unwrapExports(isObservable_1);
  var isObservable_2 = isObservable_1.isObservable;

  var isIterable_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /** Identifies an input as being an Iterable */

    function isIterable(input) {
      return input && typeof input[iterator$1.iterator] === 'function';
    }

    exports.isIterable = isIterable; 
  });
  unwrapExports(isIterable_1);
  var isIterable_2 = isIterable_1.isIterable;

  var fromPromise_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    function fromPromise(input, scheduler) {
      if (!scheduler) {
        return new Observable_1.Observable(subscribeToPromise$1.subscribeToPromise(input));
      } else {
        return new Observable_1.Observable(function (subscriber) {
          var sub = new Subscription_1.Subscription();
          sub.add(scheduler.schedule(function () {
            return input.then(function (value) {
              sub.add(scheduler.schedule(function () {
                subscriber.next(value);
                sub.add(scheduler.schedule(function () {
                  return subscriber.complete();
                }));
              }));
            }, function (err) {
              sub.add(scheduler.schedule(function () {
                return subscriber.error(err);
              }));
            });
          }));
          return sub;
        });
      }
    }

    exports.fromPromise = fromPromise; 
  });
  unwrapExports(fromPromise_1);
  var fromPromise_2 = fromPromise_1.fromPromise;

  var fromIterable_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    function fromIterable(input, scheduler) {
      if (!input) {
        throw new Error('Iterable cannot be null');
      }

      if (!scheduler) {
        return new Observable_1.Observable(subscribeToIterable$1.subscribeToIterable(input));
      } else {
        return new Observable_1.Observable(function (subscriber) {
          var sub = new Subscription_1.Subscription();
          var iterator;
          sub.add(function () {
            // Finalize generators
            if (iterator && typeof iterator.return === 'function') {
              iterator.return();
            }
          });
          sub.add(scheduler.schedule(function () {
            iterator = input[iterator$1.iterator]();
            sub.add(scheduler.schedule(function () {
              if (subscriber.closed) {
                return;
              }

              var value;
              var done;

              try {
                var result = iterator.next();
                value = result.value;
                done = result.done;
              } catch (err) {
                subscriber.error(err);
                return;
              }

              if (done) {
                subscriber.complete();
              } else {
                subscriber.next(value);
                this.schedule();
              }
            }));
          }));
          return sub;
        });
      }
    }

    exports.fromIterable = fromIterable; 
  });
  unwrapExports(fromIterable_1);
  var fromIterable_2 = fromIterable_1.fromIterable;

  var fromObservable_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    function fromObservable(input, scheduler) {
      if (!scheduler) {
        return new Observable_1.Observable(subscribeToObservable$1.subscribeToObservable(input));
      } else {
        return new Observable_1.Observable(function (subscriber) {
          var sub = new Subscription_1.Subscription();
          sub.add(scheduler.schedule(function () {
            var observable = input[observable$1.observable]();
            sub.add(observable.subscribe({
              next: function next(value) {
                sub.add(scheduler.schedule(function () {
                  return subscriber.next(value);
                }));
              },
              error: function error(err) {
                sub.add(scheduler.schedule(function () {
                  return subscriber.error(err);
                }));
              },
              complete: function complete() {
                sub.add(scheduler.schedule(function () {
                  return subscriber.complete();
                }));
              }
            }));
          }));
          return sub;
        });
      }
    }

    exports.fromObservable = fromObservable; 
  });
  unwrapExports(fromObservable_1);
  var fromObservable_2 = fromObservable_1.fromObservable;

  var from_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    function from(input, scheduler) {
      if (!scheduler) {
        if (input instanceof Observable_1.Observable) {
          return input;
        }

        return new Observable_1.Observable(subscribeTo$1.subscribeTo(input));
      }

      if (input != null) {
        if (isObservable_1.isObservable(input)) {
          return fromObservable_1.fromObservable(input, scheduler);
        } else if (isPromise_1.isPromise(input)) {
          return fromPromise_1.fromPromise(input, scheduler);
        } else if (isArrayLike$1.isArrayLike(input)) {
          return fromArray_1.fromArray(input, scheduler);
        } else if (isIterable_1.isIterable(input) || typeof input === 'string') {
          return fromIterable_1.fromIterable(input, scheduler);
        }
      }

      throw new TypeError((input !== null && typeof input || input) + ' is not observable');
    }

    exports.from = from; 
  });
  unwrapExports(from_1);
  var from_2 = from_1.from;

  var mergeMap_1 = createCommonjsModule(function (module, exports) {

    var __extends = commonjsGlobal && commonjsGlobal.__extends || function () {
      var extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (b.hasOwnProperty(p)) d[p] = b[p];
        }
      };

      return function (d, b) {
        extendStatics(d, b);

        function __() {
          this.constructor = d;
        }

        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /* tslint:enable:max-line-length */

    /**
     * Projects each source value to an Observable which is merged in the output
     * Observable.
     *
     * <span class="informal">Maps each value to an Observable, then flattens all of
     * these inner Observables using {@link mergeAll}.</span>
     *
     * <img src="./img/mergeMap.png" width="100%">
     *
     * Returns an Observable that emits items based on applying a function that you
     * supply to each item emitted by the source Observable, where that function
     * returns an Observable, and then merging those resulting Observables and
     * emitting the results of this merger.
     *
     * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>
     * var letters = Rx.Observable.of('a', 'b', 'c');
     * var result = letters.mergeMap(x =>
     *   Rx.Observable.interval(1000).map(i => x+i)
     * );
     * result.subscribe(x => console.log(x));
     *
     * // Results in the following:
     * // a0
     * // b0
     * // c0
     * // a1
     * // b1
     * // c1
     * // continues to list a,b,c with respective ascending integers
     *
     * @see {@link concatMap}
     * @see {@link exhaustMap}
     * @see {@link merge}
     * @see {@link mergeAll}
     * @see {@link mergeMapTo}
     * @see {@link mergeScan}
     * @see {@link switchMap}
     *
     * @param {function(value: T, ?index: number): ObservableInput} project A function
     * that, when applied to an item emitted by the source Observable, returns an
     * Observable.
     * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
     * Observables being subscribed to concurrently.
     * @return {Observable} An Observable that emits the result of applying the
     * projection function (and the optional `resultSelector`) to each item emitted
     * by the source Observable and merging the results of the Observables obtained
     * from this transformation.
     * @method mergeMap
     * @owner Observable
     */

    function mergeMap(project, concurrent) {
      if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
      }

      return function mergeMapOperatorFunction(source) {
        return source.lift(new MergeMapOperator(project, concurrent));
      };
    }

    exports.mergeMap = mergeMap;

    var MergeMapOperator =
    /** @class */
    function () {
      function MergeMapOperator(project, concurrent) {
        if (concurrent === void 0) {
          concurrent = Number.POSITIVE_INFINITY;
        }

        this.project = project;
        this.concurrent = concurrent;
      }

      MergeMapOperator.prototype.call = function (observer, source) {
        return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
      };

      return MergeMapOperator;
    }();

    exports.MergeMapOperator = MergeMapOperator;
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */

    var MergeMapSubscriber =
    /** @class */
    function (_super) {
      __extends(MergeMapSubscriber, _super);

      function MergeMapSubscriber(destination, project, concurrent) {
        if (concurrent === void 0) {
          concurrent = Number.POSITIVE_INFINITY;
        }

        var _this = _super.call(this, destination) || this;

        _this.project = project;
        _this.concurrent = concurrent;
        _this.hasCompleted = false;
        _this.buffer = [];
        _this.active = 0;
        _this.index = 0;
        return _this;
      }

      MergeMapSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
          this._tryNext(value);
        } else {
          this.buffer.push(value);
        }
      };

      MergeMapSubscriber.prototype._tryNext = function (value) {
        var result;
        var index = this.index++;

        try {
          result = this.project(value, index);
        } catch (err) {
          this.destination.error(err);
          return;
        }

        this.active++;

        this._innerSub(result, value, index);
      };

      MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {
        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));
      };

      MergeMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;

        if (this.active === 0 && this.buffer.length === 0) {
          this.destination.complete();
        }
      };

      MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
      };

      MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;

        if (buffer.length > 0) {
          this._next(buffer.shift());
        } else if (this.active === 0 && this.hasCompleted) {
          this.destination.complete();
        }
      };

      return MergeMapSubscriber;
    }(OuterSubscriber_1.OuterSubscriber);

    exports.MergeMapSubscriber = MergeMapSubscriber; 
  });
  unwrapExports(mergeMap_1);
  var mergeMap_2 = mergeMap_1.mergeMap;
  var mergeMap_3 = mergeMap_1.MergeMapOperator;
  var mergeMap_4 = mergeMap_1.MergeMapSubscriber;

  var mergeAll_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /**
     * Converts a higher-order Observable into a first-order Observable which
     * concurrently delivers all values that are emitted on the inner Observables.
     *
     * <span class="informal">Flattens an Observable-of-Observables.</span>
     *
     * <img src="./img/mergeAll.png" width="100%">
     *
     * `mergeAll` subscribes to an Observable that emits Observables, also known as
     * a higher-order Observable. Each time it observes one of these emitted inner
     * Observables, it subscribes to that and delivers all the values from the
     * inner Observable on the output Observable. The output Observable only
     * completes once all inner Observables have completed. Any error delivered by
     * a inner Observable will be immediately emitted on the output Observable.
     *
     * @example <caption>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));
     * var firstOrder = higherOrder.mergeAll();
     * firstOrder.subscribe(x => console.log(x));
     *
     * @example <caption>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));
     * var firstOrder = higherOrder.mergeAll(2);
     * firstOrder.subscribe(x => console.log(x));
     *
     * @see {@link combineAll}
     * @see {@link concatAll}
     * @see {@link exhaust}
     * @see {@link merge}
     * @see {@link mergeMap}
     * @see {@link mergeMapTo}
     * @see {@link mergeScan}
     * @see {@link switch}
     * @see {@link zipAll}
     *
     * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner
     * Observables being subscribed to concurrently.
     * @return {Observable} An Observable that emits values coming from all the
     * inner Observables emitted by the source Observable.
     * @method mergeAll
     * @owner Observable
     */

    function mergeAll(concurrent) {
      if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
      }

      return mergeMap_1.mergeMap(identity_1.identity, concurrent);
    }

    exports.mergeAll = mergeAll; 
  });
  unwrapExports(mergeAll_1);
  var mergeAll_2 = mergeAll_1.mergeAll;

  var concatAll_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /**
     * Converts a higher-order Observable into a first-order Observable by
     * concatenating the inner Observables in order.
     *
     * <span class="informal">Flattens an Observable-of-Observables by putting one
     * inner Observable after the other.</span>
     *
     * <img src="./img/concatAll.png" width="100%">
     *
     * Joins every Observable emitted by the source (a higher-order Observable), in
     * a serial fashion. It subscribes to each inner Observable only after the
     * previous inner Observable has completed, and merges all of their values into
     * the returned observable.
     *
     * __Warning:__ If the source Observable emits Observables quickly and
     * endlessly, and the inner Observables it emits generally complete slower than
     * the source emits, you can run into memory issues as the incoming Observables
     * collect in an unbounded buffer.
     *
     * Note: `concatAll` is equivalent to `mergeAll` with concurrency parameter set
     * to `1`.
     *
     * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var higherOrder = clicks.map(ev => Rx.Observable.interval(1000).take(4));
     * var firstOrder = higherOrder.concatAll();
     * firstOrder.subscribe(x => console.log(x));
     *
     * // Results in the following:
     * // (results are not concurrent)
     * // For every click on the "document" it will emit values 0 to 3 spaced
     * // on a 1000ms interval
     * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3
     *
     * @see {@link combineAll}
     * @see {@link concat}
     * @see {@link concatMap}
     * @see {@link concatMapTo}
     * @see {@link exhaust}
     * @see {@link mergeAll}
     * @see {@link switch}
     * @see {@link zipAll}
     *
     * @return {Observable} An Observable emitting values from all the inner
     * Observables concatenated.
     * @method concatAll
     * @owner Observable
     */

    function concatAll() {
      return mergeAll_1.mergeAll(1);
    }

    exports.concatAll = concatAll; 
  });
  unwrapExports(concatAll_1);
  var concatAll_2 = concatAll_1.concatAll;

  var concat_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /* tslint:enable:max-line-length */

    /**
     * Creates an output Observable which sequentially emits all values from given
     * Observable and then moves on to the next.
     *
     * <span class="informal">Concatenates multiple Observables together by
     * sequentially emitting their values, one Observable after the other.</span>
     *
     * <img src="./img/concat.png" width="100%">
     *
     * `concat` joins multiple Observables together, by subscribing to them one at a time and
     * merging their results into the output Observable. You can pass either an array of
     * Observables, or put them directly as arguments. Passing an empty array will result
     * in Observable that completes immediately.
     *
     * `concat` will subscribe to first input Observable and emit all its values, without
     * changing or affecting them in any way. When that Observable completes, it will
     * subscribe to then next Observable passed and, again, emit its values. This will be
     * repeated, until the operator runs out of Observables. When last input Observable completes,
     * `concat` will complete as well. At any given moment only one Observable passed to operator
     * emits values. If you would like to emit values from passed Observables concurrently, check out
     * {@link merge} instead, especially with optional `concurrent` parameter. As a matter of fact,
     * `concat` is an equivalent of `merge` operator with `concurrent` parameter set to `1`.
     *
     * Note that if some input Observable never completes, `concat` will also never complete
     * and Observables following the one that did not complete will never be subscribed. On the other
     * hand, if some Observable simply completes immediately after it is subscribed, it will be
     * invisible for `concat`, which will just move on to the next Observable.
     *
     * If any Observable in chain errors, instead of passing control to the next Observable,
     * `concat` will error immediately as well. Observables that would be subscribed after
     * the one that emitted error, never will.
     *
     * If you pass to `concat` the same Observable many times, its stream of values
     * will be "replayed" on every subscription, which means you can repeat given Observable
     * as many times as you like. If passing the same Observable to `concat` 1000 times becomes tedious,
     * you can always use {@link repeat}.
     *
     * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>
     * var timer = Rx.Observable.interval(1000).take(4);
     * var sequence = Rx.Observable.range(1, 10);
     * var result = Rx.Observable.concat(timer, sequence);
     * result.subscribe(x => console.log(x));
     *
     * // results in:
     * // 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10
     *
     *
     * @example <caption>Concatenate an array of 3 Observables</caption>
     * var timer1 = Rx.Observable.interval(1000).take(10);
     * var timer2 = Rx.Observable.interval(2000).take(6);
     * var timer3 = Rx.Observable.interval(500).take(10);
     * var result = Rx.Observable.concat([timer1, timer2, timer3]); // note that array is passed
     * result.subscribe(x => console.log(x));
     *
     * // results in the following:
     * // (Prints to console sequentially)
     * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9
     * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5
     * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9
     *
     *
     * @example <caption>Concatenate the same Observable to repeat it</caption>
     * const timer = Rx.Observable.interval(1000).take(2);
     *
     * Rx.Observable.concat(timer, timer) // concating the same Observable!
     * .subscribe(
     *   value => console.log(value),
     *   err => {},
     *   () => console.log('...and it is done!')
     * );
     *
     * // Logs:
     * // 0 after 1s
     * // 1 after 2s
     * // 0 after 3s
     * // 1 after 4s
     * // "...and it is done!" also after 4s
     *
     * @see {@link concatAll}
     * @see {@link concatMap}
     * @see {@link concatMapTo}
     *
     * @param {ObservableInput} input1 An input Observable to concatenate with others.
     * @param {ObservableInput} input2 An input Observable to concatenate with others.
     * More than one input Observables may be given as argument.
     * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each
     * Observable subscription on.
     * @return {Observable} All values of each passed Observable merged into a
     * single Observable, in order, in serial fashion.
     * @static true
     * @name concat
     * @owner Observable
     */

    function concat() {
      var observables = [];

      for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
      }

      if (observables.length === 1 || observables.length === 2 && isScheduler_1.isScheduler(observables[1])) {
        return from_1.from(observables[0]);
      }

      return concatAll_1.concatAll()(of_1.of.apply(void 0, observables));
    }

    exports.concat = concat; 
  });
  unwrapExports(concat_1);
  var concat_2 = concat_1.concat;

  var defer_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    }); // lol

    /**
     * Creates an Observable that, on subscribe, calls an Observable factory to
     * make an Observable for each new Observer.
     *
     * <span class="informal">Creates the Observable lazily, that is, only when it
     * is subscribed.
     * </span>
     *
     * <img src="./img/defer.png" width="100%">
     *
     * `defer` allows you to create the Observable only when the Observer
     * subscribes, and create a fresh Observable for each Observer. It waits until
     * an Observer subscribes to it, and then it generates an Observable,
     * typically with an Observable factory function. It does this afresh for each
     * subscriber, so although each subscriber may think it is subscribing to the
     * same Observable, in fact each subscriber gets its own individual
     * Observable.
     *
     * @example <caption>Subscribe to either an Observable of clicks or an Observable of interval, at random</caption>
     * var clicksOrInterval = Rx.Observable.defer(function () {
     *   if (Math.random() > 0.5) {
     *     return Rx.Observable.fromEvent(document, 'click');
     *   } else {
     *     return Rx.Observable.interval(1000);
     *   }
     * });
     * clicksOrInterval.subscribe(x => console.log(x));
     *
     * // Results in the following behavior:
     * // If the result of Math.random() is greater than 0.5 it will listen
     * // for clicks anywhere on the "document"; when document is clicked it
     * // will log a MouseEvent object to the console. If the result is less
     * // than 0.5 it will emit ascending numbers, one every second(1000ms).
     *
     * @see {@link create}
     *
     * @param {function(): SubscribableOrPromise} observableFactory The Observable
     * factory function to invoke for each Observer that subscribes to the output
     * Observable. May also return a Promise, which will be converted on the fly
     * to an Observable.
     * @return {Observable} An Observable whose Observers' subscriptions trigger
     * an invocation of the given Observable factory function.
     * @static true
     * @name defer
     * @owner Observable
     */

    function defer(observableFactory) {
      return new Observable_1.Observable(function (subscriber) {
        var input;

        try {
          input = observableFactory();
        } catch (err) {
          subscriber.error(err);
          return undefined;
        }

        var source = input ? from_1.from(input) : empty_1.empty();
        return source.subscribe(subscriber);
      });
    }

    exports.defer = defer; 
  });
  unwrapExports(defer_1);
  var defer_2 = defer_1.defer;

  var forkJoin_1 = createCommonjsModule(function (module, exports) {

    var __extends = commonjsGlobal && commonjsGlobal.__extends || function () {
      var extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (b.hasOwnProperty(p)) d[p] = b[p];
        }
      };

      return function (d, b) {
        extendStatics(d, b);

        function __() {
          this.constructor = d;
        }

        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /* tslint:enable:max-line-length */

    /**
     * Joins last values emitted by passed Observables.
     *
     * <span class="informal">Wait for Observables to complete and then combine last values they emitted.</span>
     *
     * <img src="./img/forkJoin.png" width="100%">
     *
     * `forkJoin` is an operator that takes any number of Observables which can be passed either as an array
     * or directly as arguments. If no input Observables are provided, resulting stream will complete
     * immediately.
     *
     * `forkJoin` will wait for all passed Observables to complete and then it will emit an array with last
     * values from corresponding Observables. So if you pass `n` Observables to the operator, resulting
     * array will have `n` values, where first value is the last thing emitted by the first Observable,
     * second value is the last thing emitted by the second Observable and so on. That means `forkJoin` will
     * not emit more than once and it will complete after that. If you need to emit combined values not only
     * at the end of lifecycle of passed Observables, but also throughout it, try out {@link combineLatest}
     * or {@link zip} instead.
     *
     * In order for resulting array to have the same length as the number of input Observables, whenever any of
     * that Observables completes without emitting any value, `forkJoin` will complete at that moment as well
     * and it will not emit anything either, even if it already has some last values from other Observables.
     * Conversely, if there is an Observable that never completes, `forkJoin` will never complete as well,
     * unless at any point some other Observable completes without emitting value, which brings us back to
     * the previous case. Overall, in order for `forkJoin` to emit a value, all Observables passed as arguments
     * have to emit something at least once and complete.
     *
     * If any input Observable errors at some point, `forkJoin` will error as well and all other Observables
     * will be immediately unsubscribed.
     *
     * Optionally `forkJoin` accepts project function, that will be called with values which normally
     * would land in emitted array. Whatever is returned by project function, will appear in output
     * Observable instead. This means that default project can be thought of as a function that takes
     * all its arguments and puts them into an array. Note that project function will be called only
     * when output Observable is supposed to emit a result.
     *
     * @example <caption>Use forkJoin with operator emitting immediately</caption>
     * import { forkJoin, of } from 'rxjs/create';
     *
     * const observable = forkJoin(
     *   of(1, 2, 3, 4),
     *   of(5, 6, 7, 8)
     * );
     * observable.subscribe(
     *   value => console.log(value),
     *   err => {},
     *   () => console.log('This is how it ends!')
     * );
     *
     * // Logs:
     * // [4, 8]
     * // "This is how it ends!"
     *
     *
     * @example <caption>Use forkJoin with operator emitting after some time</caption>
     * import { forkJoin, interval } from 'rxjs/create';
     * import { take } from 'rxjs/operators';
     *
     * const observable = forkJoin(
     *   interval(1000).pipe(take(3)), // emit 0, 1, 2 every second and complete
     *   interval(500).pipe(take(4)) // emit 0, 1, 2, 3 every half a second and complete
     * );
     * observable.subscribe(
     *   value => console.log(value),
     *   err => {},
     *   () => console.log('This is how it ends!')
     * );
     *
     * // Logs:
     * // [2, 3] after 3 seconds
     * // "This is how it ends!" immediately after
     *
     *
     * @example <caption>Use forkJoin with project function</caption>
     * import { jorkJoin, interval } from 'rxjs/create';
     * import { take } from 'rxjs/operators';
     *
     * const observable = forkJoin(
     *   interval(1000).pipe(take(3)), // emit 0, 1, 2 every second and complete
     *   interval(500).pipe(take(4)), // emit 0, 1, 2, 3 every half a second and complete
     *   (n, m) => n + m
     * );
     * observable.subscribe(
     *   value => console.log(value),
     *   err => {},
     *   () => console.log('This is how it ends!')
     * );
     *
     * // Logs:
     * // 5 after 3 seconds
     * // "This is how it ends!" immediately after
     *
     * @see {@link combineLatest}
     * @see {@link zip}
     *
     * @param {...ObservableInput} sources Any number of Observables provided either as an array or as an arguments
     * passed directly to the operator.
     * @param {function} [project] Function that takes values emitted by input Observables and returns value
     * that will appear in resulting Observable instead of default array.
     * @return {Observable} Observable emitting either an array of last values emitted by passed Observables
     * or value from project function.
     * @static true
     * @name forkJoin
     * @owner Observable
     */

    function forkJoin() {
      var sources = [];

      for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
      } // if the first and only other argument is an array
      // assume it's been called with `forkJoin([obs1, obs2, obs3])`


      if (sources.length === 1 && isArray$1.isArray(sources[0])) {
        sources = sources[0];
      }

      if (sources.length === 0) {
        return empty_1.EMPTY;
      }

      return new Observable_1.Observable(function (subscriber) {
        return new ForkJoinSubscriber(subscriber, sources);
      });
    }

    exports.forkJoin = forkJoin;
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */

    var ForkJoinSubscriber =
    /** @class */
    function (_super) {
      __extends(ForkJoinSubscriber, _super);

      function ForkJoinSubscriber(destination, sources) {
        var _this = _super.call(this, destination) || this;

        _this.sources = sources;
        _this.completed = 0;
        _this.haveValues = 0;
        var len = sources.length;
        _this.values = new Array(len);

        for (var i = 0; i < len; i++) {
          var source = sources[i];
          var innerSubscription = subscribeToResult_1.subscribeToResult(_this, source, null, i);

          if (innerSubscription) {
            _this.add(innerSubscription);
          }
        }

        return _this;
      }

      ForkJoinSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.values[outerIndex] = innerValue;

        if (!innerSub._hasValue) {
          innerSub._hasValue = true;
          this.haveValues++;
        }
      };

      ForkJoinSubscriber.prototype.notifyComplete = function (innerSub) {
        var _a = this,
            destination = _a.destination,
            haveValues = _a.haveValues,
            values = _a.values;

        var len = values.length;

        if (!innerSub._hasValue) {
          destination.complete();
          return;
        }

        this.completed++;

        if (this.completed !== len) {
          return;
        }

        if (haveValues === len) {
          destination.next(values);
        }

        destination.complete();
      };

      return ForkJoinSubscriber;
    }(OuterSubscriber_1.OuterSubscriber); 

  });
  unwrapExports(forkJoin_1);
  var forkJoin_2 = forkJoin_1.forkJoin;

  var fromEvent_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var toString = Object.prototype.toString;
    /* tslint:enable:max-line-length */

    /**
     * Creates an Observable that emits events of a specific type coming from the
     * given event target.
     *
     * <span class="informal">Creates an Observable from DOM events, or Node.js
     * EventEmitter events or others.</span>
     *
     * <img src="./img/fromEvent.png" width="100%">
     *
     * `fromEvent` accepts as a first argument event target, which is an object with methods
     * for registering event handler functions. As a second argument it takes string that indicates
     * type of event we want to listen for. `fromEvent` supports selected types of event targets,
     * which are described in detail below. If your event target does not match any of the ones listed,
     * you should use {@link fromEventPattern}, which can be used on arbitrary APIs.
     * When it comes to APIs supported by `fromEvent`, their methods for adding and removing event
     * handler functions have different names, but they all accept a string describing event type
     * and function itself, which will be called whenever said event happens.
     *
     * Every time resulting Observable is subscribed, event handler function will be registered
     * to event target on given event type. When that event fires, value
     * passed as a first argument to registered function will be emitted by output Observable.
     * When Observable is unsubscribed, function will be unregistered from event target.
     *
     * Note that if event target calls registered function with more than one argument, second
     * and following arguments will not appear in resulting stream. In order to get access to them,
     * you can pass to `fromEvent` optional project function, which will be called with all arguments
     * passed to event handler. Output Observable will then emit value returned by project function,
     * instead of the usual value.
     *
     * Remember that event targets listed below are checked via duck typing. It means that
     * no matter what kind of object you have and no matter what environment you work in,
     * you can safely use `fromEvent` on that object if it exposes described methods (provided
     * of course they behave as was described above). So for example if Node.js library exposes
     * event target which has the same method names as DOM EventTarget, `fromEvent` is still
     * a good choice.
     *
     * If the API you use is more callback then event handler oriented (subscribed
     * callback function fires only once and thus there is no need to manually
     * unregister it), you should use {@link bindCallback} or {@link bindNodeCallback}
     * instead.
     *
     * `fromEvent` supports following types of event targets:
     *
     * **DOM EventTarget**
     *
     * This is an object with `addEventListener` and `removeEventListener` methods.
     *
     * In the browser, `addEventListener` accepts - apart from event type string and event
     * handler function arguments - optional third parameter, which is either an object or boolean,
     * both used for additional configuration how and when passed function will be called. When
     * `fromEvent` is used with event target of that type, you can provide this values
     * as third parameter as well.
     *
     * **Node.js EventEmitter**
     *
     * An object with `addListener` and `removeListener` methods.
     *
     * **JQuery-style event target**
     *
     * An object with `on` and `off` methods
     *
     * **DOM NodeList**
     *
     * List of DOM Nodes, returned for example by `document.querySelectorAll` or `Node.childNodes`.
     *
     * Although this collection is not event target in itself, `fromEvent` will iterate over all Nodes
     * it contains and install event handler function in every of them. When returned Observable
     * is unsubscribed, function will be removed from all Nodes.
     *
     * **DOM HtmlCollection**
     *
     * Just as in case of NodeList it is a collection of DOM nodes. Here as well event handler function is
     * installed and removed in each of elements.
     *
     *
     * @example <caption>Emits clicks happening on the DOM document</caption>
     * var clicks = fromEvent(document, 'click');
     * clicks.subscribe(x => console.log(x));
     *
     * // Results in:
     * // MouseEvent object logged to console every time a click
     * // occurs on the document.
     *
     *
     * @example <caption>Use addEventListener with capture option</caption>
     * var clicksInDocument = fromEvent(document, 'click', true); // note optional configuration parameter
     *                                                                          // which will be passed to addEventListener
     * var clicksInDiv = fromEvent(someDivInDocument, 'click');
     *
     * clicksInDocument.subscribe(() => console.log('document'));
     * clicksInDiv.subscribe(() => console.log('div'));
     *
     * // By default events bubble UP in DOM tree, so normally
     * // when we would click on div in document
     * // "div" would be logged first and then "document".
     * // Since we specified optional `capture` option, document
     * // will catch event when it goes DOWN DOM tree, so console
     * // will log "document" and then "div".
     *
     * @see {@link bindCallback}
     * @see {@link bindNodeCallback}
     * @see {@link fromEventPattern}
     *
     * @param {EventTargetLike} target The DOM EventTarget, Node.js
     * EventEmitter, JQuery-like event target, NodeList or HTMLCollection to attach the event handler to.
     * @param {string} eventName The event name of interest, being emitted by the
     * `target`.
     * @param {EventListenerOptions} [options] Options to pass through to addEventListener
     * @return {Observable<T>}
     * @name fromEvent
     */

    function fromEvent(target, eventName, options) {
      return new Observable_1.Observable(function (subscriber) {
        function handler(e) {
          if (arguments.length > 1) {
            subscriber.next(Array.prototype.slice.call(arguments));
          } else {
            subscriber.next(e);
          }
        }

        setupSubscription(target, eventName, handler, subscriber, options);
      });
    }

    exports.fromEvent = fromEvent;

    function setupSubscription(sourceObj, eventName, handler, subscriber, options) {
      var unsubscribe;

      if (isNodeList(sourceObj) || isHTMLCollection(sourceObj)) {
        for (var i = 0, len = sourceObj.length; i < len; i++) {
          setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
        }
      } else if (isEventTarget(sourceObj)) {
        var source_1 = sourceObj;
        sourceObj.addEventListener(eventName, handler, options);

        unsubscribe = function unsubscribe() {
          return source_1.removeEventListener(eventName, handler, options);
        };
      } else if (isJQueryStyleEventEmitter(sourceObj)) {
        var source_2 = sourceObj;
        sourceObj.on(eventName, handler);

        unsubscribe = function unsubscribe() {
          return source_2.off(eventName, handler);
        };
      } else if (isNodeStyleEventEmitter(sourceObj)) {
        var source_3 = sourceObj;
        sourceObj.addListener(eventName, handler);

        unsubscribe = function unsubscribe() {
          return source_3.removeListener(eventName, handler);
        };
      } else {
        throw new TypeError('Invalid event target');
      }

      subscriber.add(unsubscribe);
    }

    function isNodeStyleEventEmitter(sourceObj) {
      return !!sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';
    }

    function isJQueryStyleEventEmitter(sourceObj) {
      return !!sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';
    }

    function isNodeList(sourceObj) {
      return !!sourceObj && toString.call(sourceObj) === '[object NodeList]';
    }

    function isHTMLCollection(sourceObj) {
      return !!sourceObj && toString.call(sourceObj) === '[object HTMLCollection]';
    }

    function isEventTarget(sourceObj) {
      return !!sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';
    } 

  });
  unwrapExports(fromEvent_1);
  var fromEvent_2 = fromEvent_1.fromEvent;

  var fromEventPattern_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /**
     * Creates an Observable from an API based on addHandler/removeHandler
     * functions.
     *
     * <span class="informal">Converts any addHandler/removeHandler API to an
     * Observable.</span>
     *
     * <img src="./img/fromEventPattern.png" width="100%">
     *
     * Creates an Observable by using the `addHandler` and `removeHandler`
     * functions to add and remove the handlers. The `addHandler` is
     * called when the output Observable is subscribed, and `removeHandler` is
     * called when the Subscription is unsubscribed.
     *
     * @example <caption>Emits clicks happening on the DOM document</caption>
     * function addClickHandler(handler) {
     *   document.addEventListener('click', handler);
     * }
     *
     * function removeClickHandler(handler) {
     *   document.removeEventListener('click', handler);
     * }
     *
     * var clicks = fromEventPattern(
     *   addClickHandler,
     *   removeClickHandler
     * );
     * clicks.subscribe(x => console.log(x));
     *
     * @see {@link from}
     * @see {@link fromEvent}
     *
     * @param {function(handler: Function): any} addHandler A function that takes
     * a `handler` function as argument and attaches it somehow to the actual
     * source of events.
     * @param {function(handler: Function, signal?: any): void} [removeHandler] An optional function that
     * takes a `handler` function as argument and removes it in case it was
     * previously attached using `addHandler`. if addHandler returns signal to teardown when remove,
     * removeHandler function will forward it.
     * @return {Observable<T>}
     * @name fromEventPattern
     */

    function fromEventPattern(addHandler, removeHandler) {
      return new Observable_1.Observable(function (subscriber) {
        var handler = function handler(e) {
          return subscriber.next(e);
        };

        var retValue;

        try {
          retValue = addHandler(handler);
        } catch (err) {
          subscriber.error(err);
          return undefined;
        }

        if (!isFunction_1.isFunction(removeHandler)) {
          return undefined;
        }

        return function () {
          return removeHandler(handler, retValue);
        };
      });
    }

    exports.fromEventPattern = fromEventPattern; 
  });
  unwrapExports(fromEventPattern_1);
  var fromEventPattern_2 = fromEventPattern_1.fromEventPattern;

  var generate_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    function generate(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler) {
      var resultSelector;
      var initialState;

      if (arguments.length == 1) {
        var options = initialStateOrOptions;
        initialState = options.initialState;
        condition = options.condition;
        iterate = options.iterate;
        resultSelector = options.resultSelector || identity_1.identity;
        scheduler = options.scheduler;
      } else if (resultSelectorOrObservable === undefined || isScheduler_1.isScheduler(resultSelectorOrObservable)) {
        initialState = initialStateOrOptions;
        resultSelector = identity_1.identity;
        scheduler = resultSelectorOrObservable;
      } else {
        initialState = initialStateOrOptions;
        resultSelector = resultSelectorOrObservable;
      }

      return new Observable_1.Observable(function (subscriber) {
        var state = initialState;

        if (scheduler) {
          return scheduler.schedule(dispatch, 0, {
            subscriber: subscriber,
            iterate: iterate,
            condition: condition,
            resultSelector: resultSelector,
            state: state
          });
        }

        do {
          if (condition) {
            var conditionResult = void 0;

            try {
              conditionResult = condition(state);
            } catch (err) {
              subscriber.error(err);
              return undefined;
            }

            if (!conditionResult) {
              subscriber.complete();
              break;
            }
          }

          var value = void 0;

          try {
            value = resultSelector(state);
          } catch (err) {
            subscriber.error(err);
            return undefined;
          }

          subscriber.next(value);

          if (subscriber.closed) {
            break;
          }

          try {
            state = iterate(state);
          } catch (err) {
            subscriber.error(err);
            return undefined;
          }
        } while (true);

        return undefined;
      });
    }

    exports.generate = generate;

    function dispatch(state) {
      var subscriber = state.subscriber,
          condition = state.condition;

      if (subscriber.closed) {
        return undefined;
      }

      if (state.needIterate) {
        try {
          state.state = state.iterate(state.state);
        } catch (err) {
          subscriber.error(err);
          return undefined;
        }
      } else {
        state.needIterate = true;
      }

      if (condition) {
        var conditionResult = void 0;

        try {
          conditionResult = condition(state.state);
        } catch (err) {
          subscriber.error(err);
          return undefined;
        }

        if (!conditionResult) {
          subscriber.complete();
          return undefined;
        }

        if (subscriber.closed) {
          return undefined;
        }
      }

      var value;

      try {
        value = state.resultSelector(state.state);
      } catch (err) {
        subscriber.error(err);
        return undefined;
      }

      if (subscriber.closed) {
        return undefined;
      }

      subscriber.next(value);

      if (subscriber.closed) {
        return undefined;
      }

      return this.schedule(state);
    } 

  });
  unwrapExports(generate_1);
  var generate_2 = generate_1.generate;

  var iif_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /**
     * Decides at subscription time which Observable will actually be subscribed.
     *
     * <span class="informal">`If` statement for Observables.</span>
     *
     * `if` accepts a condition function and two Observables. When
     * an Observable returned by the operator is subscribed, condition function will be called.
     * Based on what boolean it returns at that moment, consumer will subscribe either to
     * the first Observable (if condition was true) or to the second (if condition was false). Condition
     * function may also not return anything - in that case condition will be evaluated as false and
     * second Observable will be subscribed.
     *
     * Note that Observables for both cases (true and false) are optional. If condition points to an Observable that
     * was left undefined, resulting stream will simply complete immediately. That allows you to, rather
     * then controlling which Observable will be subscribed, decide at runtime if consumer should have access
     * to given Observable or not.
     *
     * If you have more complex logic that requires decision between more than two Observables, {@link defer}
     * will probably be a better choice. Actually `if` can be easily implemented with {@link defer}
     * and exists only for convenience and readability reasons.
     *
     *
     * @example <caption>Change at runtime which Observable will be subscribed</caption>
     * let subscribeToFirst;
     * const firstOrSecond = Rx.Observable.if(
     *   () => subscribeToFirst,
     *   Rx.Observable.of('first'),
     *   Rx.Observable.of('second')
     * );
     *
     * subscribeToFirst = true;
     * firstOrSecond.subscribe(value => console.log(value));
     *
     * // Logs:
     * // "first"
     *
     * subscribeToFirst = false;
     * firstOrSecond.subscribe(value => console.log(value));
     *
     * // Logs:
     * // "second"
     *
     *
     * @example <caption>Control an access to an Observable</caption>
     * let accessGranted;
     * const observableIfYouHaveAccess = Rx.Observable.if(
     *   () => accessGranted,
     *   Rx.Observable.of('It seems you have an access...') // Note that only one Observable is passed to the operator.
     * );
     *
     * accessGranted = true;
     * observableIfYouHaveAccess.subscribe(
     *   value => console.log(value),
     *   err => {},
     *   () => console.log('The end')
     * );
     *
     * // Logs:
     * // "It seems you have an access..."
     * // "The end"
     *
     * accessGranted = false;
     * observableIfYouHaveAccess.subscribe(
     *   value => console.log(value),
     *   err => {},
     *   () => console.log('The end')
     * );
     *
     * // Logs:
     * // "The end"
     *
     * @see {@link defer}
     *
     * @param {function(): boolean} condition Condition which Observable should be chosen.
     * @param {Observable} [trueObservable] An Observable that will be subscribed if condition is true.
     * @param {Observable} [falseObservable] An Observable that will be subscribed if condition is false.
     * @return {Observable} Either first or second Observable, depending on condition.
     * @static true
     * @name iif
     * @owner Observable
     */

    function iif(condition, trueResult, falseResult) {
      if (trueResult === void 0) {
        trueResult = empty_1.EMPTY;
      }

      if (falseResult === void 0) {
        falseResult = empty_1.EMPTY;
      }

      return defer_1.defer(function () {
        return condition() ? trueResult : falseResult;
      });
    }

    exports.iif = iif; 
  });
  unwrapExports(iif_1);
  var iif_2 = iif_1.iif;

  var isNumeric_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    function isNumeric(val) {
      // parseFloat NaNs numeric-cast false positives (null|true|false|"")
      // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
      // subtraction forces infinities to NaN
      // adding 1 corrects loss of precision from parseFloat (#15100)
      return !isArray$1.isArray(val) && val - parseFloat(val) + 1 >= 0;
    }

    exports.isNumeric = isNumeric; 
  });
  unwrapExports(isNumeric_1);
  var isNumeric_2 = isNumeric_1.isNumeric;

  var interval_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /**
     * Creates an Observable that emits sequential numbers every specified
     * interval of time, on a specified IScheduler.
     *
     * <span class="informal">Emits incremental numbers periodically in time.
     * </span>
     *
     * <img src="./img/interval.png" width="100%">
     *
     * `interval` returns an Observable that emits an infinite sequence of
     * ascending integers, with a constant interval of time of your choosing
     * between those emissions. The first emission is not sent immediately, but
     * only after the first period has passed. By default, this operator uses the
     * `async` IScheduler to provide a notion of time, but you may pass any
     * IScheduler to it.
     *
     * @example <caption>Emits ascending numbers, one every second (1000ms)</caption>
     * var numbers = Rx.Observable.interval(1000);
     * numbers.subscribe(x => console.log(x));
     *
     * @see {@link timer}
     * @see {@link delay}
     *
     * @param {number} [period=0] The interval size in milliseconds (by default)
     * or the time unit determined by the scheduler's clock.
     * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling
     * the emission of values, and providing a notion of "time".
     * @return {Observable} An Observable that emits a sequential number each time
     * interval.
     * @static true
     * @name interval
     * @owner Observable
     */

    function interval(period, scheduler) {
      if (period === void 0) {
        period = 0;
      }

      if (scheduler === void 0) {
        scheduler = async$1.async;
      }

      if (!isNumeric_1.isNumeric(period) || period < 0) {
        period = 0;
      }

      if (!scheduler || typeof scheduler.schedule !== 'function') {
        scheduler = async$1.async;
      }

      return new Observable_1.Observable(function (subscriber) {
        subscriber.add(scheduler.schedule(dispatch, period, {
          subscriber: subscriber,
          counter: 0,
          period: period
        }));
        return subscriber;
      });
    }

    exports.interval = interval;

    function dispatch(state) {
      var subscriber = state.subscriber,
          counter = state.counter,
          period = state.period;
      subscriber.next(counter);
      this.schedule({
        subscriber: subscriber,
        counter: counter + 1,
        period: period
      }, period);
    } 

  });
  unwrapExports(interval_1);
  var interval_2 = interval_1.interval;

  var merge_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /* tslint:enable:max-line-length */

    /**
     * Creates an output Observable which concurrently emits all values from every
     * given input Observable.
     *
     * <span class="informal">Flattens multiple Observables together by blending
     * their values into one Observable.</span>
     *
     * <img src="./img/merge.png" width="100%">
     *
     * `merge` subscribes to each given input Observable (as arguments), and simply
     * forwards (without doing any transformation) all the values from all the input
     * Observables to the output Observable. The output Observable only completes
     * once all input Observables have completed. Any error delivered by an input
     * Observable will be immediately emitted on the output Observable.
     *
     * @example <caption>Merge together two Observables: 1s interval and clicks</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var timer = Rx.Observable.interval(1000);
     * var clicksOrTimer = Rx.Observable.merge(clicks, timer);
     * clicksOrTimer.subscribe(x => console.log(x));
     *
     * // Results in the following:
     * // timer will emit ascending values, one every second(1000ms) to console
     * // clicks logs MouseEvents to console everytime the "document" is clicked
     * // Since the two streams are merged you see these happening
     * // as they occur.
     *
     * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>
     * var timer1 = Rx.Observable.interval(1000).take(10);
     * var timer2 = Rx.Observable.interval(2000).take(6);
     * var timer3 = Rx.Observable.interval(500).take(10);
     * var concurrent = 2; // the argument
     * var merged = Rx.Observable.merge(timer1, timer2, timer3, concurrent);
     * merged.subscribe(x => console.log(x));
     *
     * // Results in the following:
     * // - First timer1 and timer2 will run concurrently
     * // - timer1 will emit a value every 1000ms for 10 iterations
     * // - timer2 will emit a value every 2000ms for 6 iterations
     * // - after timer1 hits it's max iteration, timer2 will
     * //   continue, and timer3 will start to run concurrently with timer2
     * // - when timer2 hits it's max iteration it terminates, and
     * //   timer3 will continue to emit a value every 500ms until it is complete
     *
     * @see {@link mergeAll}
     * @see {@link mergeMap}
     * @see {@link mergeMapTo}
     * @see {@link mergeScan}
     *
     * @param {...ObservableInput} observables Input Observables to merge together.
     * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
     * Observables being subscribed to concurrently.
     * @param {Scheduler} [scheduler=null] The IScheduler to use for managing
     * concurrency of input Observables.
     * @return {Observable} an Observable that emits items that are the result of
     * every input Observable.
     * @static true
     * @name merge
     * @owner Observable
     */

    function merge() {
      var observables = [];

      for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
      }

      var concurrent = Number.POSITIVE_INFINITY;
      var scheduler = null;
      var last = observables[observables.length - 1];

      if (isScheduler_1.isScheduler(last)) {
        scheduler = observables.pop();

        if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
          concurrent = observables.pop();
        }
      } else if (typeof last === 'number') {
        concurrent = observables.pop();
      }

      if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable_1.Observable) {
        return observables[0];
      }

      return mergeAll_1.mergeAll(concurrent)(fromArray_1.fromArray(observables, scheduler));
    }

    exports.merge = merge; 
  });
  unwrapExports(merge_1);
  var merge_2 = merge_1.merge;

  var onErrorResumeNext_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /* tslint:enable:max-line-length */

    /**
     * When any of the provided Observable emits an complete or error notification, it immediately subscribes to the next one
     * that was passed.
     *
     * <span class="informal">Execute series of Observables no matter what, even if it means swallowing errors.</span>
     *
     * <img src="./img/onErrorResumeNext.png" width="100%">
     *
     * `onErrorResumeNext` Will subscribe to each observable source it is provided, in order.
     * If the source it's subscribed to emits an error or completes, it will move to the next source
     * without error.
     *
     * If `onErrorResumeNext` is provided no arguments, or a single, empty array, it will return {@link EMPTY}.
     *
     * `onErrorResumeNext` is basically {@link concat}, only it will continue, even if one of its
     * sources emits an error.
     *
     * Note that there is no way to handle any errors thrown by sources via the resuult of
     * `onErrorResumeNext`. If you want to handle errors thrown in any given source, you can
     * always use the {@link catchError} operator on them before passing them into `onErrorResumeNext`.
     *
     * @example <caption>Subscribe to the next Observable after map fails</caption>
     * import { onErrorResumeNext, of } from 'rxjs/create';
     * import { map } from 'rxjs/operators';
     *
     * onErrorResumeNext(
     *  of(1, 2, 3, 0).pipe(
     *    map(x => {
     *      if (x === 0) throw Error();
     *      return 10 / x;
     *    })
     *  ),
     *  of(1, 2, 3),
     * )
     * .subscribe(
     *   val => console.log(val),
     *   err => console.log(err),          // Will never be called.
     *   () => console.log('done')
     * );
     *
     * // Logs:
     * // 10
     * // 5
     * // 3.3333333333333335
     * // 1
     * // 2
     * // 3
     * // "done"
     *
     * @see {@link concat}
     * @see {@link catch}
     *
     * @param {...ObservableInput} sources Observables (or anything that *is* observable) passed either directly or as an array.
     * @return {Observable} An Observable that concatenates all sources, one after the other,
     * ignoring all errors, such that any error causes it to move on to the next source.
     */

    function onErrorResumeNext() {
      var sources = [];

      for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
      }

      if (sources.length === 0) {
        return empty_1.EMPTY;
      }

      var first = sources[0],
          remainder = sources.slice(1);

      if (sources.length === 1 && isArray$1.isArray(first)) {
        return onErrorResumeNext.apply(void 0, first);
      }

      return new Observable_1.Observable(function (subscriber) {
        var subNext = function subNext() {
          return subscriber.add(onErrorResumeNext.apply(void 0, remainder).subscribe(subscriber));
        };

        return from_1.from(first).subscribe({
          next: function next(value) {
            subscriber.next(value);
          },
          error: subNext,
          complete: subNext
        });
      });
    }

    exports.onErrorResumeNext = onErrorResumeNext; 
  });
  unwrapExports(onErrorResumeNext_1);
  var onErrorResumeNext_2 = onErrorResumeNext_1.onErrorResumeNext;

  var pairs_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /**
     * Convert an object into an observable sequence of [key, value] pairs
     * using an optional IScheduler to enumerate the object.
     *
     * @example <caption>Converts a javascript object to an Observable</caption>
     * var obj = {
     *   foo: 42,
     *   bar: 56,
     *   baz: 78
     * };
     *
     * var source = Rx.Observable.pairs(obj);
     *
     * var subscription = source.subscribe(
     *   function (x) {
     *     console.log('Next: %s', x);
     *   },
     *   function (err) {
     *     console.log('Error: %s', err);
     *   },
     *   function () {
     *     console.log('Completed');
     *   });
     *
     * @param {Object} obj The object to inspect and turn into an
     * Observable sequence.
     * @param {Scheduler} [scheduler] An optional IScheduler to run the
     * enumeration of the input sequence on.
     * @returns {(Observable<[string, T]>)} An observable sequence of
     * [key, value] pairs from the object.
     */

    function pairs(obj, scheduler) {
      if (!scheduler) {
        return new Observable_1.Observable(function (subscriber) {
          var keys = Object.keys(obj);

          for (var i = 0; i < keys.length && !subscriber.closed; i++) {
            var key = keys[i];

            if (obj.hasOwnProperty(key)) {
              subscriber.next([key, obj[key]]);
            }
          }

          subscriber.complete();
        });
      } else {
        return new Observable_1.Observable(function (subscriber) {
          var keys = Object.keys(obj);
          var subscription = new Subscription_1.Subscription();
          subscription.add(scheduler.schedule(dispatch, 0, {
            keys: keys,
            index: 0,
            subscriber: subscriber,
            subscription: subscription,
            obj: obj
          }));
          return subscription;
        });
      }
    }

    exports.pairs = pairs;
    /** @internal */

    function dispatch(state) {
      var keys = state.keys,
          index = state.index,
          subscriber = state.subscriber,
          subscription = state.subscription,
          obj = state.obj;

      if (!subscriber.closed) {
        if (index < keys.length) {
          var key = keys[index];
          subscriber.next([key, obj[key]]);
          subscription.add(this.schedule({
            keys: keys,
            index: index + 1,
            subscriber: subscriber,
            subscription: subscription,
            obj: obj
          }));
        } else {
          subscriber.complete();
        }
      }
    }

    exports.dispatch = dispatch; 
  });
  unwrapExports(pairs_1);
  var pairs_2 = pairs_1.pairs;
  var pairs_3 = pairs_1.dispatch;

  var race_1 = createCommonjsModule(function (module, exports) {

    var __extends = commonjsGlobal && commonjsGlobal.__extends || function () {
      var extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (b.hasOwnProperty(p)) d[p] = b[p];
        }
      };

      return function (d, b) {
        extendStatics(d, b);

        function __() {
          this.constructor = d;
        }

        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    function race() {
      var observables = [];

      for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
      } // if the only argument is an array, it was most likely called with
      // `race([obs1, obs2, ...])`


      if (observables.length === 1) {
        if (isArray$1.isArray(observables[0])) {
          observables = observables[0];
        } else {
          return observables[0];
        }
      }

      return fromArray_1.fromArray(observables, undefined).lift(new RaceOperator());
    }

    exports.race = race;

    var RaceOperator =
    /** @class */
    function () {
      function RaceOperator() {}

      RaceOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RaceSubscriber(subscriber));
      };

      return RaceOperator;
    }();

    exports.RaceOperator = RaceOperator;
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */

    var RaceSubscriber =
    /** @class */
    function (_super) {
      __extends(RaceSubscriber, _super);

      function RaceSubscriber(destination) {
        var _this = _super.call(this, destination) || this;

        _this.hasFirst = false;
        _this.observables = [];
        _this.subscriptions = [];
        return _this;
      }

      RaceSubscriber.prototype._next = function (observable) {
        this.observables.push(observable);
      };

      RaceSubscriber.prototype._complete = function () {
        var observables = this.observables;
        var len = observables.length;

        if (len === 0) {
          this.destination.complete();
        } else {
          for (var i = 0; i < len && !this.hasFirst; i++) {
            var observable = observables[i];
            var subscription = subscribeToResult_1.subscribeToResult(this, observable, observable, i);

            if (this.subscriptions) {
              this.subscriptions.push(subscription);
            }

            this.add(subscription);
          }

          this.observables = null;
        }
      };

      RaceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (!this.hasFirst) {
          this.hasFirst = true;

          for (var i = 0; i < this.subscriptions.length; i++) {
            if (i !== outerIndex) {
              var subscription = this.subscriptions[i];
              subscription.unsubscribe();
              this.remove(subscription);
            }
          }

          this.subscriptions = null;
        }

        this.destination.next(innerValue);
      };

      return RaceSubscriber;
    }(OuterSubscriber_1.OuterSubscriber);

    exports.RaceSubscriber = RaceSubscriber; 
  });
  unwrapExports(race_1);
  var race_2 = race_1.race;
  var race_3 = race_1.RaceOperator;
  var race_4 = race_1.RaceSubscriber;

  var range_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /**
     * Creates an Observable that emits a sequence of numbers within a specified
     * range.
     *
     * <span class="informal">Emits a sequence of numbers in a range.</span>
     *
     * <img src="./img/range.png" width="100%">
     *
     * `range` operator emits a range of sequential integers, in order, where you
     * select the `start` of the range and its `length`. By default, uses no
     * IScheduler and just delivers the notifications synchronously, but may use
     * an optional IScheduler to regulate those deliveries.
     *
     * @example <caption>Emits the numbers 1 to 10</caption>
     * var numbers = Rx.Observable.range(1, 10);
     * numbers.subscribe(x => console.log(x));
     *
     * @see {@link timer}
     * @see {@link interval}
     *
     * @param {number} [start=0] The value of the first integer in the sequence.
     * @param {number} [count=0] The number of sequential integers to generate.
     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
     * the emissions of the notifications.
     * @return {Observable} An Observable of numbers that emits a finite range of
     * sequential integers.
     * @static true
     * @name range
     * @owner Observable
     */

    function range(start, count, scheduler) {
      if (start === void 0) {
        start = 0;
      }

      if (count === void 0) {
        count = 0;
      }

      return new Observable_1.Observable(function (subscriber) {
        var index = 0;

        if (scheduler) {
          return scheduler.schedule(dispatch, 0, {
            index: index,
            count: count,
            start: start,
            subscriber: subscriber
          });
        } else {
          do {
            if (index++ >= count) {
              subscriber.complete();
              break;
            }

            subscriber.next(start++);

            if (subscriber.closed) {
              break;
            }
          } while (true);
        }

        return undefined;
      });
    }

    exports.range = range;
    /** @internal */

    function dispatch(state) {
      var start = state.start,
          index = state.index,
          count = state.count,
          subscriber = state.subscriber;

      if (index >= count) {
        subscriber.complete();
        return;
      }

      subscriber.next(start);

      if (subscriber.closed) {
        return;
      }

      state.index = index + 1;
      state.start = start + 1;
      this.schedule(state);
    }

    exports.dispatch = dispatch; 
  });
  unwrapExports(range_1);
  var range_2 = range_1.range;
  var range_3 = range_1.dispatch;

  var timer_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /**
     * Creates an Observable that starts emitting after an `initialDelay` and
     * emits ever increasing numbers after each `period` of time thereafter.
     *
     * <span class="informal">Its like {@link interval}, but you can specify when
     * should the emissions start.</span>
     *
     * <img src="./img/timer.png" width="100%">
     *
     * `timer` returns an Observable that emits an infinite sequence of ascending
     * integers, with a constant interval of time, `period` of your choosing
     * between those emissions. The first emission happens after the specified
     * `initialDelay`. The initial delay may be a {@link Date}. By default, this
     * operator uses the `async` IScheduler to provide a notion of time, but you
     * may pass any IScheduler to it. If `period` is not specified, the output
     * Observable emits only one value, `0`. Otherwise, it emits an infinite
     * sequence.
     *
     * @example <caption>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</caption>
     * var numbers = Rx.Observable.timer(3000, 1000);
     * numbers.subscribe(x => console.log(x));
     *
     * @example <caption>Emits one number after five seconds</caption>
     * var numbers = Rx.Observable.timer(5000);
     * numbers.subscribe(x => console.log(x));
     *
     * @see {@link interval}
     * @see {@link delay}
     *
     * @param {number|Date} [dueTime] The initial delay time to wait before
     * emitting the first value of `0`.
     * @param {number|SchedulerLike} [periodOrScheduler] The period of time between emissions of the
     * subsequent numbers.
     * @param {SchedulerLike} [scheduler=async] The IScheduler to use for scheduling
     * the emission of values, and providing a notion of "time".
     * @return {Observable} An Observable that emits a `0` after the
     * `initialDelay` and ever increasing numbers after each `period` of time
     * thereafter.
     * @static true
     * @name timer
     * @owner Observable
     */

    function timer(dueTime, periodOrScheduler, scheduler) {
      if (dueTime === void 0) {
        dueTime = 0;
      }

      var period = -1;

      if (isNumeric_1.isNumeric(periodOrScheduler)) {
        period = Number(periodOrScheduler) < 1 && 1 || Number(periodOrScheduler);
      } else if (isScheduler_1.isScheduler(periodOrScheduler)) {
        scheduler = periodOrScheduler;
      }

      if (!isScheduler_1.isScheduler(scheduler)) {
        scheduler = async$1.async;
      }

      return new Observable_1.Observable(function (subscriber) {
        var due = isNumeric_1.isNumeric(dueTime) ? dueTime : +dueTime - scheduler.now();
        return scheduler.schedule(dispatch, due, {
          index: 0,
          period: period,
          subscriber: subscriber
        });
      });
    }

    exports.timer = timer;

    function dispatch(state) {
      var index = state.index,
          period = state.period,
          subscriber = state.subscriber;
      subscriber.next(index);

      if (subscriber.closed) {
        return;
      } else if (period === -1) {
        return subscriber.complete();
      }

      state.index = index + 1;
      this.schedule(state, period);
    } 

  });
  unwrapExports(timer_1);
  var timer_2 = timer_1.timer;

  var using_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    }); // from from from! LAWL

    /**
     * Creates an Observable that uses a resource which will be disposed at the same time as the Observable.
     *
     * <span class="informal">Use it when you catch yourself cleaning up after an Observable.</span>
     *
     * `using` is a factory operator, which accepts two functions. First function returns a disposable resource.
     * It can be an arbitrary object that implements `unsubscribe` method. Second function will be injected with
     * that object and should return an Observable. That Observable can use resource object during its execution.
     * Both functions passed to `using` will be called every time someone subscribes - neither an Observable nor
     * resource object will be shared in any way between subscriptions.
     *
     * When Observable returned by `using` is subscribed, Observable returned from the second function will be subscribed
     * as well. All its notifications (nexted values, completion and error events) will be emitted unchanged by the output
     * Observable. If however someone unsubscribes from the Observable or source Observable completes or errors by itself,
     * the `unsubscribe` method on resource object will be called. This can be used to do any necessary clean up, which
     * otherwise would have to be handled by hand. Note that complete or error notifications are not emitted when someone
     * cancels subscription to an Observable via `unsubscribe`, so `using` can be used as a hook, allowing you to make
     * sure that all resources which need to exist during an Observable execution will be disposed at appropriate time.
     *
     * @see {@link defer}
     *
     * @param {function(): ISubscription} resourceFactory A function which creates any resource object
     * that implements `unsubscribe` method.
     * @param {function(resource: ISubscription): Observable<T>} observableFactory A function which
     * creates an Observable, that can use injected resource object.
     * @return {Observable<T>} An Observable that behaves the same as Observable returned by `observableFactory`, but
     * which - when completed, errored or unsubscribed - will also call `unsubscribe` on created resource object.
     */

    function using(resourceFactory, observableFactory) {
      return new Observable_1.Observable(function (subscriber) {
        var resource;

        try {
          resource = resourceFactory();
        } catch (err) {
          subscriber.error(err);
          return undefined;
        }

        var result;

        try {
          result = observableFactory(resource);
        } catch (err) {
          subscriber.error(err);
          return undefined;
        }

        var source = result ? from_1.from(result) : empty_1.EMPTY;
        var subscription = source.subscribe(subscriber);
        return function () {
          subscription.unsubscribe();

          if (resource) {
            resource.unsubscribe();
          }
        };
      });
    }

    exports.using = using; 
  });
  unwrapExports(using_1);
  var using_2 = using_1.using;

  var zip_1 = createCommonjsModule(function (module, exports) {

    var __extends = commonjsGlobal && commonjsGlobal.__extends || function () {
      var extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (b.hasOwnProperty(p)) d[p] = b[p];
        }
      };

      return function (d, b) {
        extendStatics(d, b);

        function __() {
          this.constructor = d;
        }

        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /* tslint:enable:max-line-length */

    /**
     * Combines multiple Observables to create an Observable whose values are calculated from the values, in order, of each
     * of its input Observables.
     *
     * If the latest parameter is a function, this function is used to compute the created value from the input values.
     * Otherwise, an array of the input values is returned.
     *
     * @example <caption>Combine age and name from different sources</caption>
     *
     * let age$ = Observable.of<number>(27, 25, 29);
     * let name$ = Observable.of<string>('Foo', 'Bar', 'Beer');
     * let isDev$ = Observable.of<boolean>(true, true, false);
     *
     * Observable
     *     .zip(age$,
     *          name$,
     *          isDev$,
     *          (age: number, name: string, isDev: boolean) => ({ age, name, isDev }))
     *     .subscribe(x => console.log(x));
     *
     * // outputs
     * // { age: 27, name: 'Foo', isDev: true }
     * // { age: 25, name: 'Bar', isDev: true }
     * // { age: 29, name: 'Beer', isDev: false }
     *
     * @param observables
     * @return {Observable<R>}
     * @static true
     * @name zip
     * @owner Observable
     */

    function zip() {
      var observables = [];

      for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
      }

      var project = observables[observables.length - 1];

      if (typeof project === 'function') {
        observables.pop();
      }

      return fromArray_1.fromArray(observables, undefined).lift(new ZipOperator(project));
    }

    exports.zip = zip;

    var ZipOperator =
    /** @class */
    function () {
      function ZipOperator(project) {
        this.project = project;
      }

      ZipOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ZipSubscriber(subscriber, this.project));
      };

      return ZipOperator;
    }();

    exports.ZipOperator = ZipOperator;
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */

    var ZipSubscriber =
    /** @class */
    function (_super) {
      __extends(ZipSubscriber, _super);

      function ZipSubscriber(destination, project, values) {
        if (values === void 0) {
          values = Object.create(null);
        }

        var _this = _super.call(this, destination) || this;

        _this.iterators = [];
        _this.active = 0;
        _this.project = typeof project === 'function' ? project : null;
        _this.values = values;
        return _this;
      }

      ZipSubscriber.prototype._next = function (value) {
        var iterators = this.iterators;

        if (isArray$1.isArray(value)) {
          iterators.push(new StaticArrayIterator(value));
        } else if (typeof value[iterator$1.iterator] === 'function') {
          iterators.push(new StaticIterator(value[iterator$1.iterator]()));
        } else {
          iterators.push(new ZipBufferIterator(this.destination, this, value));
        }
      };

      ZipSubscriber.prototype._complete = function () {
        var iterators = this.iterators;
        var len = iterators.length;

        if (len === 0) {
          this.destination.complete();
          return;
        }

        this.active = len;

        for (var i = 0; i < len; i++) {
          var iterator = iterators[i];

          if (iterator.stillUnsubscribed) {
            this.add(iterator.subscribe(iterator, i));
          } else {
            this.active--; // not an observable
          }
        }
      };

      ZipSubscriber.prototype.notifyInactive = function () {
        this.active--;

        if (this.active === 0) {
          this.destination.complete();
        }
      };

      ZipSubscriber.prototype.checkIterators = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        var destination = this.destination; // abort if not all of them have values

        for (var i = 0; i < len; i++) {
          var iterator = iterators[i];

          if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {
            return;
          }
        }

        var shouldComplete = false;
        var args = [];

        for (var i = 0; i < len; i++) {
          var iterator = iterators[i];
          var result = iterator.next(); // check to see if it's completed now that you've gotten
          // the next value.

          if (iterator.hasCompleted()) {
            shouldComplete = true;
          }

          if (result.done) {
            destination.complete();
            return;
          }

          args.push(result.value);
        }

        if (this.project) {
          this._tryProject(args);
        } else {
          destination.next(args);
        }

        if (shouldComplete) {
          destination.complete();
        }
      };

      ZipSubscriber.prototype._tryProject = function (args) {
        var result;

        try {
          result = this.project.apply(this, args);
        } catch (err) {
          this.destination.error(err);
          return;
        }

        this.destination.next(result);
      };

      return ZipSubscriber;
    }(Subscriber_1.Subscriber);

    exports.ZipSubscriber = ZipSubscriber;

    var StaticIterator =
    /** @class */
    function () {
      function StaticIterator(iterator) {
        this.iterator = iterator;
        this.nextResult = iterator.next();
      }

      StaticIterator.prototype.hasValue = function () {
        return true;
      };

      StaticIterator.prototype.next = function () {
        var result = this.nextResult;
        this.nextResult = this.iterator.next();
        return result;
      };

      StaticIterator.prototype.hasCompleted = function () {
        var nextResult = this.nextResult;
        return nextResult && nextResult.done;
      };

      return StaticIterator;
    }();

    var StaticArrayIterator =
    /** @class */
    function () {
      function StaticArrayIterator(array) {
        this.array = array;
        this.index = 0;
        this.length = 0;
        this.length = array.length;
      }

      StaticArrayIterator.prototype[iterator$1.iterator] = function () {
        return this;
      };

      StaticArrayIterator.prototype.next = function (value) {
        var i = this.index++;
        var array = this.array;
        return i < this.length ? {
          value: array[i],
          done: false
        } : {
          value: null,
          done: true
        };
      };

      StaticArrayIterator.prototype.hasValue = function () {
        return this.array.length > this.index;
      };

      StaticArrayIterator.prototype.hasCompleted = function () {
        return this.array.length === this.index;
      };

      return StaticArrayIterator;
    }();
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */


    var ZipBufferIterator =
    /** @class */
    function (_super) {
      __extends(ZipBufferIterator, _super);

      function ZipBufferIterator(destination, parent, observable) {
        var _this = _super.call(this, destination) || this;

        _this.parent = parent;
        _this.observable = observable;
        _this.stillUnsubscribed = true;
        _this.buffer = [];
        _this.isComplete = false;
        return _this;
      }

      ZipBufferIterator.prototype[iterator$1.iterator] = function () {
        return this;
      }; // NOTE: there is actually a name collision here with Subscriber.next and Iterator.next
      //    this is legit because `next()` will never be called by a subscription in this case.


      ZipBufferIterator.prototype.next = function () {
        var buffer = this.buffer;

        if (buffer.length === 0 && this.isComplete) {
          return {
            value: null,
            done: true
          };
        } else {
          return {
            value: buffer.shift(),
            done: false
          };
        }
      };

      ZipBufferIterator.prototype.hasValue = function () {
        return this.buffer.length > 0;
      };

      ZipBufferIterator.prototype.hasCompleted = function () {
        return this.buffer.length === 0 && this.isComplete;
      };

      ZipBufferIterator.prototype.notifyComplete = function () {
        if (this.buffer.length > 0) {
          this.isComplete = true;
          this.parent.notifyInactive();
        } else {
          this.destination.complete();
        }
      };

      ZipBufferIterator.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.buffer.push(innerValue);
        this.parent.checkIterators();
      };

      ZipBufferIterator.prototype.subscribe = function (value, index) {
        return subscribeToResult_1.subscribeToResult(this, this.observable, this, index);
      };

      return ZipBufferIterator;
    }(OuterSubscriber_1.OuterSubscriber); 

  });
  unwrapExports(zip_1);
  var zip_2 = zip_1.zip;
  var zip_3 = zip_1.ZipOperator;
  var zip_4 = zip_1.ZipSubscriber;

  var never = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /**
     * An Observable that emits no items to the Observer and never completes.
     *
     * <img src="./img/never.png" width="100%">
     *
     * A simple Observable that emits neither values nor errors nor the completion
     * notification. It can be used for testing purposes or for composing with other
     * Observables. Please note that by never emitting a complete notification, this
     * Observable keeps the subscription from being disposed automatically.
     * Subscriptions need to be manually disposed.
     *
     * @example <caption>Emit the number 7, then never emit anything else (not even complete).</caption>
     * function info() {
     *   console.log('Will not be called');
     * }
     * var result = NEVER.startWith(7);
     * result.subscribe(x => console.log(x), info, info);
     *
     * @see {@link create}
     * @see {@link EMPTY}
     * @see {@link of}
     * @see {@link throwError}
     */

    exports.NEVER = new Observable_1.Observable(noop_1.noop); 
  });
  unwrapExports(never);
  var never_1 = never.NEVER;

  var rxjs = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /* Observable */

    exports.Observable = Observable_1.Observable;
    exports.ConnectableObservable = ConnectableObservable_1.ConnectableObservable;
    exports.observable = observable$1.observable;
    /* Subjects */

    exports.Subject = Subject_1.Subject;
    exports.BehaviorSubject = BehaviorSubject_1.BehaviorSubject;
    exports.ReplaySubject = ReplaySubject_1.ReplaySubject;
    exports.AsyncSubject = AsyncSubject_1.AsyncSubject;
    /* Schedulers */

    exports.asapScheduler = asap.asap;
    exports.asyncScheduler = async$1.async;
    exports.queueScheduler = queue$2.queue;
    exports.animationFrameScheduler = animationFrame.animationFrame;
    exports.VirtualTimeScheduler = VirtualTimeScheduler_1.VirtualTimeScheduler;
    exports.VirtualAction = VirtualTimeScheduler_1.VirtualAction;
    /* Subscription */

    exports.Subscription = Subscription_1.Subscription;
    exports.Subscriber = Subscriber_1.Subscriber;
    /* Notification */

    exports.Notification = Notification_1.Notification;
    /* Utils */

    exports.pipe = pipe_1.pipe;
    exports.noop = noop_1.noop;
    exports.identity = identity_1.identity;
    /* Error types */

    exports.ArgumentOutOfRangeError = ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
    exports.EmptyError = EmptyError_1.EmptyError;
    exports.ObjectUnsubscribedError = ObjectUnsubscribedError_1.ObjectUnsubscribedError;
    exports.UnsubscriptionError = UnsubscriptionError_1.UnsubscriptionError;
    exports.TimeoutError = TimeoutError_1.TimeoutError;
    /* Static observable creation exports */

    exports.bindCallback = bindCallback_1.bindCallback;
    exports.bindNodeCallback = bindNodeCallback_1.bindNodeCallback;
    exports.combineLatest = combineLatest_1.combineLatest;
    exports.concat = concat_1.concat;
    exports.defer = defer_1.defer;
    exports.empty = empty_1.empty;
    exports.forkJoin = forkJoin_1.forkJoin;
    exports.from = from_1.from;
    exports.fromEvent = fromEvent_1.fromEvent;
    exports.fromEventPattern = fromEventPattern_1.fromEventPattern;
    exports.generate = generate_1.generate;
    exports.iif = iif_1.iif;
    exports.interval = interval_1.interval;
    exports.merge = merge_1.merge;
    exports.of = of_1.of;
    exports.onErrorResumeNext = onErrorResumeNext_1.onErrorResumeNext;
    exports.pairs = pairs_1.pairs;
    exports.race = race_1.race;
    exports.range = range_1.range;
    exports.throwError = throwError_1.throwError;
    exports.timer = timer_1.timer;
    exports.using = using_1.using;
    exports.zip = zip_1.zip;
    /* Constants */

    var empty_2 = empty_1;
    exports.EMPTY = empty_2.EMPTY;
    exports.NEVER = never.NEVER; 
  });
  unwrapExports(rxjs);
  var rxjs_1 = rxjs.Observable;
  var rxjs_2 = rxjs.ConnectableObservable;
  var rxjs_3 = rxjs.observable;
  var rxjs_4 = rxjs.Subject;
  var rxjs_5 = rxjs.BehaviorSubject;
  var rxjs_6 = rxjs.ReplaySubject;
  var rxjs_7 = rxjs.AsyncSubject;
  var rxjs_8 = rxjs.asapScheduler;
  var rxjs_9 = rxjs.asyncScheduler;
  var rxjs_10 = rxjs.queueScheduler;
  var rxjs_11 = rxjs.animationFrameScheduler;
  var rxjs_12 = rxjs.VirtualTimeScheduler;
  var rxjs_13 = rxjs.VirtualAction;
  var rxjs_14 = rxjs.Subscription;
  var rxjs_15 = rxjs.Subscriber;
  var rxjs_16 = rxjs.Notification;
  var rxjs_17 = rxjs.pipe;
  var rxjs_18 = rxjs.noop;
  var rxjs_19 = rxjs.identity;
  var rxjs_20 = rxjs.ArgumentOutOfRangeError;
  var rxjs_21 = rxjs.EmptyError;
  var rxjs_22 = rxjs.ObjectUnsubscribedError;
  var rxjs_23 = rxjs.UnsubscriptionError;
  var rxjs_24 = rxjs.TimeoutError;
  var rxjs_25 = rxjs.bindCallback;
  var rxjs_26 = rxjs.bindNodeCallback;
  var rxjs_27 = rxjs.combineLatest;
  var rxjs_28 = rxjs.concat;
  var rxjs_29 = rxjs.defer;
  var rxjs_30 = rxjs.empty;
  var rxjs_31 = rxjs.forkJoin;
  var rxjs_32 = rxjs.from;
  var rxjs_33 = rxjs.fromEvent;
  var rxjs_34 = rxjs.fromEventPattern;
  var rxjs_35 = rxjs.generate;
  var rxjs_36 = rxjs.iif;
  var rxjs_37 = rxjs.interval;
  var rxjs_38 = rxjs.merge;
  var rxjs_39 = rxjs.of;
  var rxjs_40 = rxjs.onErrorResumeNext;
  var rxjs_41 = rxjs.pairs;
  var rxjs_42 = rxjs.race;
  var rxjs_43 = rxjs.range;
  var rxjs_44 = rxjs.throwError;
  var rxjs_45 = rxjs.timer;
  var rxjs_46 = rxjs.using;
  var rxjs_47 = rxjs.zip;
  var rxjs_48 = rxjs.EMPTY;
  var rxjs_49 = rxjs.NEVER;

  var arraySlice = [].slice;
  var factories = {};

  var construct = function (F, len, args) {
    if (!(len in factories)) {
      for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']';
      // eslint-disable-next-line no-new-func
      factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
    } return factories[len](F, args);
  };

  var _bind = Function.bind || function bind(that /* , ...args */) {
    var fn = _aFunction(this);
    var partArgs = arraySlice.call(arguments, 1);
    var bound = function (/* args... */) {
      var args = partArgs.concat(arraySlice.call(arguments));
      return this instanceof bound ? construct(fn, args.length, args) : _invoke(fn, args, that);
    };
    if (_isObject(fn.prototype)) bound.prototype = fn.prototype;
    return bound;
  };

  // 26.1.2 Reflect.construct(target, argumentsList [, newTarget])







  var rConstruct = (_global.Reflect || {}).construct;

  // MS Edge supports only 2 arguments and argumentsList argument is optional
  // FF Nightly sets third argument as `new.target`, but does not create `this` from it
  var NEW_TARGET_BUG = _fails(function () {
    function F() { /* empty */ }
    return !(rConstruct(function () { /* empty */ }, [], F) instanceof F);
  });
  var ARGS_BUG = !_fails(function () {
    rConstruct(function () { /* empty */ });
  });

  _export(_export.S + _export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
    construct: function construct(Target, args /* , newTarget */) {
      _aFunction(Target);
      _anObject(args);
      var newTarget = arguments.length < 3 ? Target : _aFunction(arguments[2]);
      if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);
      if (Target == newTarget) {
        // w/o altered newTarget, optimization for 0-4 arguments
        switch (args.length) {
          case 0: return new Target();
          case 1: return new Target(args[0]);
          case 2: return new Target(args[0], args[1]);
          case 3: return new Target(args[0], args[1], args[2]);
          case 4: return new Target(args[0], args[1], args[2], args[3]);
        }
        // w/o altered newTarget, lot of arguments case
        var $args = [null];
        $args.push.apply($args, args);
        return new (_bind.apply(Target, $args))();
      }
      // with altered newTarget, not support built-in constructors
      var proto = newTarget.prototype;
      var instance = _objectCreate(_isObject(proto) ? proto : Object.prototype);
      var result = Function.apply.call(Target, instance, args);
      return _isObject(result) ? result : instance;
    }
  });

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    _setPrototypeOf(subClass.prototype, superClass && superClass.prototype);

    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.getPrototypeOf || function _getPrototypeOf(o) {
      return o.__proto__;
    };

    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null) break;
    }

    return object;
  }

  function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get;
    } else {
      _get = function _get(target, property, receiver) {
        var base = _superPropBase(target, property);

        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(receiver);
        }

        return desc.value;
      };
    }

    return _get(target, property, receiver || target);
  }

  var dP$3 = _objectDp.f;
  var FProto = Function.prototype;
  var nameRE = /^\s*function ([^ (]*)/;
  var NAME$1 = 'name';

  // 19.2.4.2 name
  NAME$1 in FProto || _descriptors && dP$3(FProto, NAME$1, {
    configurable: true,
    get: function () {
      try {
        return ('' + this).match(nameRE)[1];
      } catch (e) {
        return '';
      }
    }
  });

  var _fixReWks = function (KEY, length, exec) {
    var SYMBOL = _wks(KEY);
    var fns = exec(_defined, SYMBOL, ''[KEY]);
    var strfn = fns[0];
    var rxfn = fns[1];
    if (_fails(function () {
      var O = {};
      O[SYMBOL] = function () { return 7; };
      return ''[KEY](O) != 7;
    })) {
      _redefine(String.prototype, KEY, strfn);
      _hide(RegExp.prototype, SYMBOL, length == 2
        // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
        // 21.2.5.11 RegExp.prototype[@@split](string, limit)
        ? function (string, arg) { return rxfn.call(string, this, arg); }
        // 21.2.5.6 RegExp.prototype[@@match](string)
        // 21.2.5.9 RegExp.prototype[@@search](string)
        : function (string) { return rxfn.call(string, this); }
      );
    }
  };

  // 7.2.8 IsRegExp(argument)


  var MATCH = _wks('match');
  var _isRegexp = function (it) {
    var isRegExp;
    return _isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : _cof(it) == 'RegExp');
  };

  // @@split logic
  _fixReWks('split', 2, function (defined, SPLIT, $split) {
    var isRegExp = _isRegexp;
    var _split = $split;
    var $push = [].push;
    var $SPLIT = 'split';
    var LENGTH = 'length';
    var LAST_INDEX = 'lastIndex';
    if (
      'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
      'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
      'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
      '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
      '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
      ''[$SPLIT](/.?/)[LENGTH]
    ) {
      var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group
      // based on es5-shim implementation, need to rework it
      $split = function (separator, limit) {
        var string = String(this);
        if (separator === undefined && limit === 0) return [];
        // If `separator` is not a regex, use native split
        if (!isRegExp(separator)) return _split.call(string, separator, limit);
        var output = [];
        var flags = (separator.ignoreCase ? 'i' : '') +
                    (separator.multiline ? 'm' : '') +
                    (separator.unicode ? 'u' : '') +
                    (separator.sticky ? 'y' : '');
        var lastLastIndex = 0;
        var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;
        // Make `global` and avoid `lastIndex` issues by working with a copy
        var separatorCopy = new RegExp(separator.source, flags + 'g');
        var separator2, match, lastIndex, lastLength, i;
        // Doesn't need flags gy, but they don't hurt
        if (!NPCG) separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
        while (match = separatorCopy.exec(string)) {
          // `separatorCopy.lastIndex` is not reliable cross-browser
          lastIndex = match.index + match[0][LENGTH];
          if (lastIndex > lastLastIndex) {
            output.push(string.slice(lastLastIndex, match.index));
            // Fix browsers whose `exec` methods don't consistently return `undefined` for NPCG
            // eslint-disable-next-line no-loop-func
            if (!NPCG && match[LENGTH] > 1) match[0].replace(separator2, function () {
              for (i = 1; i < arguments[LENGTH] - 2; i++) if (arguments[i] === undefined) match[i] = undefined;
            });
            if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
            lastLength = match[0][LENGTH];
            lastLastIndex = lastIndex;
            if (output[LENGTH] >= splitLimit) break;
          }
          if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
        }
        if (lastLastIndex === string[LENGTH]) {
          if (lastLength || !separatorCopy.test('')) output.push('');
        } else output.push(string.slice(lastLastIndex));
        return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
      };
    // Chakra, V8
    } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
      $split = function (separator, limit) {
        return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);
      };
    }
    // 21.1.3.17 String.prototype.split(separator, limit)
    return [function split(separator, limit) {
      var O = defined(this);
      var fn = separator == undefined ? undefined : separator[SPLIT];
      return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);
    }, $split];
  });

  /**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   */
  // The first argument to JS template tags retain identity across multiple
  // calls to a tag for the same literal, so we can cache work done per literal
  // in a Map.
  var templateCaches = new Map();
  /**
   * Interprets a template literal as an HTML template that can efficiently
   * render to and update a container.
   */

  var html = function html(strings) {
    for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      values[_key - 1] = arguments[_key];
    }

    return new TemplateResult(strings, values, 'html');
  };
  /**
   * The return type of `html`, which holds a Template and the values from
   * interpolated expressions.
   */

  var TemplateResult =
  /*#__PURE__*/
  function () {
    function TemplateResult(strings, values, type) {
      var partCallback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : defaultPartCallback;

      _classCallCheck(this, TemplateResult);

      this.strings = strings;
      this.values = values;
      this.type = type;
      this.partCallback = partCallback;
    }
    /**
     * Returns a string of HTML used to create a <template> element.
     */


    _createClass(TemplateResult, [{
      key: "getHTML",
      value: function getHTML() {
        var l = this.strings.length - 1;
        var html = '';
        var isTextBinding = true;

        for (var i = 0; i < l; i++) {
          var s = this.strings[i];
          html += s; // We're in a text position if the previous string closed its tags.
          // If it doesn't have any tags, then we use the previous text position
          // state.

          var closing = findTagClose(s);
          isTextBinding = closing > -1 ? closing < s.length : isTextBinding;
          html += isTextBinding ? nodeMarker : marker;
        }

        html += this.strings[l];
        return html;
      }
    }, {
      key: "getTemplateElement",
      value: function getTemplateElement() {
        var template = document.createElement('template');
        template.innerHTML = this.getHTML();
        return template;
      }
    }]);

    return TemplateResult;
  }();
  /**
   * A TemplateResult for SVG fragments.
   *
   * This class wraps HTMl in an <svg> tag in order to parse its contents in the
   * SVG namespace, then modifies the template to remove the <svg> tag so that
   * clones only container the original fragment.
   */

  var SVGTemplateResult =
  /*#__PURE__*/
  function (_TemplateResult) {
    function SVGTemplateResult() {
      _classCallCheck(this, SVGTemplateResult);

      return _possibleConstructorReturn(this, _getPrototypeOf(SVGTemplateResult).apply(this, arguments));
    }

    _createClass(SVGTemplateResult, [{
      key: "getHTML",
      value: function getHTML() {
        return `<svg>${_get(_getPrototypeOf(SVGTemplateResult.prototype), "getHTML", this).call(this)}</svg>`;
      }
    }, {
      key: "getTemplateElement",
      value: function getTemplateElement() {
        var template = _get(_getPrototypeOf(SVGTemplateResult.prototype), "getTemplateElement", this).call(this);

        var content = template.content;
        var svgElement = content.firstChild;
        content.removeChild(svgElement);
        reparentNodes(content, svgElement.firstChild);
        return template;
      }
    }]);

    _inherits(SVGTemplateResult, _TemplateResult);

    return SVGTemplateResult;
  }(TemplateResult);
  /**
   * The default TemplateFactory which caches Templates keyed on
   * result.type and result.strings.
   */

  function defaultTemplateFactory(result) {
    var templateCache = templateCaches.get(result.type);

    if (templateCache === undefined) {
      templateCache = new Map();
      templateCaches.set(result.type, templateCache);
    }

    var template = templateCache.get(result.strings);

    if (template === undefined) {
      template = new Template(result, result.getTemplateElement());
      templateCache.set(result.strings, template);
    }

    return template;
  }
  /**
   * Renders a template to a container.
   *
   * To update a container with new values, reevaluate the template literal and
   * call `render` with the new result.
   *
   * @param result a TemplateResult created by evaluating a template tag like
   *     `html` or `svg`.
   * @param container A DOM parent to render to. The entire contents are either
   *     replaced, or efficiently updated if the same result type was previous
   *     rendered there.
   * @param templateFactory a function to create a Template or retreive one from
   *     cache.
   */

  function render(result, container) {
    var templateFactory = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultTemplateFactory;
    var template = templateFactory(result);
    var instance = container.__templateInstance; // Repeat render, just call update()

    if (instance !== undefined && instance.template === template && instance._partCallback === result.partCallback) {
      instance.update(result.values);
      return;
    } // First render, create a new TemplateInstance and append it


    instance = new TemplateInstance(template, result.partCallback, templateFactory);
    container.__templateInstance = instance;

    var fragment = instance._clone();

    instance.update(result.values);
    removeNodes(container, container.firstChild);
    container.appendChild(fragment);
  }
  /**
   * An expression marker with embedded unique key to avoid collision with
   * possible text in templates.
   */

  var marker = `{{lit-${String(Math.random()).slice(2)}}}`;
  /**
   * An expression marker used text-posisitions, not attribute positions,
   * in template.
   */

  var nodeMarker = `<!--${marker}-->`;
  var markerRegex = new RegExp(`${marker}|${nodeMarker}`);
  /**
   * This regex extracts the attribute name preceding an attribute-position
   * expression. It does this by matching the syntax allowed for attributes
   * against the string literal directly preceding the expression, assuming that
   * the expression is in an attribute-value position.
   *
   * See attributes in the HTML spec:
   * https://www.w3.org/TR/html5/syntax.html#attributes-0
   *
   * "\0-\x1F\x7F-\x9F" are Unicode control characters
   *
   * " \x09\x0a\x0c\x0d" are HTML space characters:
   * https://www.w3.org/TR/html5/infrastructure.html#space-character
   *
   * So an attribute is:
   *  * The name: any character except a control character, space character, ('),
   *    ("), ">", "=", or "/"
   *  * Followed by zero or more space characters
   *  * Followed by "="
   *  * Followed by zero or more space characters
   *  * Followed by:
   *    * Any character except space, ('), ("), "<", ">", "=", (`), or
   *    * (") then any non-("), or
   *    * (') then any non-(')
   */

  var lastAttributeNameRegex = /[ \x09\x0a\x0c\x0d]([^\0-\x1F\x7F-\x9F \x09\x0a\x0c\x0d"'>=/]+)[ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*)$/;
  /**
   * Finds the closing index of the last closed HTML tag.
   * This has 3 possible return values:
   *   - `-1`, meaning there is no tag in str.
   *   - `string.length`, meaning the last opened tag is unclosed.
   *   - Some positive number < str.length, meaning the index of the closing '>'.
   */

  function findTagClose(str) {
    var close = str.lastIndexOf('>');
    var open = str.indexOf('<', close + 1);
    return open > -1 ? str.length : close;
  }
  /**
   * A placeholder for a dynamic expression in an HTML template.
   *
   * There are two built-in part types: AttributePart and NodePart. NodeParts
   * always represent a single dynamic expression, while AttributeParts may
   * represent as many expressions are contained in the attribute.
   *
   * A Template's parts are mutable, so parts can be replaced or modified
   * (possibly to implement different template semantics). The contract is that
   * parts can only be replaced, not removed, added or reordered, and parts must
   * always consume the correct number of values in their `update()` method.
   *
   * TODO(justinfagnani): That requirement is a little fragile. A
   * TemplateInstance could instead be more careful about which values it gives
   * to Part.update().
   */


  var TemplatePart = function TemplatePart(type, index, name, rawName, strings) {
    _classCallCheck(this, TemplatePart);

    this.type = type;
    this.index = index;
    this.name = name;
    this.rawName = rawName;
    this.strings = strings;
  };
  /**
   * An updateable Template that tracks the location of dynamic parts.
   */

  var Template = function Template(result, element) {
    _classCallCheck(this, Template);

    this.parts = [];
    this.element = element;
    var content = this.element.content; // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null

    var walker = document.createTreeWalker(content, 133
    /* NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT |
    NodeFilter.SHOW_TEXT */
    , null, false);
    var index = -1;
    var partIndex = 0;
    var nodesToRemove = []; // The actual previous node, accounting for removals: if a node is removed
    // it will never be the previousNode.

    var previousNode; // Used to set previousNode at the top of the loop.

    var currentNode;

    while (walker.nextNode()) {
      index++;
      previousNode = currentNode;
      var node = currentNode = walker.currentNode;

      if (node.nodeType === 1
      /* Node.ELEMENT_NODE */
      ) {
          if (!node.hasAttributes()) {
            continue;
          }

          var attributes = node.attributes; // Per https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap,
          // attributes are not guaranteed to be returned in document order. In
          // particular, Edge/IE can return them out of order, so we cannot assume
          // a correspondance between part index and attribute index.

          var count = 0;

          for (var i = 0; i < attributes.length; i++) {
            if (attributes[i].value.indexOf(marker) >= 0) {
              count++;
            }
          }

          while (count-- > 0) {
            // Get the template literal section leading up to the first
            // expression in this attribute attribute
            var stringForPart = result.strings[partIndex]; // Find the attribute name

            var attributeNameInPart = lastAttributeNameRegex.exec(stringForPart)[1]; // Find the corresponding attribute
            // TODO(justinfagnani): remove non-null assertion

            var attribute = attributes.getNamedItem(attributeNameInPart);
            var stringsForAttributeValue = attribute.value.split(markerRegex);
            this.parts.push(new TemplatePart('attribute', index, attribute.name, attributeNameInPart, stringsForAttributeValue));
            node.removeAttribute(attribute.name);
            partIndex += stringsForAttributeValue.length - 1;
          }
        } else if (node.nodeType === 3
      /* Node.TEXT_NODE */
      ) {
          var nodeValue = node.nodeValue;

          if (nodeValue.indexOf(marker) < 0) {
            continue;
          }

          var parent = node.parentNode;
          var strings = nodeValue.split(markerRegex);
          var lastIndex = strings.length - 1; // We have a part for each match found

          partIndex += lastIndex; // Generate a new text node for each literal section
          // These nodes are also used as the markers for node parts

          for (var _i = 0; _i < lastIndex; _i++) {
            parent.insertBefore(strings[_i] === '' ? document.createComment('') : document.createTextNode(strings[_i]), node);
            this.parts.push(new TemplatePart('node', index++));
          }

          parent.insertBefore(strings[lastIndex] === '' ? document.createComment('') : document.createTextNode(strings[lastIndex]), node);
          nodesToRemove.push(node);
        } else if (node.nodeType === 8
      /* Node.COMMENT_NODE */
      && node.nodeValue === marker) {
        var _parent = node.parentNode; // Add a new marker node to be the startNode of the Part if any of the
        // following are true:
        //  * We don't have a previousSibling
        //  * previousSibling is being removed (thus it's not the
        //    `previousNode`)
        //  * previousSibling is not a Text node
        //
        // TODO(justinfagnani): We should be able to use the previousNode here
        // as the marker node and reduce the number of extra nodes we add to a
        // template. See https://github.com/PolymerLabs/lit-html/issues/147

        var previousSibling = node.previousSibling;

        if (previousSibling === null || previousSibling !== previousNode || previousSibling.nodeType !== Node.TEXT_NODE) {
          _parent.insertBefore(document.createComment(''), node);
        } else {
          index--;
        }

        this.parts.push(new TemplatePart('node', index++));
        nodesToRemove.push(node); // If we don't have a nextSibling add a marker node.
        // We don't have to check if the next node is going to be removed,
        // because that node will induce a new marker if so.

        if (node.nextSibling === null) {
          _parent.insertBefore(document.createComment(''), node);
        } else {
          index--;
        }

        currentNode = previousNode;
        partIndex++;
      }
    } // Remove text binding nodes after the walk to not disturb the TreeWalker


    for (var _i2 = 0; _i2 < nodesToRemove.length; _i2++) {
      var n = nodesToRemove[_i2];
      n.parentNode.removeChild(n);
    }
  };
  /**
   * Returns a value ready to be inserted into a Part from a user-provided value.
   *
   * If the user value is a directive, this invokes the directive with the given
   * part. If the value is null, it's converted to undefined to work better
   * with certain DOM APIs, like textContent.
   */

  var getValue = function getValue(part, value) {
    // `null` as the value of a Text node will render the string 'null'
    // so we convert it to undefined
    if (isDirective(value)) {
      value = value(part);
      return directiveValue;
    }

    return value === null ? undefined : value;
  };

  var isDirective = function isDirective(o) {
    return typeof o === 'function' && o.__litDirective === true;
  };
  /**
   * A sentinel value that signals that a value was handled by a directive and
   * should not be written to the DOM.
   */


  var directiveValue = {};

  var isPrimitiveValue = function isPrimitiveValue(value) {
    return value === null || !(typeof value === 'object' || typeof value === 'function');
  };

  var AttributePart =
  /*#__PURE__*/
  function () {
    function AttributePart(instance, element, name, strings) {
      _classCallCheck(this, AttributePart);

      this.instance = instance;
      this.element = element;
      this.name = name;
      this.strings = strings;
      this.size = strings.length - 1;
      this._previousValues = [];
    }

    _createClass(AttributePart, [{
      key: "_interpolate",
      value: function _interpolate(values, startIndex) {
        var strings = this.strings;
        var l = strings.length - 1;
        var text = '';

        for (var i = 0; i < l; i++) {
          text += strings[i];
          var v = getValue(this, values[startIndex + i]);

          if (v && v !== directiveValue && (Array.isArray(v) || typeof v !== 'string' && v[Symbol.iterator])) {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = v[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var t = _step.value;
                // TODO: we need to recursively call getValue into iterables...
                text += t;
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                  _iterator.return();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
          } else {
            text += v;
          }
        }

        return text + strings[l];
      }
    }, {
      key: "_equalToPreviousValues",
      value: function _equalToPreviousValues(values, startIndex) {
        for (var i = startIndex; i < startIndex + this.size; i++) {
          if (this._previousValues[i] !== values[i] || !isPrimitiveValue(values[i])) {
            return false;
          }
        }

        return true;
      }
    }, {
      key: "setValue",
      value: function setValue(values, startIndex) {
        if (this._equalToPreviousValues(values, startIndex)) {
          return;
        }

        var s = this.strings;
        var value;

        if (s.length === 2 && s[0] === '' && s[1] === '') {
          // An expression that occupies the whole attribute value will leave
          // leading and trailing empty strings.
          value = getValue(this, values[startIndex]);

          if (Array.isArray(value)) {
            value = value.join('');
          }
        } else {
          value = this._interpolate(values, startIndex);
        }

        if (value !== directiveValue) {
          this.element.setAttribute(this.name, value);
        }

        this._previousValues = values;
      }
    }]);

    return AttributePart;
  }();
  var NodePart =
  /*#__PURE__*/
  function () {
    function NodePart(instance, startNode, endNode) {
      _classCallCheck(this, NodePart);

      this.instance = instance;
      this.startNode = startNode;
      this.endNode = endNode;
      this._previousValue = undefined;
    }

    _createClass(NodePart, [{
      key: "setValue",
      value: function setValue(value) {
        value = getValue(this, value);

        if (value === directiveValue) {
          return;
        }

        if (isPrimitiveValue(value)) {
          // Handle primitive values
          // If the value didn't change, do nothing
          if (value === this._previousValue) {
            return;
          }

          this._setText(value);
        } else if (value instanceof TemplateResult) {
          this._setTemplateResult(value);
        } else if (Array.isArray(value) || value[Symbol.iterator]) {
          this._setIterable(value);
        } else if (value instanceof Node) {
          this._setNode(value);
        } else if (value.then !== undefined) {
          this._setPromise(value);
        } else {
          // Fallback, will render the string representation
          this._setText(value);
        }
      }
    }, {
      key: "_insert",
      value: function _insert(node) {
        this.endNode.parentNode.insertBefore(node, this.endNode);
      }
    }, {
      key: "_setNode",
      value: function _setNode(value) {
        if (this._previousValue === value) {
          return;
        }

        this.clear();

        this._insert(value);

        this._previousValue = value;
      }
    }, {
      key: "_setText",
      value: function _setText(value) {
        var node = this.startNode.nextSibling;
        value = value === undefined ? '' : value;

        if (node === this.endNode.previousSibling && node.nodeType === Node.TEXT_NODE) {
          // If we only have a single text node between the markers, we can just
          // set its value, rather than replacing it.
          // TODO(justinfagnani): Can we just check if _previousValue is
          // primitive?
          node.textContent = value;
        } else {
          this._setNode(document.createTextNode(value));
        }

        this._previousValue = value;
      }
    }, {
      key: "_setTemplateResult",
      value: function _setTemplateResult(value) {
        var template = this.instance._getTemplate(value);

        var instance;

        if (this._previousValue && this._previousValue.template === template) {
          instance = this._previousValue;
        } else {
          instance = new TemplateInstance(template, this.instance._partCallback, this.instance._getTemplate);

          this._setNode(instance._clone());

          this._previousValue = instance;
        }

        instance.update(value.values);
      }
    }, {
      key: "_setIterable",
      value: function _setIterable(value) {
        // For an Iterable, we create a new InstancePart per item, then set its
        // value to the item. This is a little bit of overhead for every item in
        // an Iterable, but it lets us recurse easily and efficiently update Arrays
        // of TemplateResults that will be commonly returned from expressions like:
        // array.map((i) => html`${i}`), by reusing existing TemplateInstances.
        // If _previousValue is an array, then the previous render was of an
        // iterable and _previousValue will contain the NodeParts from the previous
        // render. If _previousValue is not an array, clear this part and make a new
        // array for NodeParts.
        if (!Array.isArray(this._previousValue)) {
          this.clear();
          this._previousValue = [];
        } // Lets us keep track of how many items we stamped so we can clear leftover
        // items from a previous render


        var itemParts = this._previousValue;
        var partIndex = 0;
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = value[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var item = _step2.value;
            // Try to reuse an existing part
            var itemPart = itemParts[partIndex]; // If no existing part, create a new one

            if (itemPart === undefined) {
              // If we're creating the first item part, it's startNode should be the
              // container's startNode
              var itemStart = this.startNode; // If we're not creating the first part, create a new separator marker
              // node, and fix up the previous part's endNode to point to it

              if (partIndex > 0) {
                var previousPart = itemParts[partIndex - 1];
                itemStart = previousPart.endNode = document.createTextNode('');

                this._insert(itemStart);
              }

              itemPart = new NodePart(this.instance, itemStart, this.endNode);
              itemParts.push(itemPart);
            }

            itemPart.setValue(item);
            partIndex++;
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        if (partIndex === 0) {
          this.clear();
          this._previousValue = undefined;
        } else if (partIndex < itemParts.length) {
          var lastPart = itemParts[partIndex - 1]; // Truncate the parts array so _previousValue reflects the current state

          itemParts.length = partIndex;
          this.clear(lastPart.endNode.previousSibling);
          lastPart.endNode = this.endNode;
        }
      }
    }, {
      key: "_setPromise",
      value: function _setPromise(value) {
        var _this = this;

        this._previousValue = value;
        value.then(function (v) {
          if (_this._previousValue === value) {
            _this.setValue(v);
          }
        });
      }
    }, {
      key: "clear",
      value: function clear() {
        var startNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.startNode;
        removeNodes(this.startNode.parentNode, startNode.nextSibling, this.endNode);
      }
    }]);

    return NodePart;
  }();
  var defaultPartCallback = function defaultPartCallback(instance, templatePart, node) {
    if (templatePart.type === 'attribute') {
      return new AttributePart(instance, node, templatePart.name, templatePart.strings);
    } else if (templatePart.type === 'node') {
      return new NodePart(instance, node, node.nextSibling);
    }

    throw new Error(`Unknown part type ${templatePart.type}`);
  };
  /**
   * An instance of a `Template` that can be attached to the DOM and updated
   * with new values.
   */

  var TemplateInstance =
  /*#__PURE__*/
  function () {
    function TemplateInstance(template, partCallback, getTemplate) {
      _classCallCheck(this, TemplateInstance);

      this._parts = [];
      this.template = template;
      this._partCallback = partCallback;
      this._getTemplate = getTemplate;
    }

    _createClass(TemplateInstance, [{
      key: "update",
      value: function update(values) {
        var valueIndex = 0;
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = this._parts[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var part = _step3.value;

            if (part.size === undefined) {
              part.setValue(values[valueIndex]);
              valueIndex++;
            } else {
              part.setValue(values, valueIndex);
              valueIndex += part.size;
            }
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
      }
    }, {
      key: "_clone",
      value: function _clone() {
        var fragment = document.importNode(this.template.element.content, true);
        var parts = this.template.parts;

        if (parts.length > 0) {
          // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be
          // null
          var _walker = document.createTreeWalker(fragment, 133
          /* NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT |
          NodeFilter.SHOW_TEXT */
          , null, false);

          var _index = -1;

          for (var i = 0; i < parts.length; i++) {
            var part = parts[i];

            while (_index < part.index) {
              _index++;

              _walker.nextNode();
            }

            this._parts.push(this._partCallback(this, part, _walker.currentNode));
          }
        }

        return fragment;
      }
    }]);

    return TemplateInstance;
  }();
  /**
   * Reparents nodes, starting from `startNode` (inclusive) to `endNode`
   * (exclusive), into another container (could be the same container), before
   * `beforeNode`. If `beforeNode` is null, it appends the nodes to the
   * container.
   */

  var reparentNodes = function reparentNodes(container, start) {
    var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var before = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var node = start;

    while (node !== end) {
      var n = node.nextSibling;
      container.insertBefore(node, before);
      node = n;
    }
  };
  /**
   * Removes nodes, starting from `startNode` (inclusive) to `endNode`
   * (exclusive), from `container`.
   */

  var removeNodes = function removeNodes(container, startNode) {
    var endNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var node = startNode;

    while (node !== endNode) {
      var n = node.nextSibling;
      container.removeChild(node);
      node = n;
    }
  };

  var shadyTemplateFactory = function shadyTemplateFactory(scopeName) {
    return function (result) {
      var cacheKey = `${result.type}--${scopeName}`;
      var templateCache = templateCaches.get(cacheKey);

      if (templateCache === undefined) {
        templateCache = new Map();
        templateCaches.set(cacheKey, templateCache);
      }

      var template = templateCache.get(result.strings);

      if (template === undefined) {
        var element = result.getTemplateElement();

        if (typeof window.ShadyCSS === 'object') {
          window.ShadyCSS.prepareTemplate(element, scopeName);
        }

        template = new Template(result, element);
        templateCache.set(result.strings, template);
      }

      return template;
    };
  };

  function render$1(result, container, scopeName) {
    return render(result, container, shadyTemplateFactory(scopeName));
  }

  function _CustomElement() {
    return Reflect.construct(HTMLElement, [], this.__proto__.constructor);
  }
  Object.setPrototypeOf(_CustomElement.prototype, HTMLElement.prototype);
  Object.setPrototypeOf(_CustomElement, HTMLElement);

  function template() {
    return html`
<style>
:host {
  display: block;
  position: absolute;
  z-index: 1;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  
  background-repeat: no-repeat !important;
  background-size: cover !important;
  background-position: center center !important;
}
</style>
`;
  }

  var TalkieBackfaceAttributes;

  (function (TalkieBackfaceAttributes) {
    TalkieBackfaceAttributes["IMAGE"] = "image";
    TalkieBackfaceAttributes["FILTER"] = "filter";
  })(TalkieBackfaceAttributes || (TalkieBackfaceAttributes = {}));

  var TalkieBackface =
  /*#__PURE__*/
  function (_CustomElement2) {
    function TalkieBackface() {
      _classCallCheck(this, TalkieBackface);

      return _possibleConstructorReturn(this, _getPrototypeOf(TalkieBackface).apply(this, arguments));
    }

    _createClass(TalkieBackface, [{
      key: "connectedCallback",
      value: function connectedCallback() {
        this.attachShadow({
          mode: 'open'
        });
        this.render();
      }
    }, {
      key: "attributeChangedCallback",
      value: function attributeChangedCallback() {
        var imageUrl = this.getAttribute(TalkieBackfaceAttributes.IMAGE) || '';
        var filterDecl = this.getAttribute(TalkieBackfaceAttributes.FILTER) || '';

        if (imageUrl) {
          var style = `background-image: url(${imageUrl});background-color: transparent;filter: ${filterDecl ? filterDecl : 'none'};`;
          this.setAttribute('style', style);
        } else {
          this.removeAttribute('style');
        }
      }
    }, {
      key: "render",
      value: function render$$1() {
        if (this.shadowRoot == null) {
          throw new Error('shadowRoot not initialized yet');
        }

        render$1(template(), this.shadowRoot, TalkieBackface.ns);
      }
    }], [{
      key: "ns",
      get: function get() {
        return 'tk-backface';
      }
    }, {
      key: "observedAttributes",
      get: function get() {
        return [TalkieBackfaceAttributes.IMAGE, TalkieBackfaceAttributes.FILTER];
      }
    }]);

    _inherits(TalkieBackface, _CustomElement2);

    return TalkieBackface;
  }(_CustomElement);

  function _CustomElement$1() {
    return Reflect.construct(HTMLElement, [], this.__proto__.constructor);
  }
  Object.setPrototypeOf(_CustomElement$1.prototype, HTMLElement.prototype);
  Object.setPrototypeOf(_CustomElement$1, HTMLElement);

  function template$1(_ref) {
    var current = _ref.current,
        total = _ref.total;
    return html`
<style>
:host {
  position: fixed;
  z-index: 3;
  bottom: 0;
  right: 0;
  padding: 20px;
  color: hotpink;
  font-family: Consolas, Monaco, 'Andale Mono', monospace;
}

.next, .prev {
  background: none;
  border: none;
  cursor: pointer;
  width: 0;
  height: 0;
  border: 10px solid transparent;
  padding: 0;
  vertical-align: middle;
}

.next {
  border-left-width: 20px;
  border-left-color: hotpink;
}

.prev {
  border-right-width: 20px;
  border-right-color: hotpink;
}
</style>

<nav>
  <p>
    <button class="prev" aria-label="Prev Slide"></button>
    Page ${current} of ${total}
    <button class="next" aria-label="Next Slide"></button>
  </p>
</nav>
`;
  }

  var TalkiePagerAttributes;

  (function (TalkiePagerAttributes) {
    TalkiePagerAttributes["TOTAL"] = "total";
    TalkiePagerAttributes["CURRENT"] = "current";
  })(TalkiePagerAttributes || (TalkiePagerAttributes = {}));

  var TalkiePager =
  /*#__PURE__*/
  function (_CustomElement2) {
    _createClass(TalkiePager, null, [{
      key: "ns",
      get: function get() {
        return 'tk-pager';
      }
    }, {
      key: "observedAttributes",
      get: function get() {
        return [TalkiePagerAttributes.TOTAL, TalkiePagerAttributes.CURRENT];
      }
    }]);

    function TalkiePager() {
      _classCallCheck(this, TalkiePager);

      return _possibleConstructorReturn(this, _getPrototypeOf(TalkiePager).call(this));
    }

    _createClass(TalkiePager, [{
      key: "connectedCallback",
      value: function connectedCallback() {
        this.attachShadow({
          mode: 'open'
        });
        this.render();
      }
    }, {
      key: "attributeChangedCallback",
      value: function attributeChangedCallback() {
        this.render();
      }
    }, {
      key: "render",
      value: function render$$1() {
        if (this.shadowRoot == null) {
          throw new Error('shadowRoot not initialized yet');
        }

        var current = this.getAttribute(TalkiePagerAttributes.CURRENT) || '0';
        var total = this.getAttribute(TalkiePagerAttributes.TOTAL) || '0';

        render$1(template$1({
          current: current,
          total: total
        }), this.shadowRoot, TalkiePager.ns);
      }
    }]);

    _inherits(TalkiePager, _CustomElement2);

    return TalkiePager;
  }(_CustomElement$1);

  function _CustomElement$2() {
    return Reflect.construct(HTMLElement, [], this.__proto__.constructor);
  }
  Object.setPrototypeOf(_CustomElement$2.prototype, HTMLElement.prototype);
  Object.setPrototypeOf(_CustomElement$2, HTMLElement);

  function template$2() {
    return html`
<style>
:host {
  display: block;
  position: fixed;
  z-index: 4;
  bottom: 0;
  left: 0;
  width: 0%;
  height: 0.2em;
  background-color: darkgray;
}
</style>
`;
  }

  var TalkieProgressAttributes;

  (function (TalkieProgressAttributes) {
    TalkieProgressAttributes["PROGRESS"] = "progress";
  })(TalkieProgressAttributes || (TalkieProgressAttributes = {}));

  var TalkieProgress =
  /*#__PURE__*/
  function (_CustomElement2) {
    function TalkieProgress() {
      _classCallCheck(this, TalkieProgress);

      return _possibleConstructorReturn(this, _getPrototypeOf(TalkieProgress).apply(this, arguments));
    }

    _createClass(TalkieProgress, [{
      key: "connectedCallback",
      value: function connectedCallback() {
        this.attachShadow({
          mode: 'open'
        });
        this.render();
      }
    }, {
      key: "attributeChangedCallback",
      value: function attributeChangedCallback() {
        var progress = this.getAttribute(TalkieProgressAttributes.PROGRESS) || '0';
        this.setAttribute('style', `width: ${progress}%;`);
      }
    }, {
      key: "render",
      value: function render$$1() {
        if (this.shadowRoot == null) {
          throw new Error('shadowRoot not initialized yet');
        }

        render$1(template$2(), this.shadowRoot, TalkieProgress.ns);
      }
    }], [{
      key: "ns",
      get: function get() {
        return 'tk-progress';
      }
    }, {
      key: "observedAttributes",
      get: function get() {
        return [TalkieProgressAttributes.PROGRESS];
      }
    }]);

    _inherits(TalkieProgress, _CustomElement2);

    return TalkieProgress;
  }(_CustomElement$2);

  // https://github.com/tc39/Array.prototype.includes

  var $includes = _arrayIncludes(true);

  _export(_export.P, 'Array', {
    includes: function includes(el /* , fromIndex = 0 */) {
      return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
    }
  });

  _addToUnscopables('includes');

  // @@replace logic
  _fixReWks('replace', 2, function (defined, REPLACE, $replace) {
    // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)
    return [function replace(searchValue, replaceValue) {
      var O = defined(this);
      var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
      return fn !== undefined
        ? fn.call(searchValue, O, replaceValue)
        : $replace.call(String(O), searchValue, replaceValue);
    }, $replace];
  });

  var Aacute = "Á";
  var aacute = "á";
  var Abreve = "Ă";
  var abreve = "ă";
  var ac = "∾";
  var acd = "∿";
  var acE = "∾̳";
  var Acirc = "Â";
  var acirc = "â";
  var acute = "´";
  var Acy = "А";
  var acy = "а";
  var AElig = "Æ";
  var aelig = "æ";
  var af = "⁡";
  var Afr = "𝔄";
  var afr = "𝔞";
  var Agrave = "À";
  var agrave = "à";
  var alefsym = "ℵ";
  var aleph = "ℵ";
  var Alpha = "Α";
  var alpha = "α";
  var Amacr = "Ā";
  var amacr = "ā";
  var amalg = "⨿";
  var amp = "&";
  var AMP = "&";
  var andand = "⩕";
  var And = "⩓";
  var and = "∧";
  var andd = "⩜";
  var andslope = "⩘";
  var andv = "⩚";
  var ang = "∠";
  var ange = "⦤";
  var angle = "∠";
  var angmsdaa = "⦨";
  var angmsdab = "⦩";
  var angmsdac = "⦪";
  var angmsdad = "⦫";
  var angmsdae = "⦬";
  var angmsdaf = "⦭";
  var angmsdag = "⦮";
  var angmsdah = "⦯";
  var angmsd = "∡";
  var angrt = "∟";
  var angrtvb = "⊾";
  var angrtvbd = "⦝";
  var angsph = "∢";
  var angst = "Å";
  var angzarr = "⍼";
  var Aogon = "Ą";
  var aogon = "ą";
  var Aopf = "𝔸";
  var aopf = "𝕒";
  var apacir = "⩯";
  var ap = "≈";
  var apE = "⩰";
  var ape = "≊";
  var apid = "≋";
  var apos = "'";
  var ApplyFunction = "⁡";
  var approx = "≈";
  var approxeq = "≊";
  var Aring = "Å";
  var aring = "å";
  var Ascr = "𝒜";
  var ascr = "𝒶";
  var Assign = "≔";
  var ast = "*";
  var asymp = "≈";
  var asympeq = "≍";
  var Atilde = "Ã";
  var atilde = "ã";
  var Auml = "Ä";
  var auml = "ä";
  var awconint = "∳";
  var awint = "⨑";
  var backcong = "≌";
  var backepsilon = "϶";
  var backprime = "‵";
  var backsim = "∽";
  var backsimeq = "⋍";
  var Backslash = "∖";
  var Barv = "⫧";
  var barvee = "⊽";
  var barwed = "⌅";
  var Barwed = "⌆";
  var barwedge = "⌅";
  var bbrk = "⎵";
  var bbrktbrk = "⎶";
  var bcong = "≌";
  var Bcy = "Б";
  var bcy = "б";
  var bdquo = "„";
  var becaus = "∵";
  var because = "∵";
  var Because = "∵";
  var bemptyv = "⦰";
  var bepsi = "϶";
  var bernou = "ℬ";
  var Bernoullis = "ℬ";
  var Beta = "Β";
  var beta = "β";
  var beth = "ℶ";
  var between = "≬";
  var Bfr = "𝔅";
  var bfr = "𝔟";
  var bigcap = "⋂";
  var bigcirc = "◯";
  var bigcup = "⋃";
  var bigodot = "⨀";
  var bigoplus = "⨁";
  var bigotimes = "⨂";
  var bigsqcup = "⨆";
  var bigstar = "★";
  var bigtriangledown = "▽";
  var bigtriangleup = "△";
  var biguplus = "⨄";
  var bigvee = "⋁";
  var bigwedge = "⋀";
  var bkarow = "⤍";
  var blacklozenge = "⧫";
  var blacksquare = "▪";
  var blacktriangle = "▴";
  var blacktriangledown = "▾";
  var blacktriangleleft = "◂";
  var blacktriangleright = "▸";
  var blank = "␣";
  var blk12 = "▒";
  var blk14 = "░";
  var blk34 = "▓";
  var block = "█";
  var bne = "=⃥";
  var bnequiv = "≡⃥";
  var bNot = "⫭";
  var bnot = "⌐";
  var Bopf = "𝔹";
  var bopf = "𝕓";
  var bot = "⊥";
  var bottom = "⊥";
  var bowtie = "⋈";
  var boxbox = "⧉";
  var boxdl = "┐";
  var boxdL = "╕";
  var boxDl = "╖";
  var boxDL = "╗";
  var boxdr = "┌";
  var boxdR = "╒";
  var boxDr = "╓";
  var boxDR = "╔";
  var boxh = "─";
  var boxH = "═";
  var boxhd = "┬";
  var boxHd = "╤";
  var boxhD = "╥";
  var boxHD = "╦";
  var boxhu = "┴";
  var boxHu = "╧";
  var boxhU = "╨";
  var boxHU = "╩";
  var boxminus = "⊟";
  var boxplus = "⊞";
  var boxtimes = "⊠";
  var boxul = "┘";
  var boxuL = "╛";
  var boxUl = "╜";
  var boxUL = "╝";
  var boxur = "└";
  var boxuR = "╘";
  var boxUr = "╙";
  var boxUR = "╚";
  var boxv = "│";
  var boxV = "║";
  var boxvh = "┼";
  var boxvH = "╪";
  var boxVh = "╫";
  var boxVH = "╬";
  var boxvl = "┤";
  var boxvL = "╡";
  var boxVl = "╢";
  var boxVL = "╣";
  var boxvr = "├";
  var boxvR = "╞";
  var boxVr = "╟";
  var boxVR = "╠";
  var bprime = "‵";
  var breve = "˘";
  var Breve = "˘";
  var brvbar = "¦";
  var bscr = "𝒷";
  var Bscr = "ℬ";
  var bsemi = "⁏";
  var bsim = "∽";
  var bsime = "⋍";
  var bsolb = "⧅";
  var bsol = "\\";
  var bsolhsub = "⟈";
  var bull = "•";
  var bullet = "•";
  var bump = "≎";
  var bumpE = "⪮";
  var bumpe = "≏";
  var Bumpeq = "≎";
  var bumpeq = "≏";
  var Cacute = "Ć";
  var cacute = "ć";
  var capand = "⩄";
  var capbrcup = "⩉";
  var capcap = "⩋";
  var cap = "∩";
  var Cap = "⋒";
  var capcup = "⩇";
  var capdot = "⩀";
  var CapitalDifferentialD = "ⅅ";
  var caps = "∩︀";
  var caret = "⁁";
  var caron = "ˇ";
  var Cayleys = "ℭ";
  var ccaps = "⩍";
  var Ccaron = "Č";
  var ccaron = "č";
  var Ccedil = "Ç";
  var ccedil = "ç";
  var Ccirc = "Ĉ";
  var ccirc = "ĉ";
  var Cconint = "∰";
  var ccups = "⩌";
  var ccupssm = "⩐";
  var Cdot = "Ċ";
  var cdot = "ċ";
  var cedil = "¸";
  var Cedilla = "¸";
  var cemptyv = "⦲";
  var cent = "¢";
  var centerdot = "·";
  var CenterDot = "·";
  var cfr = "𝔠";
  var Cfr = "ℭ";
  var CHcy = "Ч";
  var chcy = "ч";
  var check$1 = "✓";
  var checkmark = "✓";
  var Chi = "Χ";
  var chi = "χ";
  var circ = "ˆ";
  var circeq = "≗";
  var circlearrowleft = "↺";
  var circlearrowright = "↻";
  var circledast = "⊛";
  var circledcirc = "⊚";
  var circleddash = "⊝";
  var CircleDot = "⊙";
  var circledR = "®";
  var circledS = "Ⓢ";
  var CircleMinus = "⊖";
  var CirclePlus = "⊕";
  var CircleTimes = "⊗";
  var cir = "○";
  var cirE = "⧃";
  var cire = "≗";
  var cirfnint = "⨐";
  var cirmid = "⫯";
  var cirscir = "⧂";
  var ClockwiseContourIntegral = "∲";
  var CloseCurlyDoubleQuote = "”";
  var CloseCurlyQuote = "’";
  var clubs = "♣";
  var clubsuit = "♣";
  var colon = ":";
  var Colon = "∷";
  var Colone = "⩴";
  var colone = "≔";
  var coloneq = "≔";
  var comma = ",";
  var commat = "@";
  var comp = "∁";
  var compfn = "∘";
  var complement = "∁";
  var complexes = "ℂ";
  var cong = "≅";
  var congdot = "⩭";
  var Congruent = "≡";
  var conint = "∮";
  var Conint = "∯";
  var ContourIntegral = "∮";
  var copf = "𝕔";
  var Copf = "ℂ";
  var coprod = "∐";
  var Coproduct = "∐";
  var copy = "©";
  var COPY = "©";
  var copysr = "℗";
  var CounterClockwiseContourIntegral = "∳";
  var crarr = "↵";
  var cross = "✗";
  var Cross = "⨯";
  var Cscr = "𝒞";
  var cscr = "𝒸";
  var csub = "⫏";
  var csube = "⫑";
  var csup = "⫐";
  var csupe = "⫒";
  var ctdot = "⋯";
  var cudarrl = "⤸";
  var cudarrr = "⤵";
  var cuepr = "⋞";
  var cuesc = "⋟";
  var cularr = "↶";
  var cularrp = "⤽";
  var cupbrcap = "⩈";
  var cupcap = "⩆";
  var CupCap = "≍";
  var cup = "∪";
  var Cup = "⋓";
  var cupcup = "⩊";
  var cupdot = "⊍";
  var cupor = "⩅";
  var cups = "∪︀";
  var curarr = "↷";
  var curarrm = "⤼";
  var curlyeqprec = "⋞";
  var curlyeqsucc = "⋟";
  var curlyvee = "⋎";
  var curlywedge = "⋏";
  var curren = "¤";
  var curvearrowleft = "↶";
  var curvearrowright = "↷";
  var cuvee = "⋎";
  var cuwed = "⋏";
  var cwconint = "∲";
  var cwint = "∱";
  var cylcty = "⌭";
  var dagger = "†";
  var Dagger = "‡";
  var daleth = "ℸ";
  var darr = "↓";
  var Darr = "↡";
  var dArr = "⇓";
  var dash = "‐";
  var Dashv = "⫤";
  var dashv = "⊣";
  var dbkarow = "⤏";
  var dblac = "˝";
  var Dcaron = "Ď";
  var dcaron = "ď";
  var Dcy = "Д";
  var dcy = "д";
  var ddagger = "‡";
  var ddarr = "⇊";
  var DD = "ⅅ";
  var dd = "ⅆ";
  var DDotrahd = "⤑";
  var ddotseq = "⩷";
  var deg = "°";
  var Del = "∇";
  var Delta = "Δ";
  var delta = "δ";
  var demptyv = "⦱";
  var dfisht = "⥿";
  var Dfr = "𝔇";
  var dfr = "𝔡";
  var dHar = "⥥";
  var dharl = "⇃";
  var dharr = "⇂";
  var DiacriticalAcute = "´";
  var DiacriticalDot = "˙";
  var DiacriticalDoubleAcute = "˝";
  var DiacriticalGrave = "`";
  var DiacriticalTilde = "˜";
  var diam = "⋄";
  var diamond = "⋄";
  var Diamond = "⋄";
  var diamondsuit = "♦";
  var diams = "♦";
  var die = "¨";
  var DifferentialD = "ⅆ";
  var digamma = "ϝ";
  var disin = "⋲";
  var div = "÷";
  var divide = "÷";
  var divideontimes = "⋇";
  var divonx = "⋇";
  var DJcy = "Ђ";
  var djcy = "ђ";
  var dlcorn = "⌞";
  var dlcrop = "⌍";
  var dollar = "$";
  var Dopf = "𝔻";
  var dopf = "𝕕";
  var Dot = "¨";
  var dot = "˙";
  var DotDot = "⃜";
  var doteq = "≐";
  var doteqdot = "≑";
  var DotEqual = "≐";
  var dotminus = "∸";
  var dotplus = "∔";
  var dotsquare = "⊡";
  var doublebarwedge = "⌆";
  var DoubleContourIntegral = "∯";
  var DoubleDot = "¨";
  var DoubleDownArrow = "⇓";
  var DoubleLeftArrow = "⇐";
  var DoubleLeftRightArrow = "⇔";
  var DoubleLeftTee = "⫤";
  var DoubleLongLeftArrow = "⟸";
  var DoubleLongLeftRightArrow = "⟺";
  var DoubleLongRightArrow = "⟹";
  var DoubleRightArrow = "⇒";
  var DoubleRightTee = "⊨";
  var DoubleUpArrow = "⇑";
  var DoubleUpDownArrow = "⇕";
  var DoubleVerticalBar = "∥";
  var DownArrowBar = "⤓";
  var downarrow = "↓";
  var DownArrow = "↓";
  var Downarrow = "⇓";
  var DownArrowUpArrow = "⇵";
  var DownBreve = "̑";
  var downdownarrows = "⇊";
  var downharpoonleft = "⇃";
  var downharpoonright = "⇂";
  var DownLeftRightVector = "⥐";
  var DownLeftTeeVector = "⥞";
  var DownLeftVectorBar = "⥖";
  var DownLeftVector = "↽";
  var DownRightTeeVector = "⥟";
  var DownRightVectorBar = "⥗";
  var DownRightVector = "⇁";
  var DownTeeArrow = "↧";
  var DownTee = "⊤";
  var drbkarow = "⤐";
  var drcorn = "⌟";
  var drcrop = "⌌";
  var Dscr = "𝒟";
  var dscr = "𝒹";
  var DScy = "Ѕ";
  var dscy = "ѕ";
  var dsol = "⧶";
  var Dstrok = "Đ";
  var dstrok = "đ";
  var dtdot = "⋱";
  var dtri = "▿";
  var dtrif = "▾";
  var duarr = "⇵";
  var duhar = "⥯";
  var dwangle = "⦦";
  var DZcy = "Џ";
  var dzcy = "џ";
  var dzigrarr = "⟿";
  var Eacute = "É";
  var eacute = "é";
  var easter = "⩮";
  var Ecaron = "Ě";
  var ecaron = "ě";
  var Ecirc = "Ê";
  var ecirc = "ê";
  var ecir = "≖";
  var ecolon = "≕";
  var Ecy = "Э";
  var ecy = "э";
  var eDDot = "⩷";
  var Edot = "Ė";
  var edot = "ė";
  var eDot = "≑";
  var ee = "ⅇ";
  var efDot = "≒";
  var Efr = "𝔈";
  var efr = "𝔢";
  var eg = "⪚";
  var Egrave = "È";
  var egrave = "è";
  var egs = "⪖";
  var egsdot = "⪘";
  var el = "⪙";
  var Element = "∈";
  var elinters = "⏧";
  var ell = "ℓ";
  var els = "⪕";
  var elsdot = "⪗";
  var Emacr = "Ē";
  var emacr = "ē";
  var empty$4 = "∅";
  var emptyset = "∅";
  var EmptySmallSquare = "◻";
  var emptyv = "∅";
  var EmptyVerySmallSquare = "▫";
  var emsp13 = " ";
  var emsp14 = " ";
  var emsp = " ";
  var ENG = "Ŋ";
  var eng = "ŋ";
  var ensp = " ";
  var Eogon = "Ę";
  var eogon = "ę";
  var Eopf = "𝔼";
  var eopf = "𝕖";
  var epar = "⋕";
  var eparsl = "⧣";
  var eplus = "⩱";
  var epsi = "ε";
  var Epsilon = "Ε";
  var epsilon = "ε";
  var epsiv = "ϵ";
  var eqcirc = "≖";
  var eqcolon = "≕";
  var eqsim = "≂";
  var eqslantgtr = "⪖";
  var eqslantless = "⪕";
  var Equal = "⩵";
  var equals = "=";
  var EqualTilde = "≂";
  var equest = "≟";
  var Equilibrium = "⇌";
  var equiv = "≡";
  var equivDD = "⩸";
  var eqvparsl = "⧥";
  var erarr = "⥱";
  var erDot = "≓";
  var escr = "ℯ";
  var Escr = "ℰ";
  var esdot = "≐";
  var Esim = "⩳";
  var esim = "≂";
  var Eta = "Η";
  var eta = "η";
  var ETH = "Ð";
  var eth = "ð";
  var Euml = "Ë";
  var euml = "ë";
  var euro = "€";
  var excl = "!";
  var exist = "∃";
  var Exists = "∃";
  var expectation = "ℰ";
  var exponentiale = "ⅇ";
  var ExponentialE = "ⅇ";
  var fallingdotseq = "≒";
  var Fcy = "Ф";
  var fcy = "ф";
  var female = "♀";
  var ffilig = "ﬃ";
  var fflig = "ﬀ";
  var ffllig = "ﬄ";
  var Ffr = "𝔉";
  var ffr = "𝔣";
  var filig = "ﬁ";
  var FilledSmallSquare = "◼";
  var FilledVerySmallSquare = "▪";
  var fjlig = "fj";
  var flat = "♭";
  var fllig = "ﬂ";
  var fltns = "▱";
  var fnof = "ƒ";
  var Fopf = "𝔽";
  var fopf = "𝕗";
  var forall = "∀";
  var ForAll = "∀";
  var fork = "⋔";
  var forkv = "⫙";
  var Fouriertrf = "ℱ";
  var fpartint = "⨍";
  var frac12 = "½";
  var frac13 = "⅓";
  var frac14 = "¼";
  var frac15 = "⅕";
  var frac16 = "⅙";
  var frac18 = "⅛";
  var frac23 = "⅔";
  var frac25 = "⅖";
  var frac34 = "¾";
  var frac35 = "⅗";
  var frac38 = "⅜";
  var frac45 = "⅘";
  var frac56 = "⅚";
  var frac58 = "⅝";
  var frac78 = "⅞";
  var frasl = "⁄";
  var frown = "⌢";
  var fscr = "𝒻";
  var Fscr = "ℱ";
  var gacute = "ǵ";
  var Gamma = "Γ";
  var gamma = "γ";
  var Gammad = "Ϝ";
  var gammad = "ϝ";
  var gap = "⪆";
  var Gbreve = "Ğ";
  var gbreve = "ğ";
  var Gcedil = "Ģ";
  var Gcirc = "Ĝ";
  var gcirc = "ĝ";
  var Gcy = "Г";
  var gcy = "г";
  var Gdot = "Ġ";
  var gdot = "ġ";
  var ge = "≥";
  var gE = "≧";
  var gEl = "⪌";
  var gel = "⋛";
  var geq = "≥";
  var geqq = "≧";
  var geqslant = "⩾";
  var gescc = "⪩";
  var ges = "⩾";
  var gesdot = "⪀";
  var gesdoto = "⪂";
  var gesdotol = "⪄";
  var gesl = "⋛︀";
  var gesles = "⪔";
  var Gfr = "𝔊";
  var gfr = "𝔤";
  var gg = "≫";
  var Gg = "⋙";
  var ggg = "⋙";
  var gimel = "ℷ";
  var GJcy = "Ѓ";
  var gjcy = "ѓ";
  var gla = "⪥";
  var gl = "≷";
  var glE = "⪒";
  var glj = "⪤";
  var gnap = "⪊";
  var gnapprox = "⪊";
  var gne = "⪈";
  var gnE = "≩";
  var gneq = "⪈";
  var gneqq = "≩";
  var gnsim = "⋧";
  var Gopf = "𝔾";
  var gopf = "𝕘";
  var grave = "`";
  var GreaterEqual = "≥";
  var GreaterEqualLess = "⋛";
  var GreaterFullEqual = "≧";
  var GreaterGreater = "⪢";
  var GreaterLess = "≷";
  var GreaterSlantEqual = "⩾";
  var GreaterTilde = "≳";
  var Gscr = "𝒢";
  var gscr = "ℊ";
  var gsim = "≳";
  var gsime = "⪎";
  var gsiml = "⪐";
  var gtcc = "⪧";
  var gtcir = "⩺";
  var gt = ">";
  var GT = ">";
  var Gt = "≫";
  var gtdot = "⋗";
  var gtlPar = "⦕";
  var gtquest = "⩼";
  var gtrapprox = "⪆";
  var gtrarr = "⥸";
  var gtrdot = "⋗";
  var gtreqless = "⋛";
  var gtreqqless = "⪌";
  var gtrless = "≷";
  var gtrsim = "≳";
  var gvertneqq = "≩︀";
  var gvnE = "≩︀";
  var Hacek = "ˇ";
  var hairsp = " ";
  var half = "½";
  var hamilt = "ℋ";
  var HARDcy = "Ъ";
  var hardcy = "ъ";
  var harrcir = "⥈";
  var harr = "↔";
  var hArr = "⇔";
  var harrw = "↭";
  var Hat = "^";
  var hbar = "ℏ";
  var Hcirc = "Ĥ";
  var hcirc = "ĥ";
  var hearts = "♥";
  var heartsuit = "♥";
  var hellip = "…";
  var hercon = "⊹";
  var hfr = "𝔥";
  var Hfr = "ℌ";
  var HilbertSpace = "ℋ";
  var hksearow = "⤥";
  var hkswarow = "⤦";
  var hoarr = "⇿";
  var homtht = "∻";
  var hookleftarrow = "↩";
  var hookrightarrow = "↪";
  var hopf = "𝕙";
  var Hopf = "ℍ";
  var horbar = "―";
  var HorizontalLine = "─";
  var hscr = "𝒽";
  var Hscr = "ℋ";
  var hslash = "ℏ";
  var Hstrok = "Ħ";
  var hstrok = "ħ";
  var HumpDownHump = "≎";
  var HumpEqual = "≏";
  var hybull = "⁃";
  var hyphen = "‐";
  var Iacute = "Í";
  var iacute = "í";
  var ic = "⁣";
  var Icirc = "Î";
  var icirc = "î";
  var Icy = "И";
  var icy = "и";
  var Idot = "İ";
  var IEcy = "Е";
  var iecy = "е";
  var iexcl = "¡";
  var iff = "⇔";
  var ifr = "𝔦";
  var Ifr = "ℑ";
  var Igrave = "Ì";
  var igrave = "ì";
  var ii = "ⅈ";
  var iiiint = "⨌";
  var iiint = "∭";
  var iinfin = "⧜";
  var iiota = "℩";
  var IJlig = "Ĳ";
  var ijlig = "ĳ";
  var Imacr = "Ī";
  var imacr = "ī";
  var image = "ℑ";
  var ImaginaryI = "ⅈ";
  var imagline = "ℐ";
  var imagpart = "ℑ";
  var imath = "ı";
  var Im = "ℑ";
  var imof = "⊷";
  var imped = "Ƶ";
  var Implies = "⇒";
  var incare = "℅";
  var infin = "∞";
  var infintie = "⧝";
  var inodot = "ı";
  var intcal = "⊺";
  var int = "∫";
  var Int = "∬";
  var integers = "ℤ";
  var Integral = "∫";
  var intercal = "⊺";
  var Intersection = "⋂";
  var intlarhk = "⨗";
  var intprod = "⨼";
  var InvisibleComma = "⁣";
  var InvisibleTimes = "⁢";
  var IOcy = "Ё";
  var iocy = "ё";
  var Iogon = "Į";
  var iogon = "į";
  var Iopf = "𝕀";
  var iopf = "𝕚";
  var Iota = "Ι";
  var iota = "ι";
  var iprod = "⨼";
  var iquest = "¿";
  var iscr = "𝒾";
  var Iscr = "ℐ";
  var isin = "∈";
  var isindot = "⋵";
  var isinE = "⋹";
  var isins = "⋴";
  var isinsv = "⋳";
  var isinv = "∈";
  var it = "⁢";
  var Itilde = "Ĩ";
  var itilde = "ĩ";
  var Iukcy = "І";
  var iukcy = "і";
  var Iuml = "Ï";
  var iuml = "ï";
  var Jcirc = "Ĵ";
  var jcirc = "ĵ";
  var Jcy = "Й";
  var jcy = "й";
  var Jfr = "𝔍";
  var jfr = "𝔧";
  var jmath = "ȷ";
  var Jopf = "𝕁";
  var jopf = "𝕛";
  var Jscr = "𝒥";
  var jscr = "𝒿";
  var Jsercy = "Ј";
  var jsercy = "ј";
  var Jukcy = "Є";
  var jukcy = "є";
  var Kappa = "Κ";
  var kappa = "κ";
  var kappav = "ϰ";
  var Kcedil = "Ķ";
  var kcedil = "ķ";
  var Kcy = "К";
  var kcy = "к";
  var Kfr = "𝔎";
  var kfr = "𝔨";
  var kgreen = "ĸ";
  var KHcy = "Х";
  var khcy = "х";
  var KJcy = "Ќ";
  var kjcy = "ќ";
  var Kopf = "𝕂";
  var kopf = "𝕜";
  var Kscr = "𝒦";
  var kscr = "𝓀";
  var lAarr = "⇚";
  var Lacute = "Ĺ";
  var lacute = "ĺ";
  var laemptyv = "⦴";
  var lagran = "ℒ";
  var Lambda = "Λ";
  var lambda = "λ";
  var lang = "⟨";
  var Lang = "⟪";
  var langd = "⦑";
  var langle = "⟨";
  var lap = "⪅";
  var Laplacetrf = "ℒ";
  var laquo = "«";
  var larrb = "⇤";
  var larrbfs = "⤟";
  var larr = "←";
  var Larr = "↞";
  var lArr = "⇐";
  var larrfs = "⤝";
  var larrhk = "↩";
  var larrlp = "↫";
  var larrpl = "⤹";
  var larrsim = "⥳";
  var larrtl = "↢";
  var latail = "⤙";
  var lAtail = "⤛";
  var lat = "⪫";
  var late = "⪭";
  var lates = "⪭︀";
  var lbarr = "⤌";
  var lBarr = "⤎";
  var lbbrk = "❲";
  var lbrace = "{";
  var lbrack = "[";
  var lbrke = "⦋";
  var lbrksld = "⦏";
  var lbrkslu = "⦍";
  var Lcaron = "Ľ";
  var lcaron = "ľ";
  var Lcedil = "Ļ";
  var lcedil = "ļ";
  var lceil = "⌈";
  var lcub = "{";
  var Lcy = "Л";
  var lcy = "л";
  var ldca = "⤶";
  var ldquo = "“";
  var ldquor = "„";
  var ldrdhar = "⥧";
  var ldrushar = "⥋";
  var ldsh = "↲";
  var le = "≤";
  var lE = "≦";
  var LeftAngleBracket = "⟨";
  var LeftArrowBar = "⇤";
  var leftarrow = "←";
  var LeftArrow = "←";
  var Leftarrow = "⇐";
  var LeftArrowRightArrow = "⇆";
  var leftarrowtail = "↢";
  var LeftCeiling = "⌈";
  var LeftDoubleBracket = "⟦";
  var LeftDownTeeVector = "⥡";
  var LeftDownVectorBar = "⥙";
  var LeftDownVector = "⇃";
  var LeftFloor = "⌊";
  var leftharpoondown = "↽";
  var leftharpoonup = "↼";
  var leftleftarrows = "⇇";
  var leftrightarrow = "↔";
  var LeftRightArrow = "↔";
  var Leftrightarrow = "⇔";
  var leftrightarrows = "⇆";
  var leftrightharpoons = "⇋";
  var leftrightsquigarrow = "↭";
  var LeftRightVector = "⥎";
  var LeftTeeArrow = "↤";
  var LeftTee = "⊣";
  var LeftTeeVector = "⥚";
  var leftthreetimes = "⋋";
  var LeftTriangleBar = "⧏";
  var LeftTriangle = "⊲";
  var LeftTriangleEqual = "⊴";
  var LeftUpDownVector = "⥑";
  var LeftUpTeeVector = "⥠";
  var LeftUpVectorBar = "⥘";
  var LeftUpVector = "↿";
  var LeftVectorBar = "⥒";
  var LeftVector = "↼";
  var lEg = "⪋";
  var leg = "⋚";
  var leq = "≤";
  var leqq = "≦";
  var leqslant = "⩽";
  var lescc = "⪨";
  var les = "⩽";
  var lesdot = "⩿";
  var lesdoto = "⪁";
  var lesdotor = "⪃";
  var lesg = "⋚︀";
  var lesges = "⪓";
  var lessapprox = "⪅";
  var lessdot = "⋖";
  var lesseqgtr = "⋚";
  var lesseqqgtr = "⪋";
  var LessEqualGreater = "⋚";
  var LessFullEqual = "≦";
  var LessGreater = "≶";
  var lessgtr = "≶";
  var LessLess = "⪡";
  var lesssim = "≲";
  var LessSlantEqual = "⩽";
  var LessTilde = "≲";
  var lfisht = "⥼";
  var lfloor = "⌊";
  var Lfr = "𝔏";
  var lfr = "𝔩";
  var lg = "≶";
  var lgE = "⪑";
  var lHar = "⥢";
  var lhard = "↽";
  var lharu = "↼";
  var lharul = "⥪";
  var lhblk = "▄";
  var LJcy = "Љ";
  var ljcy = "љ";
  var llarr = "⇇";
  var ll = "≪";
  var Ll = "⋘";
  var llcorner = "⌞";
  var Lleftarrow = "⇚";
  var llhard = "⥫";
  var lltri = "◺";
  var Lmidot = "Ŀ";
  var lmidot = "ŀ";
  var lmoustache = "⎰";
  var lmoust = "⎰";
  var lnap = "⪉";
  var lnapprox = "⪉";
  var lne = "⪇";
  var lnE = "≨";
  var lneq = "⪇";
  var lneqq = "≨";
  var lnsim = "⋦";
  var loang = "⟬";
  var loarr = "⇽";
  var lobrk = "⟦";
  var longleftarrow = "⟵";
  var LongLeftArrow = "⟵";
  var Longleftarrow = "⟸";
  var longleftrightarrow = "⟷";
  var LongLeftRightArrow = "⟷";
  var Longleftrightarrow = "⟺";
  var longmapsto = "⟼";
  var longrightarrow = "⟶";
  var LongRightArrow = "⟶";
  var Longrightarrow = "⟹";
  var looparrowleft = "↫";
  var looparrowright = "↬";
  var lopar = "⦅";
  var Lopf = "𝕃";
  var lopf = "𝕝";
  var loplus = "⨭";
  var lotimes = "⨴";
  var lowast = "∗";
  var lowbar = "_";
  var LowerLeftArrow = "↙";
  var LowerRightArrow = "↘";
  var loz = "◊";
  var lozenge = "◊";
  var lozf = "⧫";
  var lpar = "(";
  var lparlt = "⦓";
  var lrarr = "⇆";
  var lrcorner = "⌟";
  var lrhar = "⇋";
  var lrhard = "⥭";
  var lrm = "‎";
  var lrtri = "⊿";
  var lsaquo = "‹";
  var lscr = "𝓁";
  var Lscr = "ℒ";
  var lsh = "↰";
  var Lsh = "↰";
  var lsim = "≲";
  var lsime = "⪍";
  var lsimg = "⪏";
  var lsqb = "[";
  var lsquo = "‘";
  var lsquor = "‚";
  var Lstrok = "Ł";
  var lstrok = "ł";
  var ltcc = "⪦";
  var ltcir = "⩹";
  var lt = "<";
  var LT = "<";
  var Lt = "≪";
  var ltdot = "⋖";
  var lthree = "⋋";
  var ltimes = "⋉";
  var ltlarr = "⥶";
  var ltquest = "⩻";
  var ltri = "◃";
  var ltrie = "⊴";
  var ltrif = "◂";
  var ltrPar = "⦖";
  var lurdshar = "⥊";
  var luruhar = "⥦";
  var lvertneqq = "≨︀";
  var lvnE = "≨︀";
  var macr = "¯";
  var male = "♂";
  var malt = "✠";
  var maltese = "✠";
  var map$1 = "↦";
  var mapsto = "↦";
  var mapstodown = "↧";
  var mapstoleft = "↤";
  var mapstoup = "↥";
  var marker$1 = "▮";
  var mcomma = "⨩";
  var Mcy = "М";
  var mcy = "м";
  var mdash = "—";
  var mDDot = "∺";
  var measuredangle = "∡";
  var MediumSpace = " ";
  var Mellintrf = "ℳ";
  var Mfr = "𝔐";
  var mfr = "𝔪";
  var mho = "℧";
  var micro = "µ";
  var midast = "*";
  var midcir = "⫰";
  var mid = "∣";
  var middot = "·";
  var minusb = "⊟";
  var minus = "−";
  var minusd = "∸";
  var minusdu = "⨪";
  var MinusPlus = "∓";
  var mlcp = "⫛";
  var mldr = "…";
  var mnplus = "∓";
  var models = "⊧";
  var Mopf = "𝕄";
  var mopf = "𝕞";
  var mp = "∓";
  var mscr = "𝓂";
  var Mscr = "ℳ";
  var mstpos = "∾";
  var Mu = "Μ";
  var mu = "μ";
  var multimap = "⊸";
  var mumap = "⊸";
  var nabla = "∇";
  var Nacute = "Ń";
  var nacute = "ń";
  var nang = "∠⃒";
  var nap = "≉";
  var napE = "⩰̸";
  var napid = "≋̸";
  var napos = "ŉ";
  var napprox = "≉";
  var natural = "♮";
  var naturals = "ℕ";
  var natur = "♮";
  var nbsp = " ";
  var nbump = "≎̸";
  var nbumpe = "≏̸";
  var ncap = "⩃";
  var Ncaron = "Ň";
  var ncaron = "ň";
  var Ncedil = "Ņ";
  var ncedil = "ņ";
  var ncong = "≇";
  var ncongdot = "⩭̸";
  var ncup = "⩂";
  var Ncy = "Н";
  var ncy = "н";
  var ndash = "–";
  var nearhk = "⤤";
  var nearr = "↗";
  var neArr = "⇗";
  var nearrow = "↗";
  var ne = "≠";
  var nedot = "≐̸";
  var NegativeMediumSpace = "​";
  var NegativeThickSpace = "​";
  var NegativeThinSpace = "​";
  var NegativeVeryThinSpace = "​";
  var nequiv = "≢";
  var nesear = "⤨";
  var nesim = "≂̸";
  var NestedGreaterGreater = "≫";
  var NestedLessLess = "≪";
  var NewLine = "\n";
  var nexist = "∄";
  var nexists = "∄";
  var Nfr = "𝔑";
  var nfr = "𝔫";
  var ngE = "≧̸";
  var nge = "≱";
  var ngeq = "≱";
  var ngeqq = "≧̸";
  var ngeqslant = "⩾̸";
  var nges = "⩾̸";
  var nGg = "⋙̸";
  var ngsim = "≵";
  var nGt = "≫⃒";
  var ngt = "≯";
  var ngtr = "≯";
  var nGtv = "≫̸";
  var nharr = "↮";
  var nhArr = "⇎";
  var nhpar = "⫲";
  var ni = "∋";
  var nis = "⋼";
  var nisd = "⋺";
  var niv = "∋";
  var NJcy = "Њ";
  var njcy = "њ";
  var nlarr = "↚";
  var nlArr = "⇍";
  var nldr = "‥";
  var nlE = "≦̸";
  var nle = "≰";
  var nleftarrow = "↚";
  var nLeftarrow = "⇍";
  var nleftrightarrow = "↮";
  var nLeftrightarrow = "⇎";
  var nleq = "≰";
  var nleqq = "≦̸";
  var nleqslant = "⩽̸";
  var nles = "⩽̸";
  var nless = "≮";
  var nLl = "⋘̸";
  var nlsim = "≴";
  var nLt = "≪⃒";
  var nlt = "≮";
  var nltri = "⋪";
  var nltrie = "⋬";
  var nLtv = "≪̸";
  var nmid = "∤";
  var NoBreak = "⁠";
  var NonBreakingSpace = " ";
  var nopf = "𝕟";
  var Nopf = "ℕ";
  var Not = "⫬";
  var not$1 = "¬";
  var NotCongruent = "≢";
  var NotCupCap = "≭";
  var NotDoubleVerticalBar = "∦";
  var NotElement = "∉";
  var NotEqual = "≠";
  var NotEqualTilde = "≂̸";
  var NotExists = "∄";
  var NotGreater = "≯";
  var NotGreaterEqual = "≱";
  var NotGreaterFullEqual = "≧̸";
  var NotGreaterGreater = "≫̸";
  var NotGreaterLess = "≹";
  var NotGreaterSlantEqual = "⩾̸";
  var NotGreaterTilde = "≵";
  var NotHumpDownHump = "≎̸";
  var NotHumpEqual = "≏̸";
  var notin = "∉";
  var notindot = "⋵̸";
  var notinE = "⋹̸";
  var notinva = "∉";
  var notinvb = "⋷";
  var notinvc = "⋶";
  var NotLeftTriangleBar = "⧏̸";
  var NotLeftTriangle = "⋪";
  var NotLeftTriangleEqual = "⋬";
  var NotLess = "≮";
  var NotLessEqual = "≰";
  var NotLessGreater = "≸";
  var NotLessLess = "≪̸";
  var NotLessSlantEqual = "⩽̸";
  var NotLessTilde = "≴";
  var NotNestedGreaterGreater = "⪢̸";
  var NotNestedLessLess = "⪡̸";
  var notni = "∌";
  var notniva = "∌";
  var notnivb = "⋾";
  var notnivc = "⋽";
  var NotPrecedes = "⊀";
  var NotPrecedesEqual = "⪯̸";
  var NotPrecedesSlantEqual = "⋠";
  var NotReverseElement = "∌";
  var NotRightTriangleBar = "⧐̸";
  var NotRightTriangle = "⋫";
  var NotRightTriangleEqual = "⋭";
  var NotSquareSubset = "⊏̸";
  var NotSquareSubsetEqual = "⋢";
  var NotSquareSuperset = "⊐̸";
  var NotSquareSupersetEqual = "⋣";
  var NotSubset = "⊂⃒";
  var NotSubsetEqual = "⊈";
  var NotSucceeds = "⊁";
  var NotSucceedsEqual = "⪰̸";
  var NotSucceedsSlantEqual = "⋡";
  var NotSucceedsTilde = "≿̸";
  var NotSuperset = "⊃⃒";
  var NotSupersetEqual = "⊉";
  var NotTilde = "≁";
  var NotTildeEqual = "≄";
  var NotTildeFullEqual = "≇";
  var NotTildeTilde = "≉";
  var NotVerticalBar = "∤";
  var nparallel = "∦";
  var npar = "∦";
  var nparsl = "⫽⃥";
  var npart = "∂̸";
  var npolint = "⨔";
  var npr = "⊀";
  var nprcue = "⋠";
  var nprec = "⊀";
  var npreceq = "⪯̸";
  var npre = "⪯̸";
  var nrarrc = "⤳̸";
  var nrarr = "↛";
  var nrArr = "⇏";
  var nrarrw = "↝̸";
  var nrightarrow = "↛";
  var nRightarrow = "⇏";
  var nrtri = "⋫";
  var nrtrie = "⋭";
  var nsc = "⊁";
  var nsccue = "⋡";
  var nsce = "⪰̸";
  var Nscr = "𝒩";
  var nscr = "𝓃";
  var nshortmid = "∤";
  var nshortparallel = "∦";
  var nsim = "≁";
  var nsime = "≄";
  var nsimeq = "≄";
  var nsmid = "∤";
  var nspar = "∦";
  var nsqsube = "⋢";
  var nsqsupe = "⋣";
  var nsub = "⊄";
  var nsubE = "⫅̸";
  var nsube = "⊈";
  var nsubset = "⊂⃒";
  var nsubseteq = "⊈";
  var nsubseteqq = "⫅̸";
  var nsucc = "⊁";
  var nsucceq = "⪰̸";
  var nsup = "⊅";
  var nsupE = "⫆̸";
  var nsupe = "⊉";
  var nsupset = "⊃⃒";
  var nsupseteq = "⊉";
  var nsupseteqq = "⫆̸";
  var ntgl = "≹";
  var Ntilde = "Ñ";
  var ntilde = "ñ";
  var ntlg = "≸";
  var ntriangleleft = "⋪";
  var ntrianglelefteq = "⋬";
  var ntriangleright = "⋫";
  var ntrianglerighteq = "⋭";
  var Nu = "Ν";
  var nu = "ν";
  var num = "#";
  var numero = "№";
  var numsp = " ";
  var nvap = "≍⃒";
  var nvdash = "⊬";
  var nvDash = "⊭";
  var nVdash = "⊮";
  var nVDash = "⊯";
  var nvge = "≥⃒";
  var nvgt = ">⃒";
  var nvHarr = "⤄";
  var nvinfin = "⧞";
  var nvlArr = "⤂";
  var nvle = "≤⃒";
  var nvlt = "<⃒";
  var nvltrie = "⊴⃒";
  var nvrArr = "⤃";
  var nvrtrie = "⊵⃒";
  var nvsim = "∼⃒";
  var nwarhk = "⤣";
  var nwarr = "↖";
  var nwArr = "⇖";
  var nwarrow = "↖";
  var nwnear = "⤧";
  var Oacute = "Ó";
  var oacute = "ó";
  var oast = "⊛";
  var Ocirc = "Ô";
  var ocirc = "ô";
  var ocir = "⊚";
  var Ocy = "О";
  var ocy = "о";
  var odash = "⊝";
  var Odblac = "Ő";
  var odblac = "ő";
  var odiv = "⨸";
  var odot = "⊙";
  var odsold = "⦼";
  var OElig = "Œ";
  var oelig = "œ";
  var ofcir = "⦿";
  var Ofr = "𝔒";
  var ofr = "𝔬";
  var ogon = "˛";
  var Ograve = "Ò";
  var ograve = "ò";
  var ogt = "⧁";
  var ohbar = "⦵";
  var ohm = "Ω";
  var oint = "∮";
  var olarr = "↺";
  var olcir = "⦾";
  var olcross = "⦻";
  var oline = "‾";
  var olt = "⧀";
  var Omacr = "Ō";
  var omacr = "ō";
  var Omega = "Ω";
  var omega = "ω";
  var Omicron = "Ο";
  var omicron = "ο";
  var omid = "⦶";
  var ominus = "⊖";
  var Oopf = "𝕆";
  var oopf = "𝕠";
  var opar = "⦷";
  var OpenCurlyDoubleQuote = "“";
  var OpenCurlyQuote = "‘";
  var operp = "⦹";
  var oplus = "⊕";
  var orarr = "↻";
  var Or = "⩔";
  var or = "∨";
  var ord = "⩝";
  var order = "ℴ";
  var orderof = "ℴ";
  var ordf = "ª";
  var ordm = "º";
  var origof = "⊶";
  var oror = "⩖";
  var orslope = "⩗";
  var orv = "⩛";
  var oS = "Ⓢ";
  var Oscr = "𝒪";
  var oscr = "ℴ";
  var Oslash = "Ø";
  var oslash = "ø";
  var osol = "⊘";
  var Otilde = "Õ";
  var otilde = "õ";
  var otimesas = "⨶";
  var Otimes = "⨷";
  var otimes = "⊗";
  var Ouml = "Ö";
  var ouml = "ö";
  var ovbar = "⌽";
  var OverBar = "‾";
  var OverBrace = "⏞";
  var OverBracket = "⎴";
  var OverParenthesis = "⏜";
  var para = "¶";
  var parallel = "∥";
  var par = "∥";
  var parsim = "⫳";
  var parsl = "⫽";
  var part = "∂";
  var PartialD = "∂";
  var Pcy = "П";
  var pcy = "п";
  var percnt = "%";
  var period = ".";
  var permil = "‰";
  var perp = "⊥";
  var pertenk = "‱";
  var Pfr = "𝔓";
  var pfr = "𝔭";
  var Phi = "Φ";
  var phi = "φ";
  var phiv = "ϕ";
  var phmmat = "ℳ";
  var phone = "☎";
  var Pi = "Π";
  var pi = "π";
  var pitchfork = "⋔";
  var piv = "ϖ";
  var planck = "ℏ";
  var planckh = "ℎ";
  var plankv = "ℏ";
  var plusacir = "⨣";
  var plusb = "⊞";
  var pluscir = "⨢";
  var plus = "+";
  var plusdo = "∔";
  var plusdu = "⨥";
  var pluse = "⩲";
  var PlusMinus = "±";
  var plusmn = "±";
  var plussim = "⨦";
  var plustwo = "⨧";
  var pm = "±";
  var Poincareplane = "ℌ";
  var pointint = "⨕";
  var popf = "𝕡";
  var Popf = "ℙ";
  var pound = "£";
  var prap = "⪷";
  var Pr = "⪻";
  var pr = "≺";
  var prcue = "≼";
  var precapprox = "⪷";
  var prec = "≺";
  var preccurlyeq = "≼";
  var Precedes = "≺";
  var PrecedesEqual = "⪯";
  var PrecedesSlantEqual = "≼";
  var PrecedesTilde = "≾";
  var preceq = "⪯";
  var precnapprox = "⪹";
  var precneqq = "⪵";
  var precnsim = "⋨";
  var pre = "⪯";
  var prE = "⪳";
  var precsim = "≾";
  var prime = "′";
  var Prime = "″";
  var primes = "ℙ";
  var prnap = "⪹";
  var prnE = "⪵";
  var prnsim = "⋨";
  var prod = "∏";
  var Product = "∏";
  var profalar = "⌮";
  var profline = "⌒";
  var profsurf = "⌓";
  var prop = "∝";
  var Proportional = "∝";
  var Proportion = "∷";
  var propto = "∝";
  var prsim = "≾";
  var prurel = "⊰";
  var Pscr = "𝒫";
  var pscr = "𝓅";
  var Psi = "Ψ";
  var psi = "ψ";
  var puncsp = " ";
  var Qfr = "𝔔";
  var qfr = "𝔮";
  var qint = "⨌";
  var qopf = "𝕢";
  var Qopf = "ℚ";
  var qprime = "⁗";
  var Qscr = "𝒬";
  var qscr = "𝓆";
  var quaternions = "ℍ";
  var quatint = "⨖";
  var quest = "?";
  var questeq = "≟";
  var quot = "\"";
  var QUOT = "\"";
  var rAarr = "⇛";
  var race$1 = "∽̱";
  var Racute = "Ŕ";
  var racute = "ŕ";
  var radic = "√";
  var raemptyv = "⦳";
  var rang = "⟩";
  var Rang = "⟫";
  var rangd = "⦒";
  var range$1 = "⦥";
  var rangle = "⟩";
  var raquo = "»";
  var rarrap = "⥵";
  var rarrb = "⇥";
  var rarrbfs = "⤠";
  var rarrc = "⤳";
  var rarr = "→";
  var Rarr = "↠";
  var rArr = "⇒";
  var rarrfs = "⤞";
  var rarrhk = "↪";
  var rarrlp = "↬";
  var rarrpl = "⥅";
  var rarrsim = "⥴";
  var Rarrtl = "⤖";
  var rarrtl = "↣";
  var rarrw = "↝";
  var ratail = "⤚";
  var rAtail = "⤜";
  var ratio = "∶";
  var rationals = "ℚ";
  var rbarr = "⤍";
  var rBarr = "⤏";
  var RBarr = "⤐";
  var rbbrk = "❳";
  var rbrace = "}";
  var rbrack = "]";
  var rbrke = "⦌";
  var rbrksld = "⦎";
  var rbrkslu = "⦐";
  var Rcaron = "Ř";
  var rcaron = "ř";
  var Rcedil = "Ŗ";
  var rcedil = "ŗ";
  var rceil = "⌉";
  var rcub = "}";
  var Rcy = "Р";
  var rcy = "р";
  var rdca = "⤷";
  var rdldhar = "⥩";
  var rdquo = "”";
  var rdquor = "”";
  var rdsh = "↳";
  var real = "ℜ";
  var realine = "ℛ";
  var realpart = "ℜ";
  var reals = "ℝ";
  var Re = "ℜ";
  var rect = "▭";
  var reg = "®";
  var REG = "®";
  var ReverseElement = "∋";
  var ReverseEquilibrium = "⇋";
  var ReverseUpEquilibrium = "⥯";
  var rfisht = "⥽";
  var rfloor = "⌋";
  var rfr = "𝔯";
  var Rfr = "ℜ";
  var rHar = "⥤";
  var rhard = "⇁";
  var rharu = "⇀";
  var rharul = "⥬";
  var Rho = "Ρ";
  var rho = "ρ";
  var rhov = "ϱ";
  var RightAngleBracket = "⟩";
  var RightArrowBar = "⇥";
  var rightarrow = "→";
  var RightArrow = "→";
  var Rightarrow = "⇒";
  var RightArrowLeftArrow = "⇄";
  var rightarrowtail = "↣";
  var RightCeiling = "⌉";
  var RightDoubleBracket = "⟧";
  var RightDownTeeVector = "⥝";
  var RightDownVectorBar = "⥕";
  var RightDownVector = "⇂";
  var RightFloor = "⌋";
  var rightharpoondown = "⇁";
  var rightharpoonup = "⇀";
  var rightleftarrows = "⇄";
  var rightleftharpoons = "⇌";
  var rightrightarrows = "⇉";
  var rightsquigarrow = "↝";
  var RightTeeArrow = "↦";
  var RightTee = "⊢";
  var RightTeeVector = "⥛";
  var rightthreetimes = "⋌";
  var RightTriangleBar = "⧐";
  var RightTriangle = "⊳";
  var RightTriangleEqual = "⊵";
  var RightUpDownVector = "⥏";
  var RightUpTeeVector = "⥜";
  var RightUpVectorBar = "⥔";
  var RightUpVector = "↾";
  var RightVectorBar = "⥓";
  var RightVector = "⇀";
  var ring = "˚";
  var risingdotseq = "≓";
  var rlarr = "⇄";
  var rlhar = "⇌";
  var rlm = "‏";
  var rmoustache = "⎱";
  var rmoust = "⎱";
  var rnmid = "⫮";
  var roang = "⟭";
  var roarr = "⇾";
  var robrk = "⟧";
  var ropar = "⦆";
  var ropf = "𝕣";
  var Ropf = "ℝ";
  var roplus = "⨮";
  var rotimes = "⨵";
  var RoundImplies = "⥰";
  var rpar = ")";
  var rpargt = "⦔";
  var rppolint = "⨒";
  var rrarr = "⇉";
  var Rrightarrow = "⇛";
  var rsaquo = "›";
  var rscr = "𝓇";
  var Rscr = "ℛ";
  var rsh = "↱";
  var Rsh = "↱";
  var rsqb = "]";
  var rsquo = "’";
  var rsquor = "’";
  var rthree = "⋌";
  var rtimes = "⋊";
  var rtri = "▹";
  var rtrie = "⊵";
  var rtrif = "▸";
  var rtriltri = "⧎";
  var RuleDelayed = "⧴";
  var ruluhar = "⥨";
  var rx = "℞";
  var Sacute = "Ś";
  var sacute = "ś";
  var sbquo = "‚";
  var scap = "⪸";
  var Scaron = "Š";
  var scaron = "š";
  var Sc = "⪼";
  var sc = "≻";
  var sccue = "≽";
  var sce = "⪰";
  var scE = "⪴";
  var Scedil = "Ş";
  var scedil = "ş";
  var Scirc = "Ŝ";
  var scirc = "ŝ";
  var scnap = "⪺";
  var scnE = "⪶";
  var scnsim = "⋩";
  var scpolint = "⨓";
  var scsim = "≿";
  var Scy = "С";
  var scy = "с";
  var sdotb = "⊡";
  var sdot = "⋅";
  var sdote = "⩦";
  var searhk = "⤥";
  var searr = "↘";
  var seArr = "⇘";
  var searrow = "↘";
  var sect = "§";
  var semi = ";";
  var seswar = "⤩";
  var setminus = "∖";
  var setmn = "∖";
  var sext = "✶";
  var Sfr = "𝔖";
  var sfr = "𝔰";
  var sfrown = "⌢";
  var sharp = "♯";
  var SHCHcy = "Щ";
  var shchcy = "щ";
  var SHcy = "Ш";
  var shcy = "ш";
  var ShortDownArrow = "↓";
  var ShortLeftArrow = "←";
  var shortmid = "∣";
  var shortparallel = "∥";
  var ShortRightArrow = "→";
  var ShortUpArrow = "↑";
  var shy = "­";
  var Sigma = "Σ";
  var sigma = "σ";
  var sigmaf = "ς";
  var sigmav = "ς";
  var sim = "∼";
  var simdot = "⩪";
  var sime = "≃";
  var simeq = "≃";
  var simg = "⪞";
  var simgE = "⪠";
  var siml = "⪝";
  var simlE = "⪟";
  var simne = "≆";
  var simplus = "⨤";
  var simrarr = "⥲";
  var slarr = "←";
  var SmallCircle = "∘";
  var smallsetminus = "∖";
  var smashp = "⨳";
  var smeparsl = "⧤";
  var smid = "∣";
  var smile = "⌣";
  var smt = "⪪";
  var smte = "⪬";
  var smtes = "⪬︀";
  var SOFTcy = "Ь";
  var softcy = "ь";
  var solbar = "⌿";
  var solb = "⧄";
  var sol = "/";
  var Sopf = "𝕊";
  var sopf = "𝕤";
  var spades = "♠";
  var spadesuit = "♠";
  var spar = "∥";
  var sqcap = "⊓";
  var sqcaps = "⊓︀";
  var sqcup = "⊔";
  var sqcups = "⊔︀";
  var Sqrt = "√";
  var sqsub = "⊏";
  var sqsube = "⊑";
  var sqsubset = "⊏";
  var sqsubseteq = "⊑";
  var sqsup = "⊐";
  var sqsupe = "⊒";
  var sqsupset = "⊐";
  var sqsupseteq = "⊒";
  var square = "□";
  var Square = "□";
  var SquareIntersection = "⊓";
  var SquareSubset = "⊏";
  var SquareSubsetEqual = "⊑";
  var SquareSuperset = "⊐";
  var SquareSupersetEqual = "⊒";
  var SquareUnion = "⊔";
  var squarf = "▪";
  var squ = "□";
  var squf = "▪";
  var srarr = "→";
  var Sscr = "𝒮";
  var sscr = "𝓈";
  var ssetmn = "∖";
  var ssmile = "⌣";
  var sstarf = "⋆";
  var Star = "⋆";
  var star = "☆";
  var starf = "★";
  var straightepsilon = "ϵ";
  var straightphi = "ϕ";
  var strns = "¯";
  var sub = "⊂";
  var Sub = "⋐";
  var subdot = "⪽";
  var subE = "⫅";
  var sube = "⊆";
  var subedot = "⫃";
  var submult = "⫁";
  var subnE = "⫋";
  var subne = "⊊";
  var subplus = "⪿";
  var subrarr = "⥹";
  var subset = "⊂";
  var Subset = "⋐";
  var subseteq = "⊆";
  var subseteqq = "⫅";
  var SubsetEqual = "⊆";
  var subsetneq = "⊊";
  var subsetneqq = "⫋";
  var subsim = "⫇";
  var subsub = "⫕";
  var subsup = "⫓";
  var succapprox = "⪸";
  var succ = "≻";
  var succcurlyeq = "≽";
  var Succeeds = "≻";
  var SucceedsEqual = "⪰";
  var SucceedsSlantEqual = "≽";
  var SucceedsTilde = "≿";
  var succeq = "⪰";
  var succnapprox = "⪺";
  var succneqq = "⪶";
  var succnsim = "⋩";
  var succsim = "≿";
  var SuchThat = "∋";
  var sum = "∑";
  var Sum = "∑";
  var sung = "♪";
  var sup1 = "¹";
  var sup2 = "²";
  var sup3 = "³";
  var sup = "⊃";
  var Sup = "⋑";
  var supdot = "⪾";
  var supdsub = "⫘";
  var supE = "⫆";
  var supe = "⊇";
  var supedot = "⫄";
  var Superset = "⊃";
  var SupersetEqual = "⊇";
  var suphsol = "⟉";
  var suphsub = "⫗";
  var suplarr = "⥻";
  var supmult = "⫂";
  var supnE = "⫌";
  var supne = "⊋";
  var supplus = "⫀";
  var supset = "⊃";
  var Supset = "⋑";
  var supseteq = "⊇";
  var supseteqq = "⫆";
  var supsetneq = "⊋";
  var supsetneqq = "⫌";
  var supsim = "⫈";
  var supsub = "⫔";
  var supsup = "⫖";
  var swarhk = "⤦";
  var swarr = "↙";
  var swArr = "⇙";
  var swarrow = "↙";
  var swnwar = "⤪";
  var szlig = "ß";
  var Tab = "\t";
  var target = "⌖";
  var Tau = "Τ";
  var tau = "τ";
  var tbrk = "⎴";
  var Tcaron = "Ť";
  var tcaron = "ť";
  var Tcedil = "Ţ";
  var tcedil = "ţ";
  var Tcy = "Т";
  var tcy = "т";
  var tdot = "⃛";
  var telrec = "⌕";
  var Tfr = "𝔗";
  var tfr = "𝔱";
  var there4 = "∴";
  var therefore = "∴";
  var Therefore = "∴";
  var Theta = "Θ";
  var theta = "θ";
  var thetasym = "ϑ";
  var thetav = "ϑ";
  var thickapprox = "≈";
  var thicksim = "∼";
  var ThickSpace = "  ";
  var ThinSpace = " ";
  var thinsp = " ";
  var thkap = "≈";
  var thksim = "∼";
  var THORN = "Þ";
  var thorn = "þ";
  var tilde = "˜";
  var Tilde = "∼";
  var TildeEqual = "≃";
  var TildeFullEqual = "≅";
  var TildeTilde = "≈";
  var timesbar = "⨱";
  var timesb = "⊠";
  var times = "×";
  var timesd = "⨰";
  var tint = "∭";
  var toea = "⤨";
  var topbot = "⌶";
  var topcir = "⫱";
  var top = "⊤";
  var Topf = "𝕋";
  var topf = "𝕥";
  var topfork = "⫚";
  var tosa = "⤩";
  var tprime = "‴";
  var trade = "™";
  var TRADE = "™";
  var triangle = "▵";
  var triangledown = "▿";
  var triangleleft = "◃";
  var trianglelefteq = "⊴";
  var triangleq = "≜";
  var triangleright = "▹";
  var trianglerighteq = "⊵";
  var tridot = "◬";
  var trie = "≜";
  var triminus = "⨺";
  var TripleDot = "⃛";
  var triplus = "⨹";
  var trisb = "⧍";
  var tritime = "⨻";
  var trpezium = "⏢";
  var Tscr = "𝒯";
  var tscr = "𝓉";
  var TScy = "Ц";
  var tscy = "ц";
  var TSHcy = "Ћ";
  var tshcy = "ћ";
  var Tstrok = "Ŧ";
  var tstrok = "ŧ";
  var twixt = "≬";
  var twoheadleftarrow = "↞";
  var twoheadrightarrow = "↠";
  var Uacute = "Ú";
  var uacute = "ú";
  var uarr = "↑";
  var Uarr = "↟";
  var uArr = "⇑";
  var Uarrocir = "⥉";
  var Ubrcy = "Ў";
  var ubrcy = "ў";
  var Ubreve = "Ŭ";
  var ubreve = "ŭ";
  var Ucirc = "Û";
  var ucirc = "û";
  var Ucy = "У";
  var ucy = "у";
  var udarr = "⇅";
  var Udblac = "Ű";
  var udblac = "ű";
  var udhar = "⥮";
  var ufisht = "⥾";
  var Ufr = "𝔘";
  var ufr = "𝔲";
  var Ugrave = "Ù";
  var ugrave = "ù";
  var uHar = "⥣";
  var uharl = "↿";
  var uharr = "↾";
  var uhblk = "▀";
  var ulcorn = "⌜";
  var ulcorner = "⌜";
  var ulcrop = "⌏";
  var ultri = "◸";
  var Umacr = "Ū";
  var umacr = "ū";
  var uml = "¨";
  var UnderBar = "_";
  var UnderBrace = "⏟";
  var UnderBracket = "⎵";
  var UnderParenthesis = "⏝";
  var Union = "⋃";
  var UnionPlus = "⊎";
  var Uogon = "Ų";
  var uogon = "ų";
  var Uopf = "𝕌";
  var uopf = "𝕦";
  var UpArrowBar = "⤒";
  var uparrow = "↑";
  var UpArrow = "↑";
  var Uparrow = "⇑";
  var UpArrowDownArrow = "⇅";
  var updownarrow = "↕";
  var UpDownArrow = "↕";
  var Updownarrow = "⇕";
  var UpEquilibrium = "⥮";
  var upharpoonleft = "↿";
  var upharpoonright = "↾";
  var uplus = "⊎";
  var UpperLeftArrow = "↖";
  var UpperRightArrow = "↗";
  var upsi = "υ";
  var Upsi = "ϒ";
  var upsih = "ϒ";
  var Upsilon = "Υ";
  var upsilon = "υ";
  var UpTeeArrow = "↥";
  var UpTee = "⊥";
  var upuparrows = "⇈";
  var urcorn = "⌝";
  var urcorner = "⌝";
  var urcrop = "⌎";
  var Uring = "Ů";
  var uring = "ů";
  var urtri = "◹";
  var Uscr = "𝒰";
  var uscr = "𝓊";
  var utdot = "⋰";
  var Utilde = "Ũ";
  var utilde = "ũ";
  var utri = "▵";
  var utrif = "▴";
  var uuarr = "⇈";
  var Uuml = "Ü";
  var uuml = "ü";
  var uwangle = "⦧";
  var vangrt = "⦜";
  var varepsilon = "ϵ";
  var varkappa = "ϰ";
  var varnothing = "∅";
  var varphi = "ϕ";
  var varpi = "ϖ";
  var varpropto = "∝";
  var varr = "↕";
  var vArr = "⇕";
  var varrho = "ϱ";
  var varsigma = "ς";
  var varsubsetneq = "⊊︀";
  var varsubsetneqq = "⫋︀";
  var varsupsetneq = "⊋︀";
  var varsupsetneqq = "⫌︀";
  var vartheta = "ϑ";
  var vartriangleleft = "⊲";
  var vartriangleright = "⊳";
  var vBar = "⫨";
  var Vbar = "⫫";
  var vBarv = "⫩";
  var Vcy = "В";
  var vcy = "в";
  var vdash = "⊢";
  var vDash = "⊨";
  var Vdash = "⊩";
  var VDash = "⊫";
  var Vdashl = "⫦";
  var veebar = "⊻";
  var vee = "∨";
  var Vee = "⋁";
  var veeeq = "≚";
  var vellip = "⋮";
  var verbar = "|";
  var Verbar = "‖";
  var vert = "|";
  var Vert = "‖";
  var VerticalBar = "∣";
  var VerticalLine = "|";
  var VerticalSeparator = "❘";
  var VerticalTilde = "≀";
  var VeryThinSpace = " ";
  var Vfr = "𝔙";
  var vfr = "𝔳";
  var vltri = "⊲";
  var vnsub = "⊂⃒";
  var vnsup = "⊃⃒";
  var Vopf = "𝕍";
  var vopf = "𝕧";
  var vprop = "∝";
  var vrtri = "⊳";
  var Vscr = "𝒱";
  var vscr = "𝓋";
  var vsubnE = "⫋︀";
  var vsubne = "⊊︀";
  var vsupnE = "⫌︀";
  var vsupne = "⊋︀";
  var Vvdash = "⊪";
  var vzigzag = "⦚";
  var Wcirc = "Ŵ";
  var wcirc = "ŵ";
  var wedbar = "⩟";
  var wedge = "∧";
  var Wedge = "⋀";
  var wedgeq = "≙";
  var weierp = "℘";
  var Wfr = "𝔚";
  var wfr = "𝔴";
  var Wopf = "𝕎";
  var wopf = "𝕨";
  var wp = "℘";
  var wr = "≀";
  var wreath = "≀";
  var Wscr = "𝒲";
  var wscr = "𝓌";
  var xcap = "⋂";
  var xcirc = "◯";
  var xcup = "⋃";
  var xdtri = "▽";
  var Xfr = "𝔛";
  var xfr = "𝔵";
  var xharr = "⟷";
  var xhArr = "⟺";
  var Xi = "Ξ";
  var xi = "ξ";
  var xlarr = "⟵";
  var xlArr = "⟸";
  var xmap = "⟼";
  var xnis = "⋻";
  var xodot = "⨀";
  var Xopf = "𝕏";
  var xopf = "𝕩";
  var xoplus = "⨁";
  var xotime = "⨂";
  var xrarr = "⟶";
  var xrArr = "⟹";
  var Xscr = "𝒳";
  var xscr = "𝓍";
  var xsqcup = "⨆";
  var xuplus = "⨄";
  var xutri = "△";
  var xvee = "⋁";
  var xwedge = "⋀";
  var Yacute = "Ý";
  var yacute = "ý";
  var YAcy = "Я";
  var yacy = "я";
  var Ycirc = "Ŷ";
  var ycirc = "ŷ";
  var Ycy = "Ы";
  var ycy = "ы";
  var yen = "¥";
  var Yfr = "𝔜";
  var yfr = "𝔶";
  var YIcy = "Ї";
  var yicy = "ї";
  var Yopf = "𝕐";
  var yopf = "𝕪";
  var Yscr = "𝒴";
  var yscr = "𝓎";
  var YUcy = "Ю";
  var yucy = "ю";
  var yuml = "ÿ";
  var Yuml = "Ÿ";
  var Zacute = "Ź";
  var zacute = "ź";
  var Zcaron = "Ž";
  var zcaron = "ž";
  var Zcy = "З";
  var zcy = "з";
  var Zdot = "Ż";
  var zdot = "ż";
  var zeetrf = "ℨ";
  var ZeroWidthSpace = "​";
  var Zeta = "Ζ";
  var zeta = "ζ";
  var zfr = "𝔷";
  var Zfr = "ℨ";
  var ZHcy = "Ж";
  var zhcy = "ж";
  var zigrarr = "⇝";
  var zopf = "𝕫";
  var Zopf = "ℤ";
  var Zscr = "𝒵";
  var zscr = "𝓏";
  var zwj = "‍";
  var zwnj = "‌";
  var entities = {
    Aacute: Aacute,
    aacute: aacute,
    Abreve: Abreve,
    abreve: abreve,
    ac: ac,
    acd: acd,
    acE: acE,
    Acirc: Acirc,
    acirc: acirc,
    acute: acute,
    Acy: Acy,
    acy: acy,
    AElig: AElig,
    aelig: aelig,
    af: af,
    Afr: Afr,
    afr: afr,
    Agrave: Agrave,
    agrave: agrave,
    alefsym: alefsym,
    aleph: aleph,
    Alpha: Alpha,
    alpha: alpha,
    Amacr: Amacr,
    amacr: amacr,
    amalg: amalg,
    amp: amp,
    AMP: AMP,
    andand: andand,
    And: And,
    and: and,
    andd: andd,
    andslope: andslope,
    andv: andv,
    ang: ang,
    ange: ange,
    angle: angle,
    angmsdaa: angmsdaa,
    angmsdab: angmsdab,
    angmsdac: angmsdac,
    angmsdad: angmsdad,
    angmsdae: angmsdae,
    angmsdaf: angmsdaf,
    angmsdag: angmsdag,
    angmsdah: angmsdah,
    angmsd: angmsd,
    angrt: angrt,
    angrtvb: angrtvb,
    angrtvbd: angrtvbd,
    angsph: angsph,
    angst: angst,
    angzarr: angzarr,
    Aogon: Aogon,
    aogon: aogon,
    Aopf: Aopf,
    aopf: aopf,
    apacir: apacir,
    ap: ap,
    apE: apE,
    ape: ape,
    apid: apid,
    apos: apos,
    ApplyFunction: ApplyFunction,
    approx: approx,
    approxeq: approxeq,
    Aring: Aring,
    aring: aring,
    Ascr: Ascr,
    ascr: ascr,
    Assign: Assign,
    ast: ast,
    asymp: asymp,
    asympeq: asympeq,
    Atilde: Atilde,
    atilde: atilde,
    Auml: Auml,
    auml: auml,
    awconint: awconint,
    awint: awint,
    backcong: backcong,
    backepsilon: backepsilon,
    backprime: backprime,
    backsim: backsim,
    backsimeq: backsimeq,
    Backslash: Backslash,
    Barv: Barv,
    barvee: barvee,
    barwed: barwed,
    Barwed: Barwed,
    barwedge: barwedge,
    bbrk: bbrk,
    bbrktbrk: bbrktbrk,
    bcong: bcong,
    Bcy: Bcy,
    bcy: bcy,
    bdquo: bdquo,
    becaus: becaus,
    because: because,
    Because: Because,
    bemptyv: bemptyv,
    bepsi: bepsi,
    bernou: bernou,
    Bernoullis: Bernoullis,
    Beta: Beta,
    beta: beta,
    beth: beth,
    between: between,
    Bfr: Bfr,
    bfr: bfr,
    bigcap: bigcap,
    bigcirc: bigcirc,
    bigcup: bigcup,
    bigodot: bigodot,
    bigoplus: bigoplus,
    bigotimes: bigotimes,
    bigsqcup: bigsqcup,
    bigstar: bigstar,
    bigtriangledown: bigtriangledown,
    bigtriangleup: bigtriangleup,
    biguplus: biguplus,
    bigvee: bigvee,
    bigwedge: bigwedge,
    bkarow: bkarow,
    blacklozenge: blacklozenge,
    blacksquare: blacksquare,
    blacktriangle: blacktriangle,
    blacktriangledown: blacktriangledown,
    blacktriangleleft: blacktriangleleft,
    blacktriangleright: blacktriangleright,
    blank: blank,
    blk12: blk12,
    blk14: blk14,
    blk34: blk34,
    block: block,
    bne: bne,
    bnequiv: bnequiv,
    bNot: bNot,
    bnot: bnot,
    Bopf: Bopf,
    bopf: bopf,
    bot: bot,
    bottom: bottom,
    bowtie: bowtie,
    boxbox: boxbox,
    boxdl: boxdl,
    boxdL: boxdL,
    boxDl: boxDl,
    boxDL: boxDL,
    boxdr: boxdr,
    boxdR: boxdR,
    boxDr: boxDr,
    boxDR: boxDR,
    boxh: boxh,
    boxH: boxH,
    boxhd: boxhd,
    boxHd: boxHd,
    boxhD: boxhD,
    boxHD: boxHD,
    boxhu: boxhu,
    boxHu: boxHu,
    boxhU: boxhU,
    boxHU: boxHU,
    boxminus: boxminus,
    boxplus: boxplus,
    boxtimes: boxtimes,
    boxul: boxul,
    boxuL: boxuL,
    boxUl: boxUl,
    boxUL: boxUL,
    boxur: boxur,
    boxuR: boxuR,
    boxUr: boxUr,
    boxUR: boxUR,
    boxv: boxv,
    boxV: boxV,
    boxvh: boxvh,
    boxvH: boxvH,
    boxVh: boxVh,
    boxVH: boxVH,
    boxvl: boxvl,
    boxvL: boxvL,
    boxVl: boxVl,
    boxVL: boxVL,
    boxvr: boxvr,
    boxvR: boxvR,
    boxVr: boxVr,
    boxVR: boxVR,
    bprime: bprime,
    breve: breve,
    Breve: Breve,
    brvbar: brvbar,
    bscr: bscr,
    Bscr: Bscr,
    bsemi: bsemi,
    bsim: bsim,
    bsime: bsime,
    bsolb: bsolb,
    bsol: bsol,
    bsolhsub: bsolhsub,
    bull: bull,
    bullet: bullet,
    bump: bump,
    bumpE: bumpE,
    bumpe: bumpe,
    Bumpeq: Bumpeq,
    bumpeq: bumpeq,
    Cacute: Cacute,
    cacute: cacute,
    capand: capand,
    capbrcup: capbrcup,
    capcap: capcap,
    cap: cap,
    Cap: Cap,
    capcup: capcup,
    capdot: capdot,
    CapitalDifferentialD: CapitalDifferentialD,
    caps: caps,
    caret: caret,
    caron: caron,
    Cayleys: Cayleys,
    ccaps: ccaps,
    Ccaron: Ccaron,
    ccaron: ccaron,
    Ccedil: Ccedil,
    ccedil: ccedil,
    Ccirc: Ccirc,
    ccirc: ccirc,
    Cconint: Cconint,
    ccups: ccups,
    ccupssm: ccupssm,
    Cdot: Cdot,
    cdot: cdot,
    cedil: cedil,
    Cedilla: Cedilla,
    cemptyv: cemptyv,
    cent: cent,
    centerdot: centerdot,
    CenterDot: CenterDot,
    cfr: cfr,
    Cfr: Cfr,
    CHcy: CHcy,
    chcy: chcy,
    check: check$1,
    checkmark: checkmark,
    Chi: Chi,
    chi: chi,
    circ: circ,
    circeq: circeq,
    circlearrowleft: circlearrowleft,
    circlearrowright: circlearrowright,
    circledast: circledast,
    circledcirc: circledcirc,
    circleddash: circleddash,
    CircleDot: CircleDot,
    circledR: circledR,
    circledS: circledS,
    CircleMinus: CircleMinus,
    CirclePlus: CirclePlus,
    CircleTimes: CircleTimes,
    cir: cir,
    cirE: cirE,
    cire: cire,
    cirfnint: cirfnint,
    cirmid: cirmid,
    cirscir: cirscir,
    ClockwiseContourIntegral: ClockwiseContourIntegral,
    CloseCurlyDoubleQuote: CloseCurlyDoubleQuote,
    CloseCurlyQuote: CloseCurlyQuote,
    clubs: clubs,
    clubsuit: clubsuit,
    colon: colon,
    Colon: Colon,
    Colone: Colone,
    colone: colone,
    coloneq: coloneq,
    comma: comma,
    commat: commat,
    comp: comp,
    compfn: compfn,
    complement: complement,
    complexes: complexes,
    cong: cong,
    congdot: congdot,
    Congruent: Congruent,
    conint: conint,
    Conint: Conint,
    ContourIntegral: ContourIntegral,
    copf: copf,
    Copf: Copf,
    coprod: coprod,
    Coproduct: Coproduct,
    copy: copy,
    COPY: COPY,
    copysr: copysr,
    CounterClockwiseContourIntegral: CounterClockwiseContourIntegral,
    crarr: crarr,
    cross: cross,
    Cross: Cross,
    Cscr: Cscr,
    cscr: cscr,
    csub: csub,
    csube: csube,
    csup: csup,
    csupe: csupe,
    ctdot: ctdot,
    cudarrl: cudarrl,
    cudarrr: cudarrr,
    cuepr: cuepr,
    cuesc: cuesc,
    cularr: cularr,
    cularrp: cularrp,
    cupbrcap: cupbrcap,
    cupcap: cupcap,
    CupCap: CupCap,
    cup: cup,
    Cup: Cup,
    cupcup: cupcup,
    cupdot: cupdot,
    cupor: cupor,
    cups: cups,
    curarr: curarr,
    curarrm: curarrm,
    curlyeqprec: curlyeqprec,
    curlyeqsucc: curlyeqsucc,
    curlyvee: curlyvee,
    curlywedge: curlywedge,
    curren: curren,
    curvearrowleft: curvearrowleft,
    curvearrowright: curvearrowright,
    cuvee: cuvee,
    cuwed: cuwed,
    cwconint: cwconint,
    cwint: cwint,
    cylcty: cylcty,
    dagger: dagger,
    Dagger: Dagger,
    daleth: daleth,
    darr: darr,
    Darr: Darr,
    dArr: dArr,
    dash: dash,
    Dashv: Dashv,
    dashv: dashv,
    dbkarow: dbkarow,
    dblac: dblac,
    Dcaron: Dcaron,
    dcaron: dcaron,
    Dcy: Dcy,
    dcy: dcy,
    ddagger: ddagger,
    ddarr: ddarr,
    DD: DD,
    dd: dd,
    DDotrahd: DDotrahd,
    ddotseq: ddotseq,
    deg: deg,
    Del: Del,
    Delta: Delta,
    delta: delta,
    demptyv: demptyv,
    dfisht: dfisht,
    Dfr: Dfr,
    dfr: dfr,
    dHar: dHar,
    dharl: dharl,
    dharr: dharr,
    DiacriticalAcute: DiacriticalAcute,
    DiacriticalDot: DiacriticalDot,
    DiacriticalDoubleAcute: DiacriticalDoubleAcute,
    DiacriticalGrave: DiacriticalGrave,
    DiacriticalTilde: DiacriticalTilde,
    diam: diam,
    diamond: diamond,
    Diamond: Diamond,
    diamondsuit: diamondsuit,
    diams: diams,
    die: die,
    DifferentialD: DifferentialD,
    digamma: digamma,
    disin: disin,
    div: div,
    divide: divide,
    divideontimes: divideontimes,
    divonx: divonx,
    DJcy: DJcy,
    djcy: djcy,
    dlcorn: dlcorn,
    dlcrop: dlcrop,
    dollar: dollar,
    Dopf: Dopf,
    dopf: dopf,
    Dot: Dot,
    dot: dot,
    DotDot: DotDot,
    doteq: doteq,
    doteqdot: doteqdot,
    DotEqual: DotEqual,
    dotminus: dotminus,
    dotplus: dotplus,
    dotsquare: dotsquare,
    doublebarwedge: doublebarwedge,
    DoubleContourIntegral: DoubleContourIntegral,
    DoubleDot: DoubleDot,
    DoubleDownArrow: DoubleDownArrow,
    DoubleLeftArrow: DoubleLeftArrow,
    DoubleLeftRightArrow: DoubleLeftRightArrow,
    DoubleLeftTee: DoubleLeftTee,
    DoubleLongLeftArrow: DoubleLongLeftArrow,
    DoubleLongLeftRightArrow: DoubleLongLeftRightArrow,
    DoubleLongRightArrow: DoubleLongRightArrow,
    DoubleRightArrow: DoubleRightArrow,
    DoubleRightTee: DoubleRightTee,
    DoubleUpArrow: DoubleUpArrow,
    DoubleUpDownArrow: DoubleUpDownArrow,
    DoubleVerticalBar: DoubleVerticalBar,
    DownArrowBar: DownArrowBar,
    downarrow: downarrow,
    DownArrow: DownArrow,
    Downarrow: Downarrow,
    DownArrowUpArrow: DownArrowUpArrow,
    DownBreve: DownBreve,
    downdownarrows: downdownarrows,
    downharpoonleft: downharpoonleft,
    downharpoonright: downharpoonright,
    DownLeftRightVector: DownLeftRightVector,
    DownLeftTeeVector: DownLeftTeeVector,
    DownLeftVectorBar: DownLeftVectorBar,
    DownLeftVector: DownLeftVector,
    DownRightTeeVector: DownRightTeeVector,
    DownRightVectorBar: DownRightVectorBar,
    DownRightVector: DownRightVector,
    DownTeeArrow: DownTeeArrow,
    DownTee: DownTee,
    drbkarow: drbkarow,
    drcorn: drcorn,
    drcrop: drcrop,
    Dscr: Dscr,
    dscr: dscr,
    DScy: DScy,
    dscy: dscy,
    dsol: dsol,
    Dstrok: Dstrok,
    dstrok: dstrok,
    dtdot: dtdot,
    dtri: dtri,
    dtrif: dtrif,
    duarr: duarr,
    duhar: duhar,
    dwangle: dwangle,
    DZcy: DZcy,
    dzcy: dzcy,
    dzigrarr: dzigrarr,
    Eacute: Eacute,
    eacute: eacute,
    easter: easter,
    Ecaron: Ecaron,
    ecaron: ecaron,
    Ecirc: Ecirc,
    ecirc: ecirc,
    ecir: ecir,
    ecolon: ecolon,
    Ecy: Ecy,
    ecy: ecy,
    eDDot: eDDot,
    Edot: Edot,
    edot: edot,
    eDot: eDot,
    ee: ee,
    efDot: efDot,
    Efr: Efr,
    efr: efr,
    eg: eg,
    Egrave: Egrave,
    egrave: egrave,
    egs: egs,
    egsdot: egsdot,
    el: el,
    Element: Element,
    elinters: elinters,
    ell: ell,
    els: els,
    elsdot: elsdot,
    Emacr: Emacr,
    emacr: emacr,
    empty: empty$4,
    emptyset: emptyset,
    EmptySmallSquare: EmptySmallSquare,
    emptyv: emptyv,
    EmptyVerySmallSquare: EmptyVerySmallSquare,
    emsp13: emsp13,
    emsp14: emsp14,
    emsp: emsp,
    ENG: ENG,
    eng: eng,
    ensp: ensp,
    Eogon: Eogon,
    eogon: eogon,
    Eopf: Eopf,
    eopf: eopf,
    epar: epar,
    eparsl: eparsl,
    eplus: eplus,
    epsi: epsi,
    Epsilon: Epsilon,
    epsilon: epsilon,
    epsiv: epsiv,
    eqcirc: eqcirc,
    eqcolon: eqcolon,
    eqsim: eqsim,
    eqslantgtr: eqslantgtr,
    eqslantless: eqslantless,
    Equal: Equal,
    equals: equals,
    EqualTilde: EqualTilde,
    equest: equest,
    Equilibrium: Equilibrium,
    equiv: equiv,
    equivDD: equivDD,
    eqvparsl: eqvparsl,
    erarr: erarr,
    erDot: erDot,
    escr: escr,
    Escr: Escr,
    esdot: esdot,
    Esim: Esim,
    esim: esim,
    Eta: Eta,
    eta: eta,
    ETH: ETH,
    eth: eth,
    Euml: Euml,
    euml: euml,
    euro: euro,
    excl: excl,
    exist: exist,
    Exists: Exists,
    expectation: expectation,
    exponentiale: exponentiale,
    ExponentialE: ExponentialE,
    fallingdotseq: fallingdotseq,
    Fcy: Fcy,
    fcy: fcy,
    female: female,
    ffilig: ffilig,
    fflig: fflig,
    ffllig: ffllig,
    Ffr: Ffr,
    ffr: ffr,
    filig: filig,
    FilledSmallSquare: FilledSmallSquare,
    FilledVerySmallSquare: FilledVerySmallSquare,
    fjlig: fjlig,
    flat: flat,
    fllig: fllig,
    fltns: fltns,
    fnof: fnof,
    Fopf: Fopf,
    fopf: fopf,
    forall: forall,
    ForAll: ForAll,
    fork: fork,
    forkv: forkv,
    Fouriertrf: Fouriertrf,
    fpartint: fpartint,
    frac12: frac12,
    frac13: frac13,
    frac14: frac14,
    frac15: frac15,
    frac16: frac16,
    frac18: frac18,
    frac23: frac23,
    frac25: frac25,
    frac34: frac34,
    frac35: frac35,
    frac38: frac38,
    frac45: frac45,
    frac56: frac56,
    frac58: frac58,
    frac78: frac78,
    frasl: frasl,
    frown: frown,
    fscr: fscr,
    Fscr: Fscr,
    gacute: gacute,
    Gamma: Gamma,
    gamma: gamma,
    Gammad: Gammad,
    gammad: gammad,
    gap: gap,
    Gbreve: Gbreve,
    gbreve: gbreve,
    Gcedil: Gcedil,
    Gcirc: Gcirc,
    gcirc: gcirc,
    Gcy: Gcy,
    gcy: gcy,
    Gdot: Gdot,
    gdot: gdot,
    ge: ge,
    gE: gE,
    gEl: gEl,
    gel: gel,
    geq: geq,
    geqq: geqq,
    geqslant: geqslant,
    gescc: gescc,
    ges: ges,
    gesdot: gesdot,
    gesdoto: gesdoto,
    gesdotol: gesdotol,
    gesl: gesl,
    gesles: gesles,
    Gfr: Gfr,
    gfr: gfr,
    gg: gg,
    Gg: Gg,
    ggg: ggg,
    gimel: gimel,
    GJcy: GJcy,
    gjcy: gjcy,
    gla: gla,
    gl: gl,
    glE: glE,
    glj: glj,
    gnap: gnap,
    gnapprox: gnapprox,
    gne: gne,
    gnE: gnE,
    gneq: gneq,
    gneqq: gneqq,
    gnsim: gnsim,
    Gopf: Gopf,
    gopf: gopf,
    grave: grave,
    GreaterEqual: GreaterEqual,
    GreaterEqualLess: GreaterEqualLess,
    GreaterFullEqual: GreaterFullEqual,
    GreaterGreater: GreaterGreater,
    GreaterLess: GreaterLess,
    GreaterSlantEqual: GreaterSlantEqual,
    GreaterTilde: GreaterTilde,
    Gscr: Gscr,
    gscr: gscr,
    gsim: gsim,
    gsime: gsime,
    gsiml: gsiml,
    gtcc: gtcc,
    gtcir: gtcir,
    gt: gt,
    GT: GT,
    Gt: Gt,
    gtdot: gtdot,
    gtlPar: gtlPar,
    gtquest: gtquest,
    gtrapprox: gtrapprox,
    gtrarr: gtrarr,
    gtrdot: gtrdot,
    gtreqless: gtreqless,
    gtreqqless: gtreqqless,
    gtrless: gtrless,
    gtrsim: gtrsim,
    gvertneqq: gvertneqq,
    gvnE: gvnE,
    Hacek: Hacek,
    hairsp: hairsp,
    half: half,
    hamilt: hamilt,
    HARDcy: HARDcy,
    hardcy: hardcy,
    harrcir: harrcir,
    harr: harr,
    hArr: hArr,
    harrw: harrw,
    Hat: Hat,
    hbar: hbar,
    Hcirc: Hcirc,
    hcirc: hcirc,
    hearts: hearts,
    heartsuit: heartsuit,
    hellip: hellip,
    hercon: hercon,
    hfr: hfr,
    Hfr: Hfr,
    HilbertSpace: HilbertSpace,
    hksearow: hksearow,
    hkswarow: hkswarow,
    hoarr: hoarr,
    homtht: homtht,
    hookleftarrow: hookleftarrow,
    hookrightarrow: hookrightarrow,
    hopf: hopf,
    Hopf: Hopf,
    horbar: horbar,
    HorizontalLine: HorizontalLine,
    hscr: hscr,
    Hscr: Hscr,
    hslash: hslash,
    Hstrok: Hstrok,
    hstrok: hstrok,
    HumpDownHump: HumpDownHump,
    HumpEqual: HumpEqual,
    hybull: hybull,
    hyphen: hyphen,
    Iacute: Iacute,
    iacute: iacute,
    ic: ic,
    Icirc: Icirc,
    icirc: icirc,
    Icy: Icy,
    icy: icy,
    Idot: Idot,
    IEcy: IEcy,
    iecy: iecy,
    iexcl: iexcl,
    iff: iff,
    ifr: ifr,
    Ifr: Ifr,
    Igrave: Igrave,
    igrave: igrave,
    ii: ii,
    iiiint: iiiint,
    iiint: iiint,
    iinfin: iinfin,
    iiota: iiota,
    IJlig: IJlig,
    ijlig: ijlig,
    Imacr: Imacr,
    imacr: imacr,
    image: image,
    ImaginaryI: ImaginaryI,
    imagline: imagline,
    imagpart: imagpart,
    imath: imath,
    Im: Im,
    imof: imof,
    imped: imped,
    Implies: Implies,
    incare: incare,
    infin: infin,
    infintie: infintie,
    inodot: inodot,
    intcal: intcal,
    int: int,
    Int: Int,
    integers: integers,
    Integral: Integral,
    intercal: intercal,
    Intersection: Intersection,
    intlarhk: intlarhk,
    intprod: intprod,
    InvisibleComma: InvisibleComma,
    InvisibleTimes: InvisibleTimes,
    IOcy: IOcy,
    iocy: iocy,
    Iogon: Iogon,
    iogon: iogon,
    Iopf: Iopf,
    iopf: iopf,
    Iota: Iota,
    iota: iota,
    iprod: iprod,
    iquest: iquest,
    iscr: iscr,
    Iscr: Iscr,
    isin: isin,
    isindot: isindot,
    isinE: isinE,
    isins: isins,
    isinsv: isinsv,
    isinv: isinv,
    it: it,
    Itilde: Itilde,
    itilde: itilde,
    Iukcy: Iukcy,
    iukcy: iukcy,
    Iuml: Iuml,
    iuml: iuml,
    Jcirc: Jcirc,
    jcirc: jcirc,
    Jcy: Jcy,
    jcy: jcy,
    Jfr: Jfr,
    jfr: jfr,
    jmath: jmath,
    Jopf: Jopf,
    jopf: jopf,
    Jscr: Jscr,
    jscr: jscr,
    Jsercy: Jsercy,
    jsercy: jsercy,
    Jukcy: Jukcy,
    jukcy: jukcy,
    Kappa: Kappa,
    kappa: kappa,
    kappav: kappav,
    Kcedil: Kcedil,
    kcedil: kcedil,
    Kcy: Kcy,
    kcy: kcy,
    Kfr: Kfr,
    kfr: kfr,
    kgreen: kgreen,
    KHcy: KHcy,
    khcy: khcy,
    KJcy: KJcy,
    kjcy: kjcy,
    Kopf: Kopf,
    kopf: kopf,
    Kscr: Kscr,
    kscr: kscr,
    lAarr: lAarr,
    Lacute: Lacute,
    lacute: lacute,
    laemptyv: laemptyv,
    lagran: lagran,
    Lambda: Lambda,
    lambda: lambda,
    lang: lang,
    Lang: Lang,
    langd: langd,
    langle: langle,
    lap: lap,
    Laplacetrf: Laplacetrf,
    laquo: laquo,
    larrb: larrb,
    larrbfs: larrbfs,
    larr: larr,
    Larr: Larr,
    lArr: lArr,
    larrfs: larrfs,
    larrhk: larrhk,
    larrlp: larrlp,
    larrpl: larrpl,
    larrsim: larrsim,
    larrtl: larrtl,
    latail: latail,
    lAtail: lAtail,
    lat: lat,
    late: late,
    lates: lates,
    lbarr: lbarr,
    lBarr: lBarr,
    lbbrk: lbbrk,
    lbrace: lbrace,
    lbrack: lbrack,
    lbrke: lbrke,
    lbrksld: lbrksld,
    lbrkslu: lbrkslu,
    Lcaron: Lcaron,
    lcaron: lcaron,
    Lcedil: Lcedil,
    lcedil: lcedil,
    lceil: lceil,
    lcub: lcub,
    Lcy: Lcy,
    lcy: lcy,
    ldca: ldca,
    ldquo: ldquo,
    ldquor: ldquor,
    ldrdhar: ldrdhar,
    ldrushar: ldrushar,
    ldsh: ldsh,
    le: le,
    lE: lE,
    LeftAngleBracket: LeftAngleBracket,
    LeftArrowBar: LeftArrowBar,
    leftarrow: leftarrow,
    LeftArrow: LeftArrow,
    Leftarrow: Leftarrow,
    LeftArrowRightArrow: LeftArrowRightArrow,
    leftarrowtail: leftarrowtail,
    LeftCeiling: LeftCeiling,
    LeftDoubleBracket: LeftDoubleBracket,
    LeftDownTeeVector: LeftDownTeeVector,
    LeftDownVectorBar: LeftDownVectorBar,
    LeftDownVector: LeftDownVector,
    LeftFloor: LeftFloor,
    leftharpoondown: leftharpoondown,
    leftharpoonup: leftharpoonup,
    leftleftarrows: leftleftarrows,
    leftrightarrow: leftrightarrow,
    LeftRightArrow: LeftRightArrow,
    Leftrightarrow: Leftrightarrow,
    leftrightarrows: leftrightarrows,
    leftrightharpoons: leftrightharpoons,
    leftrightsquigarrow: leftrightsquigarrow,
    LeftRightVector: LeftRightVector,
    LeftTeeArrow: LeftTeeArrow,
    LeftTee: LeftTee,
    LeftTeeVector: LeftTeeVector,
    leftthreetimes: leftthreetimes,
    LeftTriangleBar: LeftTriangleBar,
    LeftTriangle: LeftTriangle,
    LeftTriangleEqual: LeftTriangleEqual,
    LeftUpDownVector: LeftUpDownVector,
    LeftUpTeeVector: LeftUpTeeVector,
    LeftUpVectorBar: LeftUpVectorBar,
    LeftUpVector: LeftUpVector,
    LeftVectorBar: LeftVectorBar,
    LeftVector: LeftVector,
    lEg: lEg,
    leg: leg,
    leq: leq,
    leqq: leqq,
    leqslant: leqslant,
    lescc: lescc,
    les: les,
    lesdot: lesdot,
    lesdoto: lesdoto,
    lesdotor: lesdotor,
    lesg: lesg,
    lesges: lesges,
    lessapprox: lessapprox,
    lessdot: lessdot,
    lesseqgtr: lesseqgtr,
    lesseqqgtr: lesseqqgtr,
    LessEqualGreater: LessEqualGreater,
    LessFullEqual: LessFullEqual,
    LessGreater: LessGreater,
    lessgtr: lessgtr,
    LessLess: LessLess,
    lesssim: lesssim,
    LessSlantEqual: LessSlantEqual,
    LessTilde: LessTilde,
    lfisht: lfisht,
    lfloor: lfloor,
    Lfr: Lfr,
    lfr: lfr,
    lg: lg,
    lgE: lgE,
    lHar: lHar,
    lhard: lhard,
    lharu: lharu,
    lharul: lharul,
    lhblk: lhblk,
    LJcy: LJcy,
    ljcy: ljcy,
    llarr: llarr,
    ll: ll,
    Ll: Ll,
    llcorner: llcorner,
    Lleftarrow: Lleftarrow,
    llhard: llhard,
    lltri: lltri,
    Lmidot: Lmidot,
    lmidot: lmidot,
    lmoustache: lmoustache,
    lmoust: lmoust,
    lnap: lnap,
    lnapprox: lnapprox,
    lne: lne,
    lnE: lnE,
    lneq: lneq,
    lneqq: lneqq,
    lnsim: lnsim,
    loang: loang,
    loarr: loarr,
    lobrk: lobrk,
    longleftarrow: longleftarrow,
    LongLeftArrow: LongLeftArrow,
    Longleftarrow: Longleftarrow,
    longleftrightarrow: longleftrightarrow,
    LongLeftRightArrow: LongLeftRightArrow,
    Longleftrightarrow: Longleftrightarrow,
    longmapsto: longmapsto,
    longrightarrow: longrightarrow,
    LongRightArrow: LongRightArrow,
    Longrightarrow: Longrightarrow,
    looparrowleft: looparrowleft,
    looparrowright: looparrowright,
    lopar: lopar,
    Lopf: Lopf,
    lopf: lopf,
    loplus: loplus,
    lotimes: lotimes,
    lowast: lowast,
    lowbar: lowbar,
    LowerLeftArrow: LowerLeftArrow,
    LowerRightArrow: LowerRightArrow,
    loz: loz,
    lozenge: lozenge,
    lozf: lozf,
    lpar: lpar,
    lparlt: lparlt,
    lrarr: lrarr,
    lrcorner: lrcorner,
    lrhar: lrhar,
    lrhard: lrhard,
    lrm: lrm,
    lrtri: lrtri,
    lsaquo: lsaquo,
    lscr: lscr,
    Lscr: Lscr,
    lsh: lsh,
    Lsh: Lsh,
    lsim: lsim,
    lsime: lsime,
    lsimg: lsimg,
    lsqb: lsqb,
    lsquo: lsquo,
    lsquor: lsquor,
    Lstrok: Lstrok,
    lstrok: lstrok,
    ltcc: ltcc,
    ltcir: ltcir,
    lt: lt,
    LT: LT,
    Lt: Lt,
    ltdot: ltdot,
    lthree: lthree,
    ltimes: ltimes,
    ltlarr: ltlarr,
    ltquest: ltquest,
    ltri: ltri,
    ltrie: ltrie,
    ltrif: ltrif,
    ltrPar: ltrPar,
    lurdshar: lurdshar,
    luruhar: luruhar,
    lvertneqq: lvertneqq,
    lvnE: lvnE,
    macr: macr,
    male: male,
    malt: malt,
    maltese: maltese,
    map: map$1,
    mapsto: mapsto,
    mapstodown: mapstodown,
    mapstoleft: mapstoleft,
    mapstoup: mapstoup,
    marker: marker$1,
    mcomma: mcomma,
    Mcy: Mcy,
    mcy: mcy,
    mdash: mdash,
    mDDot: mDDot,
    measuredangle: measuredangle,
    MediumSpace: MediumSpace,
    Mellintrf: Mellintrf,
    Mfr: Mfr,
    mfr: mfr,
    mho: mho,
    micro: micro,
    midast: midast,
    midcir: midcir,
    mid: mid,
    middot: middot,
    minusb: minusb,
    minus: minus,
    minusd: minusd,
    minusdu: minusdu,
    MinusPlus: MinusPlus,
    mlcp: mlcp,
    mldr: mldr,
    mnplus: mnplus,
    models: models,
    Mopf: Mopf,
    mopf: mopf,
    mp: mp,
    mscr: mscr,
    Mscr: Mscr,
    mstpos: mstpos,
    Mu: Mu,
    mu: mu,
    multimap: multimap,
    mumap: mumap,
    nabla: nabla,
    Nacute: Nacute,
    nacute: nacute,
    nang: nang,
    nap: nap,
    napE: napE,
    napid: napid,
    napos: napos,
    napprox: napprox,
    natural: natural,
    naturals: naturals,
    natur: natur,
    nbsp: nbsp,
    nbump: nbump,
    nbumpe: nbumpe,
    ncap: ncap,
    Ncaron: Ncaron,
    ncaron: ncaron,
    Ncedil: Ncedil,
    ncedil: ncedil,
    ncong: ncong,
    ncongdot: ncongdot,
    ncup: ncup,
    Ncy: Ncy,
    ncy: ncy,
    ndash: ndash,
    nearhk: nearhk,
    nearr: nearr,
    neArr: neArr,
    nearrow: nearrow,
    ne: ne,
    nedot: nedot,
    NegativeMediumSpace: NegativeMediumSpace,
    NegativeThickSpace: NegativeThickSpace,
    NegativeThinSpace: NegativeThinSpace,
    NegativeVeryThinSpace: NegativeVeryThinSpace,
    nequiv: nequiv,
    nesear: nesear,
    nesim: nesim,
    NestedGreaterGreater: NestedGreaterGreater,
    NestedLessLess: NestedLessLess,
    NewLine: NewLine,
    nexist: nexist,
    nexists: nexists,
    Nfr: Nfr,
    nfr: nfr,
    ngE: ngE,
    nge: nge,
    ngeq: ngeq,
    ngeqq: ngeqq,
    ngeqslant: ngeqslant,
    nges: nges,
    nGg: nGg,
    ngsim: ngsim,
    nGt: nGt,
    ngt: ngt,
    ngtr: ngtr,
    nGtv: nGtv,
    nharr: nharr,
    nhArr: nhArr,
    nhpar: nhpar,
    ni: ni,
    nis: nis,
    nisd: nisd,
    niv: niv,
    NJcy: NJcy,
    njcy: njcy,
    nlarr: nlarr,
    nlArr: nlArr,
    nldr: nldr,
    nlE: nlE,
    nle: nle,
    nleftarrow: nleftarrow,
    nLeftarrow: nLeftarrow,
    nleftrightarrow: nleftrightarrow,
    nLeftrightarrow: nLeftrightarrow,
    nleq: nleq,
    nleqq: nleqq,
    nleqslant: nleqslant,
    nles: nles,
    nless: nless,
    nLl: nLl,
    nlsim: nlsim,
    nLt: nLt,
    nlt: nlt,
    nltri: nltri,
    nltrie: nltrie,
    nLtv: nLtv,
    nmid: nmid,
    NoBreak: NoBreak,
    NonBreakingSpace: NonBreakingSpace,
    nopf: nopf,
    Nopf: Nopf,
    Not: Not,
    not: not$1,
    NotCongruent: NotCongruent,
    NotCupCap: NotCupCap,
    NotDoubleVerticalBar: NotDoubleVerticalBar,
    NotElement: NotElement,
    NotEqual: NotEqual,
    NotEqualTilde: NotEqualTilde,
    NotExists: NotExists,
    NotGreater: NotGreater,
    NotGreaterEqual: NotGreaterEqual,
    NotGreaterFullEqual: NotGreaterFullEqual,
    NotGreaterGreater: NotGreaterGreater,
    NotGreaterLess: NotGreaterLess,
    NotGreaterSlantEqual: NotGreaterSlantEqual,
    NotGreaterTilde: NotGreaterTilde,
    NotHumpDownHump: NotHumpDownHump,
    NotHumpEqual: NotHumpEqual,
    notin: notin,
    notindot: notindot,
    notinE: notinE,
    notinva: notinva,
    notinvb: notinvb,
    notinvc: notinvc,
    NotLeftTriangleBar: NotLeftTriangleBar,
    NotLeftTriangle: NotLeftTriangle,
    NotLeftTriangleEqual: NotLeftTriangleEqual,
    NotLess: NotLess,
    NotLessEqual: NotLessEqual,
    NotLessGreater: NotLessGreater,
    NotLessLess: NotLessLess,
    NotLessSlantEqual: NotLessSlantEqual,
    NotLessTilde: NotLessTilde,
    NotNestedGreaterGreater: NotNestedGreaterGreater,
    NotNestedLessLess: NotNestedLessLess,
    notni: notni,
    notniva: notniva,
    notnivb: notnivb,
    notnivc: notnivc,
    NotPrecedes: NotPrecedes,
    NotPrecedesEqual: NotPrecedesEqual,
    NotPrecedesSlantEqual: NotPrecedesSlantEqual,
    NotReverseElement: NotReverseElement,
    NotRightTriangleBar: NotRightTriangleBar,
    NotRightTriangle: NotRightTriangle,
    NotRightTriangleEqual: NotRightTriangleEqual,
    NotSquareSubset: NotSquareSubset,
    NotSquareSubsetEqual: NotSquareSubsetEqual,
    NotSquareSuperset: NotSquareSuperset,
    NotSquareSupersetEqual: NotSquareSupersetEqual,
    NotSubset: NotSubset,
    NotSubsetEqual: NotSubsetEqual,
    NotSucceeds: NotSucceeds,
    NotSucceedsEqual: NotSucceedsEqual,
    NotSucceedsSlantEqual: NotSucceedsSlantEqual,
    NotSucceedsTilde: NotSucceedsTilde,
    NotSuperset: NotSuperset,
    NotSupersetEqual: NotSupersetEqual,
    NotTilde: NotTilde,
    NotTildeEqual: NotTildeEqual,
    NotTildeFullEqual: NotTildeFullEqual,
    NotTildeTilde: NotTildeTilde,
    NotVerticalBar: NotVerticalBar,
    nparallel: nparallel,
    npar: npar,
    nparsl: nparsl,
    npart: npart,
    npolint: npolint,
    npr: npr,
    nprcue: nprcue,
    nprec: nprec,
    npreceq: npreceq,
    npre: npre,
    nrarrc: nrarrc,
    nrarr: nrarr,
    nrArr: nrArr,
    nrarrw: nrarrw,
    nrightarrow: nrightarrow,
    nRightarrow: nRightarrow,
    nrtri: nrtri,
    nrtrie: nrtrie,
    nsc: nsc,
    nsccue: nsccue,
    nsce: nsce,
    Nscr: Nscr,
    nscr: nscr,
    nshortmid: nshortmid,
    nshortparallel: nshortparallel,
    nsim: nsim,
    nsime: nsime,
    nsimeq: nsimeq,
    nsmid: nsmid,
    nspar: nspar,
    nsqsube: nsqsube,
    nsqsupe: nsqsupe,
    nsub: nsub,
    nsubE: nsubE,
    nsube: nsube,
    nsubset: nsubset,
    nsubseteq: nsubseteq,
    nsubseteqq: nsubseteqq,
    nsucc: nsucc,
    nsucceq: nsucceq,
    nsup: nsup,
    nsupE: nsupE,
    nsupe: nsupe,
    nsupset: nsupset,
    nsupseteq: nsupseteq,
    nsupseteqq: nsupseteqq,
    ntgl: ntgl,
    Ntilde: Ntilde,
    ntilde: ntilde,
    ntlg: ntlg,
    ntriangleleft: ntriangleleft,
    ntrianglelefteq: ntrianglelefteq,
    ntriangleright: ntriangleright,
    ntrianglerighteq: ntrianglerighteq,
    Nu: Nu,
    nu: nu,
    num: num,
    numero: numero,
    numsp: numsp,
    nvap: nvap,
    nvdash: nvdash,
    nvDash: nvDash,
    nVdash: nVdash,
    nVDash: nVDash,
    nvge: nvge,
    nvgt: nvgt,
    nvHarr: nvHarr,
    nvinfin: nvinfin,
    nvlArr: nvlArr,
    nvle: nvle,
    nvlt: nvlt,
    nvltrie: nvltrie,
    nvrArr: nvrArr,
    nvrtrie: nvrtrie,
    nvsim: nvsim,
    nwarhk: nwarhk,
    nwarr: nwarr,
    nwArr: nwArr,
    nwarrow: nwarrow,
    nwnear: nwnear,
    Oacute: Oacute,
    oacute: oacute,
    oast: oast,
    Ocirc: Ocirc,
    ocirc: ocirc,
    ocir: ocir,
    Ocy: Ocy,
    ocy: ocy,
    odash: odash,
    Odblac: Odblac,
    odblac: odblac,
    odiv: odiv,
    odot: odot,
    odsold: odsold,
    OElig: OElig,
    oelig: oelig,
    ofcir: ofcir,
    Ofr: Ofr,
    ofr: ofr,
    ogon: ogon,
    Ograve: Ograve,
    ograve: ograve,
    ogt: ogt,
    ohbar: ohbar,
    ohm: ohm,
    oint: oint,
    olarr: olarr,
    olcir: olcir,
    olcross: olcross,
    oline: oline,
    olt: olt,
    Omacr: Omacr,
    omacr: omacr,
    Omega: Omega,
    omega: omega,
    Omicron: Omicron,
    omicron: omicron,
    omid: omid,
    ominus: ominus,
    Oopf: Oopf,
    oopf: oopf,
    opar: opar,
    OpenCurlyDoubleQuote: OpenCurlyDoubleQuote,
    OpenCurlyQuote: OpenCurlyQuote,
    operp: operp,
    oplus: oplus,
    orarr: orarr,
    Or: Or,
    or: or,
    ord: ord,
    order: order,
    orderof: orderof,
    ordf: ordf,
    ordm: ordm,
    origof: origof,
    oror: oror,
    orslope: orslope,
    orv: orv,
    oS: oS,
    Oscr: Oscr,
    oscr: oscr,
    Oslash: Oslash,
    oslash: oslash,
    osol: osol,
    Otilde: Otilde,
    otilde: otilde,
    otimesas: otimesas,
    Otimes: Otimes,
    otimes: otimes,
    Ouml: Ouml,
    ouml: ouml,
    ovbar: ovbar,
    OverBar: OverBar,
    OverBrace: OverBrace,
    OverBracket: OverBracket,
    OverParenthesis: OverParenthesis,
    para: para,
    parallel: parallel,
    par: par,
    parsim: parsim,
    parsl: parsl,
    part: part,
    PartialD: PartialD,
    Pcy: Pcy,
    pcy: pcy,
    percnt: percnt,
    period: period,
    permil: permil,
    perp: perp,
    pertenk: pertenk,
    Pfr: Pfr,
    pfr: pfr,
    Phi: Phi,
    phi: phi,
    phiv: phiv,
    phmmat: phmmat,
    phone: phone,
    Pi: Pi,
    pi: pi,
    pitchfork: pitchfork,
    piv: piv,
    planck: planck,
    planckh: planckh,
    plankv: plankv,
    plusacir: plusacir,
    plusb: plusb,
    pluscir: pluscir,
    plus: plus,
    plusdo: plusdo,
    plusdu: plusdu,
    pluse: pluse,
    PlusMinus: PlusMinus,
    plusmn: plusmn,
    plussim: plussim,
    plustwo: plustwo,
    pm: pm,
    Poincareplane: Poincareplane,
    pointint: pointint,
    popf: popf,
    Popf: Popf,
    pound: pound,
    prap: prap,
    Pr: Pr,
    pr: pr,
    prcue: prcue,
    precapprox: precapprox,
    prec: prec,
    preccurlyeq: preccurlyeq,
    Precedes: Precedes,
    PrecedesEqual: PrecedesEqual,
    PrecedesSlantEqual: PrecedesSlantEqual,
    PrecedesTilde: PrecedesTilde,
    preceq: preceq,
    precnapprox: precnapprox,
    precneqq: precneqq,
    precnsim: precnsim,
    pre: pre,
    prE: prE,
    precsim: precsim,
    prime: prime,
    Prime: Prime,
    primes: primes,
    prnap: prnap,
    prnE: prnE,
    prnsim: prnsim,
    prod: prod,
    Product: Product,
    profalar: profalar,
    profline: profline,
    profsurf: profsurf,
    prop: prop,
    Proportional: Proportional,
    Proportion: Proportion,
    propto: propto,
    prsim: prsim,
    prurel: prurel,
    Pscr: Pscr,
    pscr: pscr,
    Psi: Psi,
    psi: psi,
    puncsp: puncsp,
    Qfr: Qfr,
    qfr: qfr,
    qint: qint,
    qopf: qopf,
    Qopf: Qopf,
    qprime: qprime,
    Qscr: Qscr,
    qscr: qscr,
    quaternions: quaternions,
    quatint: quatint,
    quest: quest,
    questeq: questeq,
    quot: quot,
    QUOT: QUOT,
    rAarr: rAarr,
    race: race$1,
    Racute: Racute,
    racute: racute,
    radic: radic,
    raemptyv: raemptyv,
    rang: rang,
    Rang: Rang,
    rangd: rangd,
    range: range$1,
    rangle: rangle,
    raquo: raquo,
    rarrap: rarrap,
    rarrb: rarrb,
    rarrbfs: rarrbfs,
    rarrc: rarrc,
    rarr: rarr,
    Rarr: Rarr,
    rArr: rArr,
    rarrfs: rarrfs,
    rarrhk: rarrhk,
    rarrlp: rarrlp,
    rarrpl: rarrpl,
    rarrsim: rarrsim,
    Rarrtl: Rarrtl,
    rarrtl: rarrtl,
    rarrw: rarrw,
    ratail: ratail,
    rAtail: rAtail,
    ratio: ratio,
    rationals: rationals,
    rbarr: rbarr,
    rBarr: rBarr,
    RBarr: RBarr,
    rbbrk: rbbrk,
    rbrace: rbrace,
    rbrack: rbrack,
    rbrke: rbrke,
    rbrksld: rbrksld,
    rbrkslu: rbrkslu,
    Rcaron: Rcaron,
    rcaron: rcaron,
    Rcedil: Rcedil,
    rcedil: rcedil,
    rceil: rceil,
    rcub: rcub,
    Rcy: Rcy,
    rcy: rcy,
    rdca: rdca,
    rdldhar: rdldhar,
    rdquo: rdquo,
    rdquor: rdquor,
    rdsh: rdsh,
    real: real,
    realine: realine,
    realpart: realpart,
    reals: reals,
    Re: Re,
    rect: rect,
    reg: reg,
    REG: REG,
    ReverseElement: ReverseElement,
    ReverseEquilibrium: ReverseEquilibrium,
    ReverseUpEquilibrium: ReverseUpEquilibrium,
    rfisht: rfisht,
    rfloor: rfloor,
    rfr: rfr,
    Rfr: Rfr,
    rHar: rHar,
    rhard: rhard,
    rharu: rharu,
    rharul: rharul,
    Rho: Rho,
    rho: rho,
    rhov: rhov,
    RightAngleBracket: RightAngleBracket,
    RightArrowBar: RightArrowBar,
    rightarrow: rightarrow,
    RightArrow: RightArrow,
    Rightarrow: Rightarrow,
    RightArrowLeftArrow: RightArrowLeftArrow,
    rightarrowtail: rightarrowtail,
    RightCeiling: RightCeiling,
    RightDoubleBracket: RightDoubleBracket,
    RightDownTeeVector: RightDownTeeVector,
    RightDownVectorBar: RightDownVectorBar,
    RightDownVector: RightDownVector,
    RightFloor: RightFloor,
    rightharpoondown: rightharpoondown,
    rightharpoonup: rightharpoonup,
    rightleftarrows: rightleftarrows,
    rightleftharpoons: rightleftharpoons,
    rightrightarrows: rightrightarrows,
    rightsquigarrow: rightsquigarrow,
    RightTeeArrow: RightTeeArrow,
    RightTee: RightTee,
    RightTeeVector: RightTeeVector,
    rightthreetimes: rightthreetimes,
    RightTriangleBar: RightTriangleBar,
    RightTriangle: RightTriangle,
    RightTriangleEqual: RightTriangleEqual,
    RightUpDownVector: RightUpDownVector,
    RightUpTeeVector: RightUpTeeVector,
    RightUpVectorBar: RightUpVectorBar,
    RightUpVector: RightUpVector,
    RightVectorBar: RightVectorBar,
    RightVector: RightVector,
    ring: ring,
    risingdotseq: risingdotseq,
    rlarr: rlarr,
    rlhar: rlhar,
    rlm: rlm,
    rmoustache: rmoustache,
    rmoust: rmoust,
    rnmid: rnmid,
    roang: roang,
    roarr: roarr,
    robrk: robrk,
    ropar: ropar,
    ropf: ropf,
    Ropf: Ropf,
    roplus: roplus,
    rotimes: rotimes,
    RoundImplies: RoundImplies,
    rpar: rpar,
    rpargt: rpargt,
    rppolint: rppolint,
    rrarr: rrarr,
    Rrightarrow: Rrightarrow,
    rsaquo: rsaquo,
    rscr: rscr,
    Rscr: Rscr,
    rsh: rsh,
    Rsh: Rsh,
    rsqb: rsqb,
    rsquo: rsquo,
    rsquor: rsquor,
    rthree: rthree,
    rtimes: rtimes,
    rtri: rtri,
    rtrie: rtrie,
    rtrif: rtrif,
    rtriltri: rtriltri,
    RuleDelayed: RuleDelayed,
    ruluhar: ruluhar,
    rx: rx,
    Sacute: Sacute,
    sacute: sacute,
    sbquo: sbquo,
    scap: scap,
    Scaron: Scaron,
    scaron: scaron,
    Sc: Sc,
    sc: sc,
    sccue: sccue,
    sce: sce,
    scE: scE,
    Scedil: Scedil,
    scedil: scedil,
    Scirc: Scirc,
    scirc: scirc,
    scnap: scnap,
    scnE: scnE,
    scnsim: scnsim,
    scpolint: scpolint,
    scsim: scsim,
    Scy: Scy,
    scy: scy,
    sdotb: sdotb,
    sdot: sdot,
    sdote: sdote,
    searhk: searhk,
    searr: searr,
    seArr: seArr,
    searrow: searrow,
    sect: sect,
    semi: semi,
    seswar: seswar,
    setminus: setminus,
    setmn: setmn,
    sext: sext,
    Sfr: Sfr,
    sfr: sfr,
    sfrown: sfrown,
    sharp: sharp,
    SHCHcy: SHCHcy,
    shchcy: shchcy,
    SHcy: SHcy,
    shcy: shcy,
    ShortDownArrow: ShortDownArrow,
    ShortLeftArrow: ShortLeftArrow,
    shortmid: shortmid,
    shortparallel: shortparallel,
    ShortRightArrow: ShortRightArrow,
    ShortUpArrow: ShortUpArrow,
    shy: shy,
    Sigma: Sigma,
    sigma: sigma,
    sigmaf: sigmaf,
    sigmav: sigmav,
    sim: sim,
    simdot: simdot,
    sime: sime,
    simeq: simeq,
    simg: simg,
    simgE: simgE,
    siml: siml,
    simlE: simlE,
    simne: simne,
    simplus: simplus,
    simrarr: simrarr,
    slarr: slarr,
    SmallCircle: SmallCircle,
    smallsetminus: smallsetminus,
    smashp: smashp,
    smeparsl: smeparsl,
    smid: smid,
    smile: smile,
    smt: smt,
    smte: smte,
    smtes: smtes,
    SOFTcy: SOFTcy,
    softcy: softcy,
    solbar: solbar,
    solb: solb,
    sol: sol,
    Sopf: Sopf,
    sopf: sopf,
    spades: spades,
    spadesuit: spadesuit,
    spar: spar,
    sqcap: sqcap,
    sqcaps: sqcaps,
    sqcup: sqcup,
    sqcups: sqcups,
    Sqrt: Sqrt,
    sqsub: sqsub,
    sqsube: sqsube,
    sqsubset: sqsubset,
    sqsubseteq: sqsubseteq,
    sqsup: sqsup,
    sqsupe: sqsupe,
    sqsupset: sqsupset,
    sqsupseteq: sqsupseteq,
    square: square,
    Square: Square,
    SquareIntersection: SquareIntersection,
    SquareSubset: SquareSubset,
    SquareSubsetEqual: SquareSubsetEqual,
    SquareSuperset: SquareSuperset,
    SquareSupersetEqual: SquareSupersetEqual,
    SquareUnion: SquareUnion,
    squarf: squarf,
    squ: squ,
    squf: squf,
    srarr: srarr,
    Sscr: Sscr,
    sscr: sscr,
    ssetmn: ssetmn,
    ssmile: ssmile,
    sstarf: sstarf,
    Star: Star,
    star: star,
    starf: starf,
    straightepsilon: straightepsilon,
    straightphi: straightphi,
    strns: strns,
    sub: sub,
    Sub: Sub,
    subdot: subdot,
    subE: subE,
    sube: sube,
    subedot: subedot,
    submult: submult,
    subnE: subnE,
    subne: subne,
    subplus: subplus,
    subrarr: subrarr,
    subset: subset,
    Subset: Subset,
    subseteq: subseteq,
    subseteqq: subseteqq,
    SubsetEqual: SubsetEqual,
    subsetneq: subsetneq,
    subsetneqq: subsetneqq,
    subsim: subsim,
    subsub: subsub,
    subsup: subsup,
    succapprox: succapprox,
    succ: succ,
    succcurlyeq: succcurlyeq,
    Succeeds: Succeeds,
    SucceedsEqual: SucceedsEqual,
    SucceedsSlantEqual: SucceedsSlantEqual,
    SucceedsTilde: SucceedsTilde,
    succeq: succeq,
    succnapprox: succnapprox,
    succneqq: succneqq,
    succnsim: succnsim,
    succsim: succsim,
    SuchThat: SuchThat,
    sum: sum,
    Sum: Sum,
    sung: sung,
    sup1: sup1,
    sup2: sup2,
    sup3: sup3,
    sup: sup,
    Sup: Sup,
    supdot: supdot,
    supdsub: supdsub,
    supE: supE,
    supe: supe,
    supedot: supedot,
    Superset: Superset,
    SupersetEqual: SupersetEqual,
    suphsol: suphsol,
    suphsub: suphsub,
    suplarr: suplarr,
    supmult: supmult,
    supnE: supnE,
    supne: supne,
    supplus: supplus,
    supset: supset,
    Supset: Supset,
    supseteq: supseteq,
    supseteqq: supseteqq,
    supsetneq: supsetneq,
    supsetneqq: supsetneqq,
    supsim: supsim,
    supsub: supsub,
    supsup: supsup,
    swarhk: swarhk,
    swarr: swarr,
    swArr: swArr,
    swarrow: swarrow,
    swnwar: swnwar,
    szlig: szlig,
    Tab: Tab,
    target: target,
    Tau: Tau,
    tau: tau,
    tbrk: tbrk,
    Tcaron: Tcaron,
    tcaron: tcaron,
    Tcedil: Tcedil,
    tcedil: tcedil,
    Tcy: Tcy,
    tcy: tcy,
    tdot: tdot,
    telrec: telrec,
    Tfr: Tfr,
    tfr: tfr,
    there4: there4,
    therefore: therefore,
    Therefore: Therefore,
    Theta: Theta,
    theta: theta,
    thetasym: thetasym,
    thetav: thetav,
    thickapprox: thickapprox,
    thicksim: thicksim,
    ThickSpace: ThickSpace,
    ThinSpace: ThinSpace,
    thinsp: thinsp,
    thkap: thkap,
    thksim: thksim,
    THORN: THORN,
    thorn: thorn,
    tilde: tilde,
    Tilde: Tilde,
    TildeEqual: TildeEqual,
    TildeFullEqual: TildeFullEqual,
    TildeTilde: TildeTilde,
    timesbar: timesbar,
    timesb: timesb,
    times: times,
    timesd: timesd,
    tint: tint,
    toea: toea,
    topbot: topbot,
    topcir: topcir,
    top: top,
    Topf: Topf,
    topf: topf,
    topfork: topfork,
    tosa: tosa,
    tprime: tprime,
    trade: trade,
    TRADE: TRADE,
    triangle: triangle,
    triangledown: triangledown,
    triangleleft: triangleleft,
    trianglelefteq: trianglelefteq,
    triangleq: triangleq,
    triangleright: triangleright,
    trianglerighteq: trianglerighteq,
    tridot: tridot,
    trie: trie,
    triminus: triminus,
    TripleDot: TripleDot,
    triplus: triplus,
    trisb: trisb,
    tritime: tritime,
    trpezium: trpezium,
    Tscr: Tscr,
    tscr: tscr,
    TScy: TScy,
    tscy: tscy,
    TSHcy: TSHcy,
    tshcy: tshcy,
    Tstrok: Tstrok,
    tstrok: tstrok,
    twixt: twixt,
    twoheadleftarrow: twoheadleftarrow,
    twoheadrightarrow: twoheadrightarrow,
    Uacute: Uacute,
    uacute: uacute,
    uarr: uarr,
    Uarr: Uarr,
    uArr: uArr,
    Uarrocir: Uarrocir,
    Ubrcy: Ubrcy,
    ubrcy: ubrcy,
    Ubreve: Ubreve,
    ubreve: ubreve,
    Ucirc: Ucirc,
    ucirc: ucirc,
    Ucy: Ucy,
    ucy: ucy,
    udarr: udarr,
    Udblac: Udblac,
    udblac: udblac,
    udhar: udhar,
    ufisht: ufisht,
    Ufr: Ufr,
    ufr: ufr,
    Ugrave: Ugrave,
    ugrave: ugrave,
    uHar: uHar,
    uharl: uharl,
    uharr: uharr,
    uhblk: uhblk,
    ulcorn: ulcorn,
    ulcorner: ulcorner,
    ulcrop: ulcrop,
    ultri: ultri,
    Umacr: Umacr,
    umacr: umacr,
    uml: uml,
    UnderBar: UnderBar,
    UnderBrace: UnderBrace,
    UnderBracket: UnderBracket,
    UnderParenthesis: UnderParenthesis,
    Union: Union,
    UnionPlus: UnionPlus,
    Uogon: Uogon,
    uogon: uogon,
    Uopf: Uopf,
    uopf: uopf,
    UpArrowBar: UpArrowBar,
    uparrow: uparrow,
    UpArrow: UpArrow,
    Uparrow: Uparrow,
    UpArrowDownArrow: UpArrowDownArrow,
    updownarrow: updownarrow,
    UpDownArrow: UpDownArrow,
    Updownarrow: Updownarrow,
    UpEquilibrium: UpEquilibrium,
    upharpoonleft: upharpoonleft,
    upharpoonright: upharpoonright,
    uplus: uplus,
    UpperLeftArrow: UpperLeftArrow,
    UpperRightArrow: UpperRightArrow,
    upsi: upsi,
    Upsi: Upsi,
    upsih: upsih,
    Upsilon: Upsilon,
    upsilon: upsilon,
    UpTeeArrow: UpTeeArrow,
    UpTee: UpTee,
    upuparrows: upuparrows,
    urcorn: urcorn,
    urcorner: urcorner,
    urcrop: urcrop,
    Uring: Uring,
    uring: uring,
    urtri: urtri,
    Uscr: Uscr,
    uscr: uscr,
    utdot: utdot,
    Utilde: Utilde,
    utilde: utilde,
    utri: utri,
    utrif: utrif,
    uuarr: uuarr,
    Uuml: Uuml,
    uuml: uuml,
    uwangle: uwangle,
    vangrt: vangrt,
    varepsilon: varepsilon,
    varkappa: varkappa,
    varnothing: varnothing,
    varphi: varphi,
    varpi: varpi,
    varpropto: varpropto,
    varr: varr,
    vArr: vArr,
    varrho: varrho,
    varsigma: varsigma,
    varsubsetneq: varsubsetneq,
    varsubsetneqq: varsubsetneqq,
    varsupsetneq: varsupsetneq,
    varsupsetneqq: varsupsetneqq,
    vartheta: vartheta,
    vartriangleleft: vartriangleleft,
    vartriangleright: vartriangleright,
    vBar: vBar,
    Vbar: Vbar,
    vBarv: vBarv,
    Vcy: Vcy,
    vcy: vcy,
    vdash: vdash,
    vDash: vDash,
    Vdash: Vdash,
    VDash: VDash,
    Vdashl: Vdashl,
    veebar: veebar,
    vee: vee,
    Vee: Vee,
    veeeq: veeeq,
    vellip: vellip,
    verbar: verbar,
    Verbar: Verbar,
    vert: vert,
    Vert: Vert,
    VerticalBar: VerticalBar,
    VerticalLine: VerticalLine,
    VerticalSeparator: VerticalSeparator,
    VerticalTilde: VerticalTilde,
    VeryThinSpace: VeryThinSpace,
    Vfr: Vfr,
    vfr: vfr,
    vltri: vltri,
    vnsub: vnsub,
    vnsup: vnsup,
    Vopf: Vopf,
    vopf: vopf,
    vprop: vprop,
    vrtri: vrtri,
    Vscr: Vscr,
    vscr: vscr,
    vsubnE: vsubnE,
    vsubne: vsubne,
    vsupnE: vsupnE,
    vsupne: vsupne,
    Vvdash: Vvdash,
    vzigzag: vzigzag,
    Wcirc: Wcirc,
    wcirc: wcirc,
    wedbar: wedbar,
    wedge: wedge,
    Wedge: Wedge,
    wedgeq: wedgeq,
    weierp: weierp,
    Wfr: Wfr,
    wfr: wfr,
    Wopf: Wopf,
    wopf: wopf,
    wp: wp,
    wr: wr,
    wreath: wreath,
    Wscr: Wscr,
    wscr: wscr,
    xcap: xcap,
    xcirc: xcirc,
    xcup: xcup,
    xdtri: xdtri,
    Xfr: Xfr,
    xfr: xfr,
    xharr: xharr,
    xhArr: xhArr,
    Xi: Xi,
    xi: xi,
    xlarr: xlarr,
    xlArr: xlArr,
    xmap: xmap,
    xnis: xnis,
    xodot: xodot,
    Xopf: Xopf,
    xopf: xopf,
    xoplus: xoplus,
    xotime: xotime,
    xrarr: xrarr,
    xrArr: xrArr,
    Xscr: Xscr,
    xscr: xscr,
    xsqcup: xsqcup,
    xuplus: xuplus,
    xutri: xutri,
    xvee: xvee,
    xwedge: xwedge,
    Yacute: Yacute,
    yacute: yacute,
    YAcy: YAcy,
    yacy: yacy,
    Ycirc: Ycirc,
    ycirc: ycirc,
    Ycy: Ycy,
    ycy: ycy,
    yen: yen,
    Yfr: Yfr,
    yfr: yfr,
    YIcy: YIcy,
    yicy: yicy,
    Yopf: Yopf,
    yopf: yopf,
    Yscr: Yscr,
    yscr: yscr,
    YUcy: YUcy,
    yucy: yucy,
    yuml: yuml,
    Yuml: Yuml,
    Zacute: Zacute,
    zacute: zacute,
    Zcaron: Zcaron,
    zcaron: zcaron,
    Zcy: Zcy,
    zcy: zcy,
    Zdot: Zdot,
    zdot: zdot,
    zeetrf: zeetrf,
    ZeroWidthSpace: ZeroWidthSpace,
    Zeta: Zeta,
    zeta: zeta,
    zfr: zfr,
    Zfr: Zfr,
    ZHcy: ZHcy,
    zhcy: zhcy,
    zigrarr: zigrarr,
    zopf: zopf,
    Zopf: Zopf,
    Zscr: Zscr,
    zscr: zscr,
    zwj: zwj,
    zwnj: zwnj,
    "in": "∈",
    "Map": "⤅"
  };

  var entities$1 = /*#__PURE__*/Object.freeze({
    Aacute: Aacute,
    aacute: aacute,
    Abreve: Abreve,
    abreve: abreve,
    ac: ac,
    acd: acd,
    acE: acE,
    Acirc: Acirc,
    acirc: acirc,
    acute: acute,
    Acy: Acy,
    acy: acy,
    AElig: AElig,
    aelig: aelig,
    af: af,
    Afr: Afr,
    afr: afr,
    Agrave: Agrave,
    agrave: agrave,
    alefsym: alefsym,
    aleph: aleph,
    Alpha: Alpha,
    alpha: alpha,
    Amacr: Amacr,
    amacr: amacr,
    amalg: amalg,
    amp: amp,
    AMP: AMP,
    andand: andand,
    And: And,
    and: and,
    andd: andd,
    andslope: andslope,
    andv: andv,
    ang: ang,
    ange: ange,
    angle: angle,
    angmsdaa: angmsdaa,
    angmsdab: angmsdab,
    angmsdac: angmsdac,
    angmsdad: angmsdad,
    angmsdae: angmsdae,
    angmsdaf: angmsdaf,
    angmsdag: angmsdag,
    angmsdah: angmsdah,
    angmsd: angmsd,
    angrt: angrt,
    angrtvb: angrtvb,
    angrtvbd: angrtvbd,
    angsph: angsph,
    angst: angst,
    angzarr: angzarr,
    Aogon: Aogon,
    aogon: aogon,
    Aopf: Aopf,
    aopf: aopf,
    apacir: apacir,
    ap: ap,
    apE: apE,
    ape: ape,
    apid: apid,
    apos: apos,
    ApplyFunction: ApplyFunction,
    approx: approx,
    approxeq: approxeq,
    Aring: Aring,
    aring: aring,
    Ascr: Ascr,
    ascr: ascr,
    Assign: Assign,
    ast: ast,
    asymp: asymp,
    asympeq: asympeq,
    Atilde: Atilde,
    atilde: atilde,
    Auml: Auml,
    auml: auml,
    awconint: awconint,
    awint: awint,
    backcong: backcong,
    backepsilon: backepsilon,
    backprime: backprime,
    backsim: backsim,
    backsimeq: backsimeq,
    Backslash: Backslash,
    Barv: Barv,
    barvee: barvee,
    barwed: barwed,
    Barwed: Barwed,
    barwedge: barwedge,
    bbrk: bbrk,
    bbrktbrk: bbrktbrk,
    bcong: bcong,
    Bcy: Bcy,
    bcy: bcy,
    bdquo: bdquo,
    becaus: becaus,
    because: because,
    Because: Because,
    bemptyv: bemptyv,
    bepsi: bepsi,
    bernou: bernou,
    Bernoullis: Bernoullis,
    Beta: Beta,
    beta: beta,
    beth: beth,
    between: between,
    Bfr: Bfr,
    bfr: bfr,
    bigcap: bigcap,
    bigcirc: bigcirc,
    bigcup: bigcup,
    bigodot: bigodot,
    bigoplus: bigoplus,
    bigotimes: bigotimes,
    bigsqcup: bigsqcup,
    bigstar: bigstar,
    bigtriangledown: bigtriangledown,
    bigtriangleup: bigtriangleup,
    biguplus: biguplus,
    bigvee: bigvee,
    bigwedge: bigwedge,
    bkarow: bkarow,
    blacklozenge: blacklozenge,
    blacksquare: blacksquare,
    blacktriangle: blacktriangle,
    blacktriangledown: blacktriangledown,
    blacktriangleleft: blacktriangleleft,
    blacktriangleright: blacktriangleright,
    blank: blank,
    blk12: blk12,
    blk14: blk14,
    blk34: blk34,
    block: block,
    bne: bne,
    bnequiv: bnequiv,
    bNot: bNot,
    bnot: bnot,
    Bopf: Bopf,
    bopf: bopf,
    bot: bot,
    bottom: bottom,
    bowtie: bowtie,
    boxbox: boxbox,
    boxdl: boxdl,
    boxdL: boxdL,
    boxDl: boxDl,
    boxDL: boxDL,
    boxdr: boxdr,
    boxdR: boxdR,
    boxDr: boxDr,
    boxDR: boxDR,
    boxh: boxh,
    boxH: boxH,
    boxhd: boxhd,
    boxHd: boxHd,
    boxhD: boxhD,
    boxHD: boxHD,
    boxhu: boxhu,
    boxHu: boxHu,
    boxhU: boxhU,
    boxHU: boxHU,
    boxminus: boxminus,
    boxplus: boxplus,
    boxtimes: boxtimes,
    boxul: boxul,
    boxuL: boxuL,
    boxUl: boxUl,
    boxUL: boxUL,
    boxur: boxur,
    boxuR: boxuR,
    boxUr: boxUr,
    boxUR: boxUR,
    boxv: boxv,
    boxV: boxV,
    boxvh: boxvh,
    boxvH: boxvH,
    boxVh: boxVh,
    boxVH: boxVH,
    boxvl: boxvl,
    boxvL: boxvL,
    boxVl: boxVl,
    boxVL: boxVL,
    boxvr: boxvr,
    boxvR: boxvR,
    boxVr: boxVr,
    boxVR: boxVR,
    bprime: bprime,
    breve: breve,
    Breve: Breve,
    brvbar: brvbar,
    bscr: bscr,
    Bscr: Bscr,
    bsemi: bsemi,
    bsim: bsim,
    bsime: bsime,
    bsolb: bsolb,
    bsol: bsol,
    bsolhsub: bsolhsub,
    bull: bull,
    bullet: bullet,
    bump: bump,
    bumpE: bumpE,
    bumpe: bumpe,
    Bumpeq: Bumpeq,
    bumpeq: bumpeq,
    Cacute: Cacute,
    cacute: cacute,
    capand: capand,
    capbrcup: capbrcup,
    capcap: capcap,
    cap: cap,
    Cap: Cap,
    capcup: capcup,
    capdot: capdot,
    CapitalDifferentialD: CapitalDifferentialD,
    caps: caps,
    caret: caret,
    caron: caron,
    Cayleys: Cayleys,
    ccaps: ccaps,
    Ccaron: Ccaron,
    ccaron: ccaron,
    Ccedil: Ccedil,
    ccedil: ccedil,
    Ccirc: Ccirc,
    ccirc: ccirc,
    Cconint: Cconint,
    ccups: ccups,
    ccupssm: ccupssm,
    Cdot: Cdot,
    cdot: cdot,
    cedil: cedil,
    Cedilla: Cedilla,
    cemptyv: cemptyv,
    cent: cent,
    centerdot: centerdot,
    CenterDot: CenterDot,
    cfr: cfr,
    Cfr: Cfr,
    CHcy: CHcy,
    chcy: chcy,
    check: check$1,
    checkmark: checkmark,
    Chi: Chi,
    chi: chi,
    circ: circ,
    circeq: circeq,
    circlearrowleft: circlearrowleft,
    circlearrowright: circlearrowright,
    circledast: circledast,
    circledcirc: circledcirc,
    circleddash: circleddash,
    CircleDot: CircleDot,
    circledR: circledR,
    circledS: circledS,
    CircleMinus: CircleMinus,
    CirclePlus: CirclePlus,
    CircleTimes: CircleTimes,
    cir: cir,
    cirE: cirE,
    cire: cire,
    cirfnint: cirfnint,
    cirmid: cirmid,
    cirscir: cirscir,
    ClockwiseContourIntegral: ClockwiseContourIntegral,
    CloseCurlyDoubleQuote: CloseCurlyDoubleQuote,
    CloseCurlyQuote: CloseCurlyQuote,
    clubs: clubs,
    clubsuit: clubsuit,
    colon: colon,
    Colon: Colon,
    Colone: Colone,
    colone: colone,
    coloneq: coloneq,
    comma: comma,
    commat: commat,
    comp: comp,
    compfn: compfn,
    complement: complement,
    complexes: complexes,
    cong: cong,
    congdot: congdot,
    Congruent: Congruent,
    conint: conint,
    Conint: Conint,
    ContourIntegral: ContourIntegral,
    copf: copf,
    Copf: Copf,
    coprod: coprod,
    Coproduct: Coproduct,
    copy: copy,
    COPY: COPY,
    copysr: copysr,
    CounterClockwiseContourIntegral: CounterClockwiseContourIntegral,
    crarr: crarr,
    cross: cross,
    Cross: Cross,
    Cscr: Cscr,
    cscr: cscr,
    csub: csub,
    csube: csube,
    csup: csup,
    csupe: csupe,
    ctdot: ctdot,
    cudarrl: cudarrl,
    cudarrr: cudarrr,
    cuepr: cuepr,
    cuesc: cuesc,
    cularr: cularr,
    cularrp: cularrp,
    cupbrcap: cupbrcap,
    cupcap: cupcap,
    CupCap: CupCap,
    cup: cup,
    Cup: Cup,
    cupcup: cupcup,
    cupdot: cupdot,
    cupor: cupor,
    cups: cups,
    curarr: curarr,
    curarrm: curarrm,
    curlyeqprec: curlyeqprec,
    curlyeqsucc: curlyeqsucc,
    curlyvee: curlyvee,
    curlywedge: curlywedge,
    curren: curren,
    curvearrowleft: curvearrowleft,
    curvearrowright: curvearrowright,
    cuvee: cuvee,
    cuwed: cuwed,
    cwconint: cwconint,
    cwint: cwint,
    cylcty: cylcty,
    dagger: dagger,
    Dagger: Dagger,
    daleth: daleth,
    darr: darr,
    Darr: Darr,
    dArr: dArr,
    dash: dash,
    Dashv: Dashv,
    dashv: dashv,
    dbkarow: dbkarow,
    dblac: dblac,
    Dcaron: Dcaron,
    dcaron: dcaron,
    Dcy: Dcy,
    dcy: dcy,
    ddagger: ddagger,
    ddarr: ddarr,
    DD: DD,
    dd: dd,
    DDotrahd: DDotrahd,
    ddotseq: ddotseq,
    deg: deg,
    Del: Del,
    Delta: Delta,
    delta: delta,
    demptyv: demptyv,
    dfisht: dfisht,
    Dfr: Dfr,
    dfr: dfr,
    dHar: dHar,
    dharl: dharl,
    dharr: dharr,
    DiacriticalAcute: DiacriticalAcute,
    DiacriticalDot: DiacriticalDot,
    DiacriticalDoubleAcute: DiacriticalDoubleAcute,
    DiacriticalGrave: DiacriticalGrave,
    DiacriticalTilde: DiacriticalTilde,
    diam: diam,
    diamond: diamond,
    Diamond: Diamond,
    diamondsuit: diamondsuit,
    diams: diams,
    die: die,
    DifferentialD: DifferentialD,
    digamma: digamma,
    disin: disin,
    div: div,
    divide: divide,
    divideontimes: divideontimes,
    divonx: divonx,
    DJcy: DJcy,
    djcy: djcy,
    dlcorn: dlcorn,
    dlcrop: dlcrop,
    dollar: dollar,
    Dopf: Dopf,
    dopf: dopf,
    Dot: Dot,
    dot: dot,
    DotDot: DotDot,
    doteq: doteq,
    doteqdot: doteqdot,
    DotEqual: DotEqual,
    dotminus: dotminus,
    dotplus: dotplus,
    dotsquare: dotsquare,
    doublebarwedge: doublebarwedge,
    DoubleContourIntegral: DoubleContourIntegral,
    DoubleDot: DoubleDot,
    DoubleDownArrow: DoubleDownArrow,
    DoubleLeftArrow: DoubleLeftArrow,
    DoubleLeftRightArrow: DoubleLeftRightArrow,
    DoubleLeftTee: DoubleLeftTee,
    DoubleLongLeftArrow: DoubleLongLeftArrow,
    DoubleLongLeftRightArrow: DoubleLongLeftRightArrow,
    DoubleLongRightArrow: DoubleLongRightArrow,
    DoubleRightArrow: DoubleRightArrow,
    DoubleRightTee: DoubleRightTee,
    DoubleUpArrow: DoubleUpArrow,
    DoubleUpDownArrow: DoubleUpDownArrow,
    DoubleVerticalBar: DoubleVerticalBar,
    DownArrowBar: DownArrowBar,
    downarrow: downarrow,
    DownArrow: DownArrow,
    Downarrow: Downarrow,
    DownArrowUpArrow: DownArrowUpArrow,
    DownBreve: DownBreve,
    downdownarrows: downdownarrows,
    downharpoonleft: downharpoonleft,
    downharpoonright: downharpoonright,
    DownLeftRightVector: DownLeftRightVector,
    DownLeftTeeVector: DownLeftTeeVector,
    DownLeftVectorBar: DownLeftVectorBar,
    DownLeftVector: DownLeftVector,
    DownRightTeeVector: DownRightTeeVector,
    DownRightVectorBar: DownRightVectorBar,
    DownRightVector: DownRightVector,
    DownTeeArrow: DownTeeArrow,
    DownTee: DownTee,
    drbkarow: drbkarow,
    drcorn: drcorn,
    drcrop: drcrop,
    Dscr: Dscr,
    dscr: dscr,
    DScy: DScy,
    dscy: dscy,
    dsol: dsol,
    Dstrok: Dstrok,
    dstrok: dstrok,
    dtdot: dtdot,
    dtri: dtri,
    dtrif: dtrif,
    duarr: duarr,
    duhar: duhar,
    dwangle: dwangle,
    DZcy: DZcy,
    dzcy: dzcy,
    dzigrarr: dzigrarr,
    Eacute: Eacute,
    eacute: eacute,
    easter: easter,
    Ecaron: Ecaron,
    ecaron: ecaron,
    Ecirc: Ecirc,
    ecirc: ecirc,
    ecir: ecir,
    ecolon: ecolon,
    Ecy: Ecy,
    ecy: ecy,
    eDDot: eDDot,
    Edot: Edot,
    edot: edot,
    eDot: eDot,
    ee: ee,
    efDot: efDot,
    Efr: Efr,
    efr: efr,
    eg: eg,
    Egrave: Egrave,
    egrave: egrave,
    egs: egs,
    egsdot: egsdot,
    el: el,
    Element: Element,
    elinters: elinters,
    ell: ell,
    els: els,
    elsdot: elsdot,
    Emacr: Emacr,
    emacr: emacr,
    empty: empty$4,
    emptyset: emptyset,
    EmptySmallSquare: EmptySmallSquare,
    emptyv: emptyv,
    EmptyVerySmallSquare: EmptyVerySmallSquare,
    emsp13: emsp13,
    emsp14: emsp14,
    emsp: emsp,
    ENG: ENG,
    eng: eng,
    ensp: ensp,
    Eogon: Eogon,
    eogon: eogon,
    Eopf: Eopf,
    eopf: eopf,
    epar: epar,
    eparsl: eparsl,
    eplus: eplus,
    epsi: epsi,
    Epsilon: Epsilon,
    epsilon: epsilon,
    epsiv: epsiv,
    eqcirc: eqcirc,
    eqcolon: eqcolon,
    eqsim: eqsim,
    eqslantgtr: eqslantgtr,
    eqslantless: eqslantless,
    Equal: Equal,
    equals: equals,
    EqualTilde: EqualTilde,
    equest: equest,
    Equilibrium: Equilibrium,
    equiv: equiv,
    equivDD: equivDD,
    eqvparsl: eqvparsl,
    erarr: erarr,
    erDot: erDot,
    escr: escr,
    Escr: Escr,
    esdot: esdot,
    Esim: Esim,
    esim: esim,
    Eta: Eta,
    eta: eta,
    ETH: ETH,
    eth: eth,
    Euml: Euml,
    euml: euml,
    euro: euro,
    excl: excl,
    exist: exist,
    Exists: Exists,
    expectation: expectation,
    exponentiale: exponentiale,
    ExponentialE: ExponentialE,
    fallingdotseq: fallingdotseq,
    Fcy: Fcy,
    fcy: fcy,
    female: female,
    ffilig: ffilig,
    fflig: fflig,
    ffllig: ffllig,
    Ffr: Ffr,
    ffr: ffr,
    filig: filig,
    FilledSmallSquare: FilledSmallSquare,
    FilledVerySmallSquare: FilledVerySmallSquare,
    fjlig: fjlig,
    flat: flat,
    fllig: fllig,
    fltns: fltns,
    fnof: fnof,
    Fopf: Fopf,
    fopf: fopf,
    forall: forall,
    ForAll: ForAll,
    fork: fork,
    forkv: forkv,
    Fouriertrf: Fouriertrf,
    fpartint: fpartint,
    frac12: frac12,
    frac13: frac13,
    frac14: frac14,
    frac15: frac15,
    frac16: frac16,
    frac18: frac18,
    frac23: frac23,
    frac25: frac25,
    frac34: frac34,
    frac35: frac35,
    frac38: frac38,
    frac45: frac45,
    frac56: frac56,
    frac58: frac58,
    frac78: frac78,
    frasl: frasl,
    frown: frown,
    fscr: fscr,
    Fscr: Fscr,
    gacute: gacute,
    Gamma: Gamma,
    gamma: gamma,
    Gammad: Gammad,
    gammad: gammad,
    gap: gap,
    Gbreve: Gbreve,
    gbreve: gbreve,
    Gcedil: Gcedil,
    Gcirc: Gcirc,
    gcirc: gcirc,
    Gcy: Gcy,
    gcy: gcy,
    Gdot: Gdot,
    gdot: gdot,
    ge: ge,
    gE: gE,
    gEl: gEl,
    gel: gel,
    geq: geq,
    geqq: geqq,
    geqslant: geqslant,
    gescc: gescc,
    ges: ges,
    gesdot: gesdot,
    gesdoto: gesdoto,
    gesdotol: gesdotol,
    gesl: gesl,
    gesles: gesles,
    Gfr: Gfr,
    gfr: gfr,
    gg: gg,
    Gg: Gg,
    ggg: ggg,
    gimel: gimel,
    GJcy: GJcy,
    gjcy: gjcy,
    gla: gla,
    gl: gl,
    glE: glE,
    glj: glj,
    gnap: gnap,
    gnapprox: gnapprox,
    gne: gne,
    gnE: gnE,
    gneq: gneq,
    gneqq: gneqq,
    gnsim: gnsim,
    Gopf: Gopf,
    gopf: gopf,
    grave: grave,
    GreaterEqual: GreaterEqual,
    GreaterEqualLess: GreaterEqualLess,
    GreaterFullEqual: GreaterFullEqual,
    GreaterGreater: GreaterGreater,
    GreaterLess: GreaterLess,
    GreaterSlantEqual: GreaterSlantEqual,
    GreaterTilde: GreaterTilde,
    Gscr: Gscr,
    gscr: gscr,
    gsim: gsim,
    gsime: gsime,
    gsiml: gsiml,
    gtcc: gtcc,
    gtcir: gtcir,
    gt: gt,
    GT: GT,
    Gt: Gt,
    gtdot: gtdot,
    gtlPar: gtlPar,
    gtquest: gtquest,
    gtrapprox: gtrapprox,
    gtrarr: gtrarr,
    gtrdot: gtrdot,
    gtreqless: gtreqless,
    gtreqqless: gtreqqless,
    gtrless: gtrless,
    gtrsim: gtrsim,
    gvertneqq: gvertneqq,
    gvnE: gvnE,
    Hacek: Hacek,
    hairsp: hairsp,
    half: half,
    hamilt: hamilt,
    HARDcy: HARDcy,
    hardcy: hardcy,
    harrcir: harrcir,
    harr: harr,
    hArr: hArr,
    harrw: harrw,
    Hat: Hat,
    hbar: hbar,
    Hcirc: Hcirc,
    hcirc: hcirc,
    hearts: hearts,
    heartsuit: heartsuit,
    hellip: hellip,
    hercon: hercon,
    hfr: hfr,
    Hfr: Hfr,
    HilbertSpace: HilbertSpace,
    hksearow: hksearow,
    hkswarow: hkswarow,
    hoarr: hoarr,
    homtht: homtht,
    hookleftarrow: hookleftarrow,
    hookrightarrow: hookrightarrow,
    hopf: hopf,
    Hopf: Hopf,
    horbar: horbar,
    HorizontalLine: HorizontalLine,
    hscr: hscr,
    Hscr: Hscr,
    hslash: hslash,
    Hstrok: Hstrok,
    hstrok: hstrok,
    HumpDownHump: HumpDownHump,
    HumpEqual: HumpEqual,
    hybull: hybull,
    hyphen: hyphen,
    Iacute: Iacute,
    iacute: iacute,
    ic: ic,
    Icirc: Icirc,
    icirc: icirc,
    Icy: Icy,
    icy: icy,
    Idot: Idot,
    IEcy: IEcy,
    iecy: iecy,
    iexcl: iexcl,
    iff: iff,
    ifr: ifr,
    Ifr: Ifr,
    Igrave: Igrave,
    igrave: igrave,
    ii: ii,
    iiiint: iiiint,
    iiint: iiint,
    iinfin: iinfin,
    iiota: iiota,
    IJlig: IJlig,
    ijlig: ijlig,
    Imacr: Imacr,
    imacr: imacr,
    image: image,
    ImaginaryI: ImaginaryI,
    imagline: imagline,
    imagpart: imagpart,
    imath: imath,
    Im: Im,
    imof: imof,
    imped: imped,
    Implies: Implies,
    incare: incare,
    infin: infin,
    infintie: infintie,
    inodot: inodot,
    intcal: intcal,
    int: int,
    Int: Int,
    integers: integers,
    Integral: Integral,
    intercal: intercal,
    Intersection: Intersection,
    intlarhk: intlarhk,
    intprod: intprod,
    InvisibleComma: InvisibleComma,
    InvisibleTimes: InvisibleTimes,
    IOcy: IOcy,
    iocy: iocy,
    Iogon: Iogon,
    iogon: iogon,
    Iopf: Iopf,
    iopf: iopf,
    Iota: Iota,
    iota: iota,
    iprod: iprod,
    iquest: iquest,
    iscr: iscr,
    Iscr: Iscr,
    isin: isin,
    isindot: isindot,
    isinE: isinE,
    isins: isins,
    isinsv: isinsv,
    isinv: isinv,
    it: it,
    Itilde: Itilde,
    itilde: itilde,
    Iukcy: Iukcy,
    iukcy: iukcy,
    Iuml: Iuml,
    iuml: iuml,
    Jcirc: Jcirc,
    jcirc: jcirc,
    Jcy: Jcy,
    jcy: jcy,
    Jfr: Jfr,
    jfr: jfr,
    jmath: jmath,
    Jopf: Jopf,
    jopf: jopf,
    Jscr: Jscr,
    jscr: jscr,
    Jsercy: Jsercy,
    jsercy: jsercy,
    Jukcy: Jukcy,
    jukcy: jukcy,
    Kappa: Kappa,
    kappa: kappa,
    kappav: kappav,
    Kcedil: Kcedil,
    kcedil: kcedil,
    Kcy: Kcy,
    kcy: kcy,
    Kfr: Kfr,
    kfr: kfr,
    kgreen: kgreen,
    KHcy: KHcy,
    khcy: khcy,
    KJcy: KJcy,
    kjcy: kjcy,
    Kopf: Kopf,
    kopf: kopf,
    Kscr: Kscr,
    kscr: kscr,
    lAarr: lAarr,
    Lacute: Lacute,
    lacute: lacute,
    laemptyv: laemptyv,
    lagran: lagran,
    Lambda: Lambda,
    lambda: lambda,
    lang: lang,
    Lang: Lang,
    langd: langd,
    langle: langle,
    lap: lap,
    Laplacetrf: Laplacetrf,
    laquo: laquo,
    larrb: larrb,
    larrbfs: larrbfs,
    larr: larr,
    Larr: Larr,
    lArr: lArr,
    larrfs: larrfs,
    larrhk: larrhk,
    larrlp: larrlp,
    larrpl: larrpl,
    larrsim: larrsim,
    larrtl: larrtl,
    latail: latail,
    lAtail: lAtail,
    lat: lat,
    late: late,
    lates: lates,
    lbarr: lbarr,
    lBarr: lBarr,
    lbbrk: lbbrk,
    lbrace: lbrace,
    lbrack: lbrack,
    lbrke: lbrke,
    lbrksld: lbrksld,
    lbrkslu: lbrkslu,
    Lcaron: Lcaron,
    lcaron: lcaron,
    Lcedil: Lcedil,
    lcedil: lcedil,
    lceil: lceil,
    lcub: lcub,
    Lcy: Lcy,
    lcy: lcy,
    ldca: ldca,
    ldquo: ldquo,
    ldquor: ldquor,
    ldrdhar: ldrdhar,
    ldrushar: ldrushar,
    ldsh: ldsh,
    le: le,
    lE: lE,
    LeftAngleBracket: LeftAngleBracket,
    LeftArrowBar: LeftArrowBar,
    leftarrow: leftarrow,
    LeftArrow: LeftArrow,
    Leftarrow: Leftarrow,
    LeftArrowRightArrow: LeftArrowRightArrow,
    leftarrowtail: leftarrowtail,
    LeftCeiling: LeftCeiling,
    LeftDoubleBracket: LeftDoubleBracket,
    LeftDownTeeVector: LeftDownTeeVector,
    LeftDownVectorBar: LeftDownVectorBar,
    LeftDownVector: LeftDownVector,
    LeftFloor: LeftFloor,
    leftharpoondown: leftharpoondown,
    leftharpoonup: leftharpoonup,
    leftleftarrows: leftleftarrows,
    leftrightarrow: leftrightarrow,
    LeftRightArrow: LeftRightArrow,
    Leftrightarrow: Leftrightarrow,
    leftrightarrows: leftrightarrows,
    leftrightharpoons: leftrightharpoons,
    leftrightsquigarrow: leftrightsquigarrow,
    LeftRightVector: LeftRightVector,
    LeftTeeArrow: LeftTeeArrow,
    LeftTee: LeftTee,
    LeftTeeVector: LeftTeeVector,
    leftthreetimes: leftthreetimes,
    LeftTriangleBar: LeftTriangleBar,
    LeftTriangle: LeftTriangle,
    LeftTriangleEqual: LeftTriangleEqual,
    LeftUpDownVector: LeftUpDownVector,
    LeftUpTeeVector: LeftUpTeeVector,
    LeftUpVectorBar: LeftUpVectorBar,
    LeftUpVector: LeftUpVector,
    LeftVectorBar: LeftVectorBar,
    LeftVector: LeftVector,
    lEg: lEg,
    leg: leg,
    leq: leq,
    leqq: leqq,
    leqslant: leqslant,
    lescc: lescc,
    les: les,
    lesdot: lesdot,
    lesdoto: lesdoto,
    lesdotor: lesdotor,
    lesg: lesg,
    lesges: lesges,
    lessapprox: lessapprox,
    lessdot: lessdot,
    lesseqgtr: lesseqgtr,
    lesseqqgtr: lesseqqgtr,
    LessEqualGreater: LessEqualGreater,
    LessFullEqual: LessFullEqual,
    LessGreater: LessGreater,
    lessgtr: lessgtr,
    LessLess: LessLess,
    lesssim: lesssim,
    LessSlantEqual: LessSlantEqual,
    LessTilde: LessTilde,
    lfisht: lfisht,
    lfloor: lfloor,
    Lfr: Lfr,
    lfr: lfr,
    lg: lg,
    lgE: lgE,
    lHar: lHar,
    lhard: lhard,
    lharu: lharu,
    lharul: lharul,
    lhblk: lhblk,
    LJcy: LJcy,
    ljcy: ljcy,
    llarr: llarr,
    ll: ll,
    Ll: Ll,
    llcorner: llcorner,
    Lleftarrow: Lleftarrow,
    llhard: llhard,
    lltri: lltri,
    Lmidot: Lmidot,
    lmidot: lmidot,
    lmoustache: lmoustache,
    lmoust: lmoust,
    lnap: lnap,
    lnapprox: lnapprox,
    lne: lne,
    lnE: lnE,
    lneq: lneq,
    lneqq: lneqq,
    lnsim: lnsim,
    loang: loang,
    loarr: loarr,
    lobrk: lobrk,
    longleftarrow: longleftarrow,
    LongLeftArrow: LongLeftArrow,
    Longleftarrow: Longleftarrow,
    longleftrightarrow: longleftrightarrow,
    LongLeftRightArrow: LongLeftRightArrow,
    Longleftrightarrow: Longleftrightarrow,
    longmapsto: longmapsto,
    longrightarrow: longrightarrow,
    LongRightArrow: LongRightArrow,
    Longrightarrow: Longrightarrow,
    looparrowleft: looparrowleft,
    looparrowright: looparrowright,
    lopar: lopar,
    Lopf: Lopf,
    lopf: lopf,
    loplus: loplus,
    lotimes: lotimes,
    lowast: lowast,
    lowbar: lowbar,
    LowerLeftArrow: LowerLeftArrow,
    LowerRightArrow: LowerRightArrow,
    loz: loz,
    lozenge: lozenge,
    lozf: lozf,
    lpar: lpar,
    lparlt: lparlt,
    lrarr: lrarr,
    lrcorner: lrcorner,
    lrhar: lrhar,
    lrhard: lrhard,
    lrm: lrm,
    lrtri: lrtri,
    lsaquo: lsaquo,
    lscr: lscr,
    Lscr: Lscr,
    lsh: lsh,
    Lsh: Lsh,
    lsim: lsim,
    lsime: lsime,
    lsimg: lsimg,
    lsqb: lsqb,
    lsquo: lsquo,
    lsquor: lsquor,
    Lstrok: Lstrok,
    lstrok: lstrok,
    ltcc: ltcc,
    ltcir: ltcir,
    lt: lt,
    LT: LT,
    Lt: Lt,
    ltdot: ltdot,
    lthree: lthree,
    ltimes: ltimes,
    ltlarr: ltlarr,
    ltquest: ltquest,
    ltri: ltri,
    ltrie: ltrie,
    ltrif: ltrif,
    ltrPar: ltrPar,
    lurdshar: lurdshar,
    luruhar: luruhar,
    lvertneqq: lvertneqq,
    lvnE: lvnE,
    macr: macr,
    male: male,
    malt: malt,
    maltese: maltese,
    map: map$1,
    mapsto: mapsto,
    mapstodown: mapstodown,
    mapstoleft: mapstoleft,
    mapstoup: mapstoup,
    marker: marker$1,
    mcomma: mcomma,
    Mcy: Mcy,
    mcy: mcy,
    mdash: mdash,
    mDDot: mDDot,
    measuredangle: measuredangle,
    MediumSpace: MediumSpace,
    Mellintrf: Mellintrf,
    Mfr: Mfr,
    mfr: mfr,
    mho: mho,
    micro: micro,
    midast: midast,
    midcir: midcir,
    mid: mid,
    middot: middot,
    minusb: minusb,
    minus: minus,
    minusd: minusd,
    minusdu: minusdu,
    MinusPlus: MinusPlus,
    mlcp: mlcp,
    mldr: mldr,
    mnplus: mnplus,
    models: models,
    Mopf: Mopf,
    mopf: mopf,
    mp: mp,
    mscr: mscr,
    Mscr: Mscr,
    mstpos: mstpos,
    Mu: Mu,
    mu: mu,
    multimap: multimap,
    mumap: mumap,
    nabla: nabla,
    Nacute: Nacute,
    nacute: nacute,
    nang: nang,
    nap: nap,
    napE: napE,
    napid: napid,
    napos: napos,
    napprox: napprox,
    natural: natural,
    naturals: naturals,
    natur: natur,
    nbsp: nbsp,
    nbump: nbump,
    nbumpe: nbumpe,
    ncap: ncap,
    Ncaron: Ncaron,
    ncaron: ncaron,
    Ncedil: Ncedil,
    ncedil: ncedil,
    ncong: ncong,
    ncongdot: ncongdot,
    ncup: ncup,
    Ncy: Ncy,
    ncy: ncy,
    ndash: ndash,
    nearhk: nearhk,
    nearr: nearr,
    neArr: neArr,
    nearrow: nearrow,
    ne: ne,
    nedot: nedot,
    NegativeMediumSpace: NegativeMediumSpace,
    NegativeThickSpace: NegativeThickSpace,
    NegativeThinSpace: NegativeThinSpace,
    NegativeVeryThinSpace: NegativeVeryThinSpace,
    nequiv: nequiv,
    nesear: nesear,
    nesim: nesim,
    NestedGreaterGreater: NestedGreaterGreater,
    NestedLessLess: NestedLessLess,
    NewLine: NewLine,
    nexist: nexist,
    nexists: nexists,
    Nfr: Nfr,
    nfr: nfr,
    ngE: ngE,
    nge: nge,
    ngeq: ngeq,
    ngeqq: ngeqq,
    ngeqslant: ngeqslant,
    nges: nges,
    nGg: nGg,
    ngsim: ngsim,
    nGt: nGt,
    ngt: ngt,
    ngtr: ngtr,
    nGtv: nGtv,
    nharr: nharr,
    nhArr: nhArr,
    nhpar: nhpar,
    ni: ni,
    nis: nis,
    nisd: nisd,
    niv: niv,
    NJcy: NJcy,
    njcy: njcy,
    nlarr: nlarr,
    nlArr: nlArr,
    nldr: nldr,
    nlE: nlE,
    nle: nle,
    nleftarrow: nleftarrow,
    nLeftarrow: nLeftarrow,
    nleftrightarrow: nleftrightarrow,
    nLeftrightarrow: nLeftrightarrow,
    nleq: nleq,
    nleqq: nleqq,
    nleqslant: nleqslant,
    nles: nles,
    nless: nless,
    nLl: nLl,
    nlsim: nlsim,
    nLt: nLt,
    nlt: nlt,
    nltri: nltri,
    nltrie: nltrie,
    nLtv: nLtv,
    nmid: nmid,
    NoBreak: NoBreak,
    NonBreakingSpace: NonBreakingSpace,
    nopf: nopf,
    Nopf: Nopf,
    Not: Not,
    not: not$1,
    NotCongruent: NotCongruent,
    NotCupCap: NotCupCap,
    NotDoubleVerticalBar: NotDoubleVerticalBar,
    NotElement: NotElement,
    NotEqual: NotEqual,
    NotEqualTilde: NotEqualTilde,
    NotExists: NotExists,
    NotGreater: NotGreater,
    NotGreaterEqual: NotGreaterEqual,
    NotGreaterFullEqual: NotGreaterFullEqual,
    NotGreaterGreater: NotGreaterGreater,
    NotGreaterLess: NotGreaterLess,
    NotGreaterSlantEqual: NotGreaterSlantEqual,
    NotGreaterTilde: NotGreaterTilde,
    NotHumpDownHump: NotHumpDownHump,
    NotHumpEqual: NotHumpEqual,
    notin: notin,
    notindot: notindot,
    notinE: notinE,
    notinva: notinva,
    notinvb: notinvb,
    notinvc: notinvc,
    NotLeftTriangleBar: NotLeftTriangleBar,
    NotLeftTriangle: NotLeftTriangle,
    NotLeftTriangleEqual: NotLeftTriangleEqual,
    NotLess: NotLess,
    NotLessEqual: NotLessEqual,
    NotLessGreater: NotLessGreater,
    NotLessLess: NotLessLess,
    NotLessSlantEqual: NotLessSlantEqual,
    NotLessTilde: NotLessTilde,
    NotNestedGreaterGreater: NotNestedGreaterGreater,
    NotNestedLessLess: NotNestedLessLess,
    notni: notni,
    notniva: notniva,
    notnivb: notnivb,
    notnivc: notnivc,
    NotPrecedes: NotPrecedes,
    NotPrecedesEqual: NotPrecedesEqual,
    NotPrecedesSlantEqual: NotPrecedesSlantEqual,
    NotReverseElement: NotReverseElement,
    NotRightTriangleBar: NotRightTriangleBar,
    NotRightTriangle: NotRightTriangle,
    NotRightTriangleEqual: NotRightTriangleEqual,
    NotSquareSubset: NotSquareSubset,
    NotSquareSubsetEqual: NotSquareSubsetEqual,
    NotSquareSuperset: NotSquareSuperset,
    NotSquareSupersetEqual: NotSquareSupersetEqual,
    NotSubset: NotSubset,
    NotSubsetEqual: NotSubsetEqual,
    NotSucceeds: NotSucceeds,
    NotSucceedsEqual: NotSucceedsEqual,
    NotSucceedsSlantEqual: NotSucceedsSlantEqual,
    NotSucceedsTilde: NotSucceedsTilde,
    NotSuperset: NotSuperset,
    NotSupersetEqual: NotSupersetEqual,
    NotTilde: NotTilde,
    NotTildeEqual: NotTildeEqual,
    NotTildeFullEqual: NotTildeFullEqual,
    NotTildeTilde: NotTildeTilde,
    NotVerticalBar: NotVerticalBar,
    nparallel: nparallel,
    npar: npar,
    nparsl: nparsl,
    npart: npart,
    npolint: npolint,
    npr: npr,
    nprcue: nprcue,
    nprec: nprec,
    npreceq: npreceq,
    npre: npre,
    nrarrc: nrarrc,
    nrarr: nrarr,
    nrArr: nrArr,
    nrarrw: nrarrw,
    nrightarrow: nrightarrow,
    nRightarrow: nRightarrow,
    nrtri: nrtri,
    nrtrie: nrtrie,
    nsc: nsc,
    nsccue: nsccue,
    nsce: nsce,
    Nscr: Nscr,
    nscr: nscr,
    nshortmid: nshortmid,
    nshortparallel: nshortparallel,
    nsim: nsim,
    nsime: nsime,
    nsimeq: nsimeq,
    nsmid: nsmid,
    nspar: nspar,
    nsqsube: nsqsube,
    nsqsupe: nsqsupe,
    nsub: nsub,
    nsubE: nsubE,
    nsube: nsube,
    nsubset: nsubset,
    nsubseteq: nsubseteq,
    nsubseteqq: nsubseteqq,
    nsucc: nsucc,
    nsucceq: nsucceq,
    nsup: nsup,
    nsupE: nsupE,
    nsupe: nsupe,
    nsupset: nsupset,
    nsupseteq: nsupseteq,
    nsupseteqq: nsupseteqq,
    ntgl: ntgl,
    Ntilde: Ntilde,
    ntilde: ntilde,
    ntlg: ntlg,
    ntriangleleft: ntriangleleft,
    ntrianglelefteq: ntrianglelefteq,
    ntriangleright: ntriangleright,
    ntrianglerighteq: ntrianglerighteq,
    Nu: Nu,
    nu: nu,
    num: num,
    numero: numero,
    numsp: numsp,
    nvap: nvap,
    nvdash: nvdash,
    nvDash: nvDash,
    nVdash: nVdash,
    nVDash: nVDash,
    nvge: nvge,
    nvgt: nvgt,
    nvHarr: nvHarr,
    nvinfin: nvinfin,
    nvlArr: nvlArr,
    nvle: nvle,
    nvlt: nvlt,
    nvltrie: nvltrie,
    nvrArr: nvrArr,
    nvrtrie: nvrtrie,
    nvsim: nvsim,
    nwarhk: nwarhk,
    nwarr: nwarr,
    nwArr: nwArr,
    nwarrow: nwarrow,
    nwnear: nwnear,
    Oacute: Oacute,
    oacute: oacute,
    oast: oast,
    Ocirc: Ocirc,
    ocirc: ocirc,
    ocir: ocir,
    Ocy: Ocy,
    ocy: ocy,
    odash: odash,
    Odblac: Odblac,
    odblac: odblac,
    odiv: odiv,
    odot: odot,
    odsold: odsold,
    OElig: OElig,
    oelig: oelig,
    ofcir: ofcir,
    Ofr: Ofr,
    ofr: ofr,
    ogon: ogon,
    Ograve: Ograve,
    ograve: ograve,
    ogt: ogt,
    ohbar: ohbar,
    ohm: ohm,
    oint: oint,
    olarr: olarr,
    olcir: olcir,
    olcross: olcross,
    oline: oline,
    olt: olt,
    Omacr: Omacr,
    omacr: omacr,
    Omega: Omega,
    omega: omega,
    Omicron: Omicron,
    omicron: omicron,
    omid: omid,
    ominus: ominus,
    Oopf: Oopf,
    oopf: oopf,
    opar: opar,
    OpenCurlyDoubleQuote: OpenCurlyDoubleQuote,
    OpenCurlyQuote: OpenCurlyQuote,
    operp: operp,
    oplus: oplus,
    orarr: orarr,
    Or: Or,
    or: or,
    ord: ord,
    order: order,
    orderof: orderof,
    ordf: ordf,
    ordm: ordm,
    origof: origof,
    oror: oror,
    orslope: orslope,
    orv: orv,
    oS: oS,
    Oscr: Oscr,
    oscr: oscr,
    Oslash: Oslash,
    oslash: oslash,
    osol: osol,
    Otilde: Otilde,
    otilde: otilde,
    otimesas: otimesas,
    Otimes: Otimes,
    otimes: otimes,
    Ouml: Ouml,
    ouml: ouml,
    ovbar: ovbar,
    OverBar: OverBar,
    OverBrace: OverBrace,
    OverBracket: OverBracket,
    OverParenthesis: OverParenthesis,
    para: para,
    parallel: parallel,
    par: par,
    parsim: parsim,
    parsl: parsl,
    part: part,
    PartialD: PartialD,
    Pcy: Pcy,
    pcy: pcy,
    percnt: percnt,
    period: period,
    permil: permil,
    perp: perp,
    pertenk: pertenk,
    Pfr: Pfr,
    pfr: pfr,
    Phi: Phi,
    phi: phi,
    phiv: phiv,
    phmmat: phmmat,
    phone: phone,
    Pi: Pi,
    pi: pi,
    pitchfork: pitchfork,
    piv: piv,
    planck: planck,
    planckh: planckh,
    plankv: plankv,
    plusacir: plusacir,
    plusb: plusb,
    pluscir: pluscir,
    plus: plus,
    plusdo: plusdo,
    plusdu: plusdu,
    pluse: pluse,
    PlusMinus: PlusMinus,
    plusmn: plusmn,
    plussim: plussim,
    plustwo: plustwo,
    pm: pm,
    Poincareplane: Poincareplane,
    pointint: pointint,
    popf: popf,
    Popf: Popf,
    pound: pound,
    prap: prap,
    Pr: Pr,
    pr: pr,
    prcue: prcue,
    precapprox: precapprox,
    prec: prec,
    preccurlyeq: preccurlyeq,
    Precedes: Precedes,
    PrecedesEqual: PrecedesEqual,
    PrecedesSlantEqual: PrecedesSlantEqual,
    PrecedesTilde: PrecedesTilde,
    preceq: preceq,
    precnapprox: precnapprox,
    precneqq: precneqq,
    precnsim: precnsim,
    pre: pre,
    prE: prE,
    precsim: precsim,
    prime: prime,
    Prime: Prime,
    primes: primes,
    prnap: prnap,
    prnE: prnE,
    prnsim: prnsim,
    prod: prod,
    Product: Product,
    profalar: profalar,
    profline: profline,
    profsurf: profsurf,
    prop: prop,
    Proportional: Proportional,
    Proportion: Proportion,
    propto: propto,
    prsim: prsim,
    prurel: prurel,
    Pscr: Pscr,
    pscr: pscr,
    Psi: Psi,
    psi: psi,
    puncsp: puncsp,
    Qfr: Qfr,
    qfr: qfr,
    qint: qint,
    qopf: qopf,
    Qopf: Qopf,
    qprime: qprime,
    Qscr: Qscr,
    qscr: qscr,
    quaternions: quaternions,
    quatint: quatint,
    quest: quest,
    questeq: questeq,
    quot: quot,
    QUOT: QUOT,
    rAarr: rAarr,
    race: race$1,
    Racute: Racute,
    racute: racute,
    radic: radic,
    raemptyv: raemptyv,
    rang: rang,
    Rang: Rang,
    rangd: rangd,
    range: range$1,
    rangle: rangle,
    raquo: raquo,
    rarrap: rarrap,
    rarrb: rarrb,
    rarrbfs: rarrbfs,
    rarrc: rarrc,
    rarr: rarr,
    Rarr: Rarr,
    rArr: rArr,
    rarrfs: rarrfs,
    rarrhk: rarrhk,
    rarrlp: rarrlp,
    rarrpl: rarrpl,
    rarrsim: rarrsim,
    Rarrtl: Rarrtl,
    rarrtl: rarrtl,
    rarrw: rarrw,
    ratail: ratail,
    rAtail: rAtail,
    ratio: ratio,
    rationals: rationals,
    rbarr: rbarr,
    rBarr: rBarr,
    RBarr: RBarr,
    rbbrk: rbbrk,
    rbrace: rbrace,
    rbrack: rbrack,
    rbrke: rbrke,
    rbrksld: rbrksld,
    rbrkslu: rbrkslu,
    Rcaron: Rcaron,
    rcaron: rcaron,
    Rcedil: Rcedil,
    rcedil: rcedil,
    rceil: rceil,
    rcub: rcub,
    Rcy: Rcy,
    rcy: rcy,
    rdca: rdca,
    rdldhar: rdldhar,
    rdquo: rdquo,
    rdquor: rdquor,
    rdsh: rdsh,
    real: real,
    realine: realine,
    realpart: realpart,
    reals: reals,
    Re: Re,
    rect: rect,
    reg: reg,
    REG: REG,
    ReverseElement: ReverseElement,
    ReverseEquilibrium: ReverseEquilibrium,
    ReverseUpEquilibrium: ReverseUpEquilibrium,
    rfisht: rfisht,
    rfloor: rfloor,
    rfr: rfr,
    Rfr: Rfr,
    rHar: rHar,
    rhard: rhard,
    rharu: rharu,
    rharul: rharul,
    Rho: Rho,
    rho: rho,
    rhov: rhov,
    RightAngleBracket: RightAngleBracket,
    RightArrowBar: RightArrowBar,
    rightarrow: rightarrow,
    RightArrow: RightArrow,
    Rightarrow: Rightarrow,
    RightArrowLeftArrow: RightArrowLeftArrow,
    rightarrowtail: rightarrowtail,
    RightCeiling: RightCeiling,
    RightDoubleBracket: RightDoubleBracket,
    RightDownTeeVector: RightDownTeeVector,
    RightDownVectorBar: RightDownVectorBar,
    RightDownVector: RightDownVector,
    RightFloor: RightFloor,
    rightharpoondown: rightharpoondown,
    rightharpoonup: rightharpoonup,
    rightleftarrows: rightleftarrows,
    rightleftharpoons: rightleftharpoons,
    rightrightarrows: rightrightarrows,
    rightsquigarrow: rightsquigarrow,
    RightTeeArrow: RightTeeArrow,
    RightTee: RightTee,
    RightTeeVector: RightTeeVector,
    rightthreetimes: rightthreetimes,
    RightTriangleBar: RightTriangleBar,
    RightTriangle: RightTriangle,
    RightTriangleEqual: RightTriangleEqual,
    RightUpDownVector: RightUpDownVector,
    RightUpTeeVector: RightUpTeeVector,
    RightUpVectorBar: RightUpVectorBar,
    RightUpVector: RightUpVector,
    RightVectorBar: RightVectorBar,
    RightVector: RightVector,
    ring: ring,
    risingdotseq: risingdotseq,
    rlarr: rlarr,
    rlhar: rlhar,
    rlm: rlm,
    rmoustache: rmoustache,
    rmoust: rmoust,
    rnmid: rnmid,
    roang: roang,
    roarr: roarr,
    robrk: robrk,
    ropar: ropar,
    ropf: ropf,
    Ropf: Ropf,
    roplus: roplus,
    rotimes: rotimes,
    RoundImplies: RoundImplies,
    rpar: rpar,
    rpargt: rpargt,
    rppolint: rppolint,
    rrarr: rrarr,
    Rrightarrow: Rrightarrow,
    rsaquo: rsaquo,
    rscr: rscr,
    Rscr: Rscr,
    rsh: rsh,
    Rsh: Rsh,
    rsqb: rsqb,
    rsquo: rsquo,
    rsquor: rsquor,
    rthree: rthree,
    rtimes: rtimes,
    rtri: rtri,
    rtrie: rtrie,
    rtrif: rtrif,
    rtriltri: rtriltri,
    RuleDelayed: RuleDelayed,
    ruluhar: ruluhar,
    rx: rx,
    Sacute: Sacute,
    sacute: sacute,
    sbquo: sbquo,
    scap: scap,
    Scaron: Scaron,
    scaron: scaron,
    Sc: Sc,
    sc: sc,
    sccue: sccue,
    sce: sce,
    scE: scE,
    Scedil: Scedil,
    scedil: scedil,
    Scirc: Scirc,
    scirc: scirc,
    scnap: scnap,
    scnE: scnE,
    scnsim: scnsim,
    scpolint: scpolint,
    scsim: scsim,
    Scy: Scy,
    scy: scy,
    sdotb: sdotb,
    sdot: sdot,
    sdote: sdote,
    searhk: searhk,
    searr: searr,
    seArr: seArr,
    searrow: searrow,
    sect: sect,
    semi: semi,
    seswar: seswar,
    setminus: setminus,
    setmn: setmn,
    sext: sext,
    Sfr: Sfr,
    sfr: sfr,
    sfrown: sfrown,
    sharp: sharp,
    SHCHcy: SHCHcy,
    shchcy: shchcy,
    SHcy: SHcy,
    shcy: shcy,
    ShortDownArrow: ShortDownArrow,
    ShortLeftArrow: ShortLeftArrow,
    shortmid: shortmid,
    shortparallel: shortparallel,
    ShortRightArrow: ShortRightArrow,
    ShortUpArrow: ShortUpArrow,
    shy: shy,
    Sigma: Sigma,
    sigma: sigma,
    sigmaf: sigmaf,
    sigmav: sigmav,
    sim: sim,
    simdot: simdot,
    sime: sime,
    simeq: simeq,
    simg: simg,
    simgE: simgE,
    siml: siml,
    simlE: simlE,
    simne: simne,
    simplus: simplus,
    simrarr: simrarr,
    slarr: slarr,
    SmallCircle: SmallCircle,
    smallsetminus: smallsetminus,
    smashp: smashp,
    smeparsl: smeparsl,
    smid: smid,
    smile: smile,
    smt: smt,
    smte: smte,
    smtes: smtes,
    SOFTcy: SOFTcy,
    softcy: softcy,
    solbar: solbar,
    solb: solb,
    sol: sol,
    Sopf: Sopf,
    sopf: sopf,
    spades: spades,
    spadesuit: spadesuit,
    spar: spar,
    sqcap: sqcap,
    sqcaps: sqcaps,
    sqcup: sqcup,
    sqcups: sqcups,
    Sqrt: Sqrt,
    sqsub: sqsub,
    sqsube: sqsube,
    sqsubset: sqsubset,
    sqsubseteq: sqsubseteq,
    sqsup: sqsup,
    sqsupe: sqsupe,
    sqsupset: sqsupset,
    sqsupseteq: sqsupseteq,
    square: square,
    Square: Square,
    SquareIntersection: SquareIntersection,
    SquareSubset: SquareSubset,
    SquareSubsetEqual: SquareSubsetEqual,
    SquareSuperset: SquareSuperset,
    SquareSupersetEqual: SquareSupersetEqual,
    SquareUnion: SquareUnion,
    squarf: squarf,
    squ: squ,
    squf: squf,
    srarr: srarr,
    Sscr: Sscr,
    sscr: sscr,
    ssetmn: ssetmn,
    ssmile: ssmile,
    sstarf: sstarf,
    Star: Star,
    star: star,
    starf: starf,
    straightepsilon: straightepsilon,
    straightphi: straightphi,
    strns: strns,
    sub: sub,
    Sub: Sub,
    subdot: subdot,
    subE: subE,
    sube: sube,
    subedot: subedot,
    submult: submult,
    subnE: subnE,
    subne: subne,
    subplus: subplus,
    subrarr: subrarr,
    subset: subset,
    Subset: Subset,
    subseteq: subseteq,
    subseteqq: subseteqq,
    SubsetEqual: SubsetEqual,
    subsetneq: subsetneq,
    subsetneqq: subsetneqq,
    subsim: subsim,
    subsub: subsub,
    subsup: subsup,
    succapprox: succapprox,
    succ: succ,
    succcurlyeq: succcurlyeq,
    Succeeds: Succeeds,
    SucceedsEqual: SucceedsEqual,
    SucceedsSlantEqual: SucceedsSlantEqual,
    SucceedsTilde: SucceedsTilde,
    succeq: succeq,
    succnapprox: succnapprox,
    succneqq: succneqq,
    succnsim: succnsim,
    succsim: succsim,
    SuchThat: SuchThat,
    sum: sum,
    Sum: Sum,
    sung: sung,
    sup1: sup1,
    sup2: sup2,
    sup3: sup3,
    sup: sup,
    Sup: Sup,
    supdot: supdot,
    supdsub: supdsub,
    supE: supE,
    supe: supe,
    supedot: supedot,
    Superset: Superset,
    SupersetEqual: SupersetEqual,
    suphsol: suphsol,
    suphsub: suphsub,
    suplarr: suplarr,
    supmult: supmult,
    supnE: supnE,
    supne: supne,
    supplus: supplus,
    supset: supset,
    Supset: Supset,
    supseteq: supseteq,
    supseteqq: supseteqq,
    supsetneq: supsetneq,
    supsetneqq: supsetneqq,
    supsim: supsim,
    supsub: supsub,
    supsup: supsup,
    swarhk: swarhk,
    swarr: swarr,
    swArr: swArr,
    swarrow: swarrow,
    swnwar: swnwar,
    szlig: szlig,
    Tab: Tab,
    target: target,
    Tau: Tau,
    tau: tau,
    tbrk: tbrk,
    Tcaron: Tcaron,
    tcaron: tcaron,
    Tcedil: Tcedil,
    tcedil: tcedil,
    Tcy: Tcy,
    tcy: tcy,
    tdot: tdot,
    telrec: telrec,
    Tfr: Tfr,
    tfr: tfr,
    there4: there4,
    therefore: therefore,
    Therefore: Therefore,
    Theta: Theta,
    theta: theta,
    thetasym: thetasym,
    thetav: thetav,
    thickapprox: thickapprox,
    thicksim: thicksim,
    ThickSpace: ThickSpace,
    ThinSpace: ThinSpace,
    thinsp: thinsp,
    thkap: thkap,
    thksim: thksim,
    THORN: THORN,
    thorn: thorn,
    tilde: tilde,
    Tilde: Tilde,
    TildeEqual: TildeEqual,
    TildeFullEqual: TildeFullEqual,
    TildeTilde: TildeTilde,
    timesbar: timesbar,
    timesb: timesb,
    times: times,
    timesd: timesd,
    tint: tint,
    toea: toea,
    topbot: topbot,
    topcir: topcir,
    top: top,
    Topf: Topf,
    topf: topf,
    topfork: topfork,
    tosa: tosa,
    tprime: tprime,
    trade: trade,
    TRADE: TRADE,
    triangle: triangle,
    triangledown: triangledown,
    triangleleft: triangleleft,
    trianglelefteq: trianglelefteq,
    triangleq: triangleq,
    triangleright: triangleright,
    trianglerighteq: trianglerighteq,
    tridot: tridot,
    trie: trie,
    triminus: triminus,
    TripleDot: TripleDot,
    triplus: triplus,
    trisb: trisb,
    tritime: tritime,
    trpezium: trpezium,
    Tscr: Tscr,
    tscr: tscr,
    TScy: TScy,
    tscy: tscy,
    TSHcy: TSHcy,
    tshcy: tshcy,
    Tstrok: Tstrok,
    tstrok: tstrok,
    twixt: twixt,
    twoheadleftarrow: twoheadleftarrow,
    twoheadrightarrow: twoheadrightarrow,
    Uacute: Uacute,
    uacute: uacute,
    uarr: uarr,
    Uarr: Uarr,
    uArr: uArr,
    Uarrocir: Uarrocir,
    Ubrcy: Ubrcy,
    ubrcy: ubrcy,
    Ubreve: Ubreve,
    ubreve: ubreve,
    Ucirc: Ucirc,
    ucirc: ucirc,
    Ucy: Ucy,
    ucy: ucy,
    udarr: udarr,
    Udblac: Udblac,
    udblac: udblac,
    udhar: udhar,
    ufisht: ufisht,
    Ufr: Ufr,
    ufr: ufr,
    Ugrave: Ugrave,
    ugrave: ugrave,
    uHar: uHar,
    uharl: uharl,
    uharr: uharr,
    uhblk: uhblk,
    ulcorn: ulcorn,
    ulcorner: ulcorner,
    ulcrop: ulcrop,
    ultri: ultri,
    Umacr: Umacr,
    umacr: umacr,
    uml: uml,
    UnderBar: UnderBar,
    UnderBrace: UnderBrace,
    UnderBracket: UnderBracket,
    UnderParenthesis: UnderParenthesis,
    Union: Union,
    UnionPlus: UnionPlus,
    Uogon: Uogon,
    uogon: uogon,
    Uopf: Uopf,
    uopf: uopf,
    UpArrowBar: UpArrowBar,
    uparrow: uparrow,
    UpArrow: UpArrow,
    Uparrow: Uparrow,
    UpArrowDownArrow: UpArrowDownArrow,
    updownarrow: updownarrow,
    UpDownArrow: UpDownArrow,
    Updownarrow: Updownarrow,
    UpEquilibrium: UpEquilibrium,
    upharpoonleft: upharpoonleft,
    upharpoonright: upharpoonright,
    uplus: uplus,
    UpperLeftArrow: UpperLeftArrow,
    UpperRightArrow: UpperRightArrow,
    upsi: upsi,
    Upsi: Upsi,
    upsih: upsih,
    Upsilon: Upsilon,
    upsilon: upsilon,
    UpTeeArrow: UpTeeArrow,
    UpTee: UpTee,
    upuparrows: upuparrows,
    urcorn: urcorn,
    urcorner: urcorner,
    urcrop: urcrop,
    Uring: Uring,
    uring: uring,
    urtri: urtri,
    Uscr: Uscr,
    uscr: uscr,
    utdot: utdot,
    Utilde: Utilde,
    utilde: utilde,
    utri: utri,
    utrif: utrif,
    uuarr: uuarr,
    Uuml: Uuml,
    uuml: uuml,
    uwangle: uwangle,
    vangrt: vangrt,
    varepsilon: varepsilon,
    varkappa: varkappa,
    varnothing: varnothing,
    varphi: varphi,
    varpi: varpi,
    varpropto: varpropto,
    varr: varr,
    vArr: vArr,
    varrho: varrho,
    varsigma: varsigma,
    varsubsetneq: varsubsetneq,
    varsubsetneqq: varsubsetneqq,
    varsupsetneq: varsupsetneq,
    varsupsetneqq: varsupsetneqq,
    vartheta: vartheta,
    vartriangleleft: vartriangleleft,
    vartriangleright: vartriangleright,
    vBar: vBar,
    Vbar: Vbar,
    vBarv: vBarv,
    Vcy: Vcy,
    vcy: vcy,
    vdash: vdash,
    vDash: vDash,
    Vdash: Vdash,
    VDash: VDash,
    Vdashl: Vdashl,
    veebar: veebar,
    vee: vee,
    Vee: Vee,
    veeeq: veeeq,
    vellip: vellip,
    verbar: verbar,
    Verbar: Verbar,
    vert: vert,
    Vert: Vert,
    VerticalBar: VerticalBar,
    VerticalLine: VerticalLine,
    VerticalSeparator: VerticalSeparator,
    VerticalTilde: VerticalTilde,
    VeryThinSpace: VeryThinSpace,
    Vfr: Vfr,
    vfr: vfr,
    vltri: vltri,
    vnsub: vnsub,
    vnsup: vnsup,
    Vopf: Vopf,
    vopf: vopf,
    vprop: vprop,
    vrtri: vrtri,
    Vscr: Vscr,
    vscr: vscr,
    vsubnE: vsubnE,
    vsubne: vsubne,
    vsupnE: vsupnE,
    vsupne: vsupne,
    Vvdash: Vvdash,
    vzigzag: vzigzag,
    Wcirc: Wcirc,
    wcirc: wcirc,
    wedbar: wedbar,
    wedge: wedge,
    Wedge: Wedge,
    wedgeq: wedgeq,
    weierp: weierp,
    Wfr: Wfr,
    wfr: wfr,
    Wopf: Wopf,
    wopf: wopf,
    wp: wp,
    wr: wr,
    wreath: wreath,
    Wscr: Wscr,
    wscr: wscr,
    xcap: xcap,
    xcirc: xcirc,
    xcup: xcup,
    xdtri: xdtri,
    Xfr: Xfr,
    xfr: xfr,
    xharr: xharr,
    xhArr: xhArr,
    Xi: Xi,
    xi: xi,
    xlarr: xlarr,
    xlArr: xlArr,
    xmap: xmap,
    xnis: xnis,
    xodot: xodot,
    Xopf: Xopf,
    xopf: xopf,
    xoplus: xoplus,
    xotime: xotime,
    xrarr: xrarr,
    xrArr: xrArr,
    Xscr: Xscr,
    xscr: xscr,
    xsqcup: xsqcup,
    xuplus: xuplus,
    xutri: xutri,
    xvee: xvee,
    xwedge: xwedge,
    Yacute: Yacute,
    yacute: yacute,
    YAcy: YAcy,
    yacy: yacy,
    Ycirc: Ycirc,
    ycirc: ycirc,
    Ycy: Ycy,
    ycy: ycy,
    yen: yen,
    Yfr: Yfr,
    yfr: yfr,
    YIcy: YIcy,
    yicy: yicy,
    Yopf: Yopf,
    yopf: yopf,
    Yscr: Yscr,
    yscr: yscr,
    YUcy: YUcy,
    yucy: yucy,
    yuml: yuml,
    Yuml: Yuml,
    Zacute: Zacute,
    zacute: zacute,
    Zcaron: Zcaron,
    zcaron: zcaron,
    Zcy: Zcy,
    zcy: zcy,
    Zdot: Zdot,
    zdot: zdot,
    zeetrf: zeetrf,
    ZeroWidthSpace: ZeroWidthSpace,
    Zeta: Zeta,
    zeta: zeta,
    zfr: zfr,
    Zfr: Zfr,
    ZHcy: ZHcy,
    zhcy: zhcy,
    zigrarr: zigrarr,
    zopf: zopf,
    Zopf: Zopf,
    Zscr: Zscr,
    zscr: zscr,
    zwj: zwj,
    zwnj: zwnj,
    default: entities
  });

  var require$$0 = ( entities$1 && entities ) || entities$1;

  /*eslint quotes:0*/


  var entities$2 = require$$0;

  var regex = /[!-#%-\*,-/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E49\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;

  var encodeCache = {}; // Create a lookup array where anything but characters in `chars` string
  // and alphanumeric chars is percent-encoded.
  //

  function getEncodeCache(exclude) {
    var i,
        ch,
        cache = encodeCache[exclude];

    if (cache) {
      return cache;
    }

    cache = encodeCache[exclude] = [];

    for (i = 0; i < 128; i++) {
      ch = String.fromCharCode(i);

      if (/^[0-9a-z]$/i.test(ch)) {
        // always allow unencoded alphanumeric characters
        cache.push(ch);
      } else {
        cache.push('%' + ('0' + i.toString(16).toUpperCase()).slice(-2));
      }
    }

    for (i = 0; i < exclude.length; i++) {
      cache[exclude.charCodeAt(i)] = exclude[i];
    }

    return cache;
  } // Encode unsafe characters with percent-encoding, skipping already
  // encoded sequences.
  //
  //  - string       - string to encode
  //  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)
  //  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)
  //


  function encode(string, exclude, keepEscaped) {
    var i,
        l,
        code,
        nextCode,
        cache,
        result = '';

    if (typeof exclude !== 'string') {
      // encode(string, keepEscaped)
      keepEscaped = exclude;
      exclude = encode.defaultChars;
    }

    if (typeof keepEscaped === 'undefined') {
      keepEscaped = true;
    }

    cache = getEncodeCache(exclude);

    for (i = 0, l = string.length; i < l; i++) {
      code = string.charCodeAt(i);

      if (keepEscaped && code === 0x25
      /* % */
      && i + 2 < l) {
        if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
          result += string.slice(i, i + 3);
          i += 2;
          continue;
        }
      }

      if (code < 128) {
        result += cache[code];
        continue;
      }

      if (code >= 0xD800 && code <= 0xDFFF) {
        if (code >= 0xD800 && code <= 0xDBFF && i + 1 < l) {
          nextCode = string.charCodeAt(i + 1);

          if (nextCode >= 0xDC00 && nextCode <= 0xDFFF) {
            result += encodeURIComponent(string[i] + string[i + 1]);
            i++;
            continue;
          }
        }

        result += '%EF%BF%BD';
        continue;
      }

      result += encodeURIComponent(string[i]);
    }

    return result;
  }

  encode.defaultChars = ";/?:@&=+$,-_.!~*'()#";
  encode.componentChars = "-_.!~*'()";
  var encode_1 = encode;

  var decodeCache = {};

  function getDecodeCache(exclude) {
    var i,
        ch,
        cache = decodeCache[exclude];

    if (cache) {
      return cache;
    }

    cache = decodeCache[exclude] = [];

    for (i = 0; i < 128; i++) {
      ch = String.fromCharCode(i);
      cache.push(ch);
    }

    for (i = 0; i < exclude.length; i++) {
      ch = exclude.charCodeAt(i);
      cache[ch] = '%' + ('0' + ch.toString(16).toUpperCase()).slice(-2);
    }

    return cache;
  } // Decode percent-encoded string.
  //


  function decode(string, exclude) {
    var cache;

    if (typeof exclude !== 'string') {
      exclude = decode.defaultChars;
    }

    cache = getDecodeCache(exclude);
    return string.replace(/(%[a-f0-9]{2})+/gi, function (seq) {
      var i,
          l,
          b1,
          b2,
          b3,
          b4,
          chr,
          result = '';

      for (i = 0, l = seq.length; i < l; i += 3) {
        b1 = parseInt(seq.slice(i + 1, i + 3), 16);

        if (b1 < 0x80) {
          result += cache[b1];
          continue;
        }

        if ((b1 & 0xE0) === 0xC0 && i + 3 < l) {
          // 110xxxxx 10xxxxxx
          b2 = parseInt(seq.slice(i + 4, i + 6), 16);

          if ((b2 & 0xC0) === 0x80) {
            chr = b1 << 6 & 0x7C0 | b2 & 0x3F;

            if (chr < 0x80) {
              result += "\uFFFD\uFFFD";
            } else {
              result += String.fromCharCode(chr);
            }

            i += 3;
            continue;
          }
        }

        if ((b1 & 0xF0) === 0xE0 && i + 6 < l) {
          // 1110xxxx 10xxxxxx 10xxxxxx
          b2 = parseInt(seq.slice(i + 4, i + 6), 16);
          b3 = parseInt(seq.slice(i + 7, i + 9), 16);

          if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {
            chr = b1 << 12 & 0xF000 | b2 << 6 & 0xFC0 | b3 & 0x3F;

            if (chr < 0x800 || chr >= 0xD800 && chr <= 0xDFFF) {
              result += "\uFFFD\uFFFD\uFFFD";
            } else {
              result += String.fromCharCode(chr);
            }

            i += 6;
            continue;
          }
        }

        if ((b1 & 0xF8) === 0xF0 && i + 9 < l) {
          // 111110xx 10xxxxxx 10xxxxxx 10xxxxxx
          b2 = parseInt(seq.slice(i + 4, i + 6), 16);
          b3 = parseInt(seq.slice(i + 7, i + 9), 16);
          b4 = parseInt(seq.slice(i + 10, i + 12), 16);

          if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80 && (b4 & 0xC0) === 0x80) {
            chr = b1 << 18 & 0x1C0000 | b2 << 12 & 0x3F000 | b3 << 6 & 0xFC0 | b4 & 0x3F;

            if (chr < 0x10000 || chr > 0x10FFFF) {
              result += "\uFFFD\uFFFD\uFFFD\uFFFD";
            } else {
              chr -= 0x10000;
              result += String.fromCharCode(0xD800 + (chr >> 10), 0xDC00 + (chr & 0x3FF));
            }

            i += 9;
            continue;
          }
        }

        result += "\uFFFD";
      }

      return result;
    });
  }

  decode.defaultChars = ';/?:@&=+$,#';
  decode.componentChars = '';
  var decode_1 = decode;

  // @@search logic
  _fixReWks('search', 1, function (defined, SEARCH, $search) {
    // 21.1.3.15 String.prototype.search(regexp)
    return [function search(regexp) {
      var O = defined(this);
      var fn = regexp == undefined ? undefined : regexp[SEARCH];
      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
    }, $search];
  });

  var format = function format(url) {
    var result = '';
    result += url.protocol || '';
    result += url.slashes ? '//' : '';
    result += url.auth ? url.auth + '@' : '';

    if (url.hostname && url.hostname.indexOf(':') !== -1) {
      // ipv6 address
      result += '[' + url.hostname + ']';
    } else {
      result += url.hostname || '';
    }

    result += url.port ? ':' + url.port : '';
    result += url.pathname || '';
    result += url.search || '';
    result += url.hash || '';
    return result;
  };

  // @@match logic
  _fixReWks('match', 1, function (defined, MATCH, $match) {
    // 21.1.3.11 String.prototype.match(regexp)
    return [function match(regexp) {
      var O = defined(this);
      var fn = regexp == undefined ? undefined : regexp[MATCH];
      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
    }, $match];
  });

  // Copyright Joyent, Inc. and other Node contributors.

  function Url() {
    this.protocol = null;
    this.slashes = null;
    this.auth = null;
    this.port = null;
    this.hostname = null;
    this.hash = null;
    this.search = null;
    this.pathname = null;
  } // Reference: RFC 3986, RFC 1808, RFC 2396
  // define these here so at least they only have to be
  // compiled once on the first module load.


  var protocolPattern = /^([a-z0-9.+-]+:)/i,
      portPattern = /:[0-9]*$/,
      // Special case for a simple path URL
  simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
      // RFC 2396: characters reserved for delimiting URLs.
  // We actually just auto-escape these.
  delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],
      // RFC 2396: characters not allowed for various reasons.
  unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),
      // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
  autoEscape = ['\''].concat(unwise),
      // Characters that are never ever allowed in a hostname.
  // Note that any invalid chars are also handled, but these
  // are the ones that are *expected* to be seen, so we fast-path
  // them.
  nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
      hostEndingChars = ['/', '?', '#'],
      hostnameMaxLen = 255,
      hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
      hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
      // protocols that can allow "unsafe" and "unwise" chars.

  /* eslint-disable no-script-url */
  // protocols that never have a hostname.
  hostlessProtocol = {
    'javascript': true,
    'javascript:': true
  },
      // protocols that always contain a // bit.
  slashedProtocol = {
    'http': true,
    'https': true,
    'ftp': true,
    'gopher': true,
    'file': true,
    'http:': true,
    'https:': true,
    'ftp:': true,
    'gopher:': true,
    'file:': true
  };
  /* eslint-enable no-script-url */

  function urlParse(url, slashesDenoteHost) {
    if (url && url instanceof Url) {
      return url;
    }

    var u = new Url();
    u.parse(url, slashesDenoteHost);
    return u;
  }

  Url.prototype.parse = function (url, slashesDenoteHost) {
    var i,
        l,
        lowerProto,
        hec,
        slashes,
        rest = url; // trim before proceeding.
    // This is to support parse stuff like "  http://foo.com  \n"

    rest = rest.trim();

    if (!slashesDenoteHost && url.split('#').length === 1) {
      // Try fast path regexp
      var simplePath = simplePathPattern.exec(rest);

      if (simplePath) {
        this.pathname = simplePath[1];

        if (simplePath[2]) {
          this.search = simplePath[2];
        }

        return this;
      }
    }

    var proto = protocolPattern.exec(rest);

    if (proto) {
      proto = proto[0];
      lowerProto = proto.toLowerCase();
      this.protocol = proto;
      rest = rest.substr(proto.length);
    } // figure out if it's got a host
    // user@server is *always* interpreted as a hostname, and url
    // resolution will treat //foo/bar as host=foo,path=bar because that's
    // how the browser resolves relative URLs.


    if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
      slashes = rest.substr(0, 2) === '//';

      if (slashes && !(proto && hostlessProtocol[proto])) {
        rest = rest.substr(2);
        this.slashes = true;
      }
    }

    if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
      // there's a hostname.
      // the first instance of /, ?, ;, or # ends the host.
      //
      // If there is an @ in the hostname, then non-host chars *are* allowed
      // to the left of the last @ sign, unless some host-ending character
      // comes *before* the @-sign.
      // URLs are obnoxious.
      //
      // ex:
      // http://a@b@c/ => user:a@b host:c
      // http://a@b?@c => user:a host:c path:/?@c
      // v0.12 TODO(isaacs): This is not quite how Chrome does things.
      // Review our test case against browsers more comprehensively.
      // find the first instance of any hostEndingChars
      var hostEnd = -1;

      for (i = 0; i < hostEndingChars.length; i++) {
        hec = rest.indexOf(hostEndingChars[i]);

        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
          hostEnd = hec;
        }
      } // at this point, either we have an explicit point where the
      // auth portion cannot go past, or the last @ char is the decider.


      var auth, atSign;

      if (hostEnd === -1) {
        // atSign can be anywhere.
        atSign = rest.lastIndexOf('@');
      } else {
        // atSign must be in auth portion.
        // http://a@b/c@d => host:b auth:a path:/c@d
        atSign = rest.lastIndexOf('@', hostEnd);
      } // Now we have a portion which is definitely the auth.
      // Pull that off.


      if (atSign !== -1) {
        auth = rest.slice(0, atSign);
        rest = rest.slice(atSign + 1);
        this.auth = auth;
      } // the host is the remaining to the left of the first non-host char


      hostEnd = -1;

      for (i = 0; i < nonHostChars.length; i++) {
        hec = rest.indexOf(nonHostChars[i]);

        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
          hostEnd = hec;
        }
      } // if we still have not hit it, then the entire thing is a host.


      if (hostEnd === -1) {
        hostEnd = rest.length;
      }

      if (rest[hostEnd - 1] === ':') {
        hostEnd--;
      }

      var host = rest.slice(0, hostEnd);
      rest = rest.slice(hostEnd); // pull out port.

      this.parseHost(host); // we've indicated that there is a hostname,
      // so even if it's empty, it has to be present.

      this.hostname = this.hostname || ''; // if hostname begins with [ and ends with ]
      // assume that it's an IPv6 address.

      var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']'; // validate a little.

      if (!ipv6Hostname) {
        var hostparts = this.hostname.split(/\./);

        for (i = 0, l = hostparts.length; i < l; i++) {
          var part = hostparts[i];

          if (!part) {
            continue;
          }

          if (!part.match(hostnamePartPattern)) {
            var newpart = '';

            for (var j = 0, k = part.length; j < k; j++) {
              if (part.charCodeAt(j) > 127) {
                // we replace non-ASCII char with a temporary placeholder
                // we need this to make sure size of hostname is not
                // broken by replacing non-ASCII by nothing
                newpart += 'x';
              } else {
                newpart += part[j];
              }
            } // we test again with ASCII char only


            if (!newpart.match(hostnamePartPattern)) {
              var validParts = hostparts.slice(0, i);
              var notHost = hostparts.slice(i + 1);
              var bit = part.match(hostnamePartStart);

              if (bit) {
                validParts.push(bit[1]);
                notHost.unshift(bit[2]);
              }

              if (notHost.length) {
                rest = notHost.join('.') + rest;
              }

              this.hostname = validParts.join('.');
              break;
            }
          }
        }
      }

      if (this.hostname.length > hostnameMaxLen) {
        this.hostname = '';
      } // strip [ and ] from the hostname
      // the host field still retains them, though


      if (ipv6Hostname) {
        this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      }
    } // chop off from the tail first.


    var hash = rest.indexOf('#');

    if (hash !== -1) {
      // got a fragment string.
      this.hash = rest.substr(hash);
      rest = rest.slice(0, hash);
    }

    var qm = rest.indexOf('?');

    if (qm !== -1) {
      this.search = rest.substr(qm);
      rest = rest.slice(0, qm);
    }

    if (rest) {
      this.pathname = rest;
    }

    if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
      this.pathname = '';
    }

    return this;
  };

  Url.prototype.parseHost = function (host) {
    var port = portPattern.exec(host);

    if (port) {
      port = port[0];

      if (port !== ':') {
        this.port = port.substr(1);
      }

      host = host.substr(0, host.length - port.length);
    }

    if (host) {
      this.hostname = host;
    }
  };

  var parse = urlParse;

  var encode$1 = encode_1;
  var decode$1 = decode_1;
  var format$1 = format;
  var parse$1 = parse;
  var mdurl = {
    encode: encode$1,
    decode: decode$1,
    format: format$1,
    parse: parse$1
  };

  var regex$1 = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;

  var regex$2 = /[\0-\x1F\x7F-\x9F]/;

  var regex$3 = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804\uDCBD|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;

  var regex$4 = /[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/;

  var Any = regex$1;
  var Cc = regex$2;
  var Cf = regex$3;
  var P = regex;
  var Z = regex$4;
  var uc_micro = {
    Any: Any,
    Cc: Cc,
    Cf: Cf,
    P: P,
    Z: Z
  };

  var utils = createCommonjsModule(function (module, exports) {

    function _class(obj) {
      return Object.prototype.toString.call(obj);
    }

    function isString(obj) {
      return _class(obj) === '[object String]';
    }

    var _hasOwnProperty = Object.prototype.hasOwnProperty;

    function has(object, key) {
      return _hasOwnProperty.call(object, key);
    } // Merge objects
    //


    function assign(obj
    /*from1, from2, from3, ...*/
    ) {
      var sources = Array.prototype.slice.call(arguments, 1);
      sources.forEach(function (source) {
        if (!source) {
          return;
        }

        if (typeof source !== 'object') {
          throw new TypeError(source + 'must be object');
        }

        Object.keys(source).forEach(function (key) {
          obj[key] = source[key];
        });
      });
      return obj;
    } // Remove element from array and put another array at those position.
    // Useful for some operations with tokens


    function arrayReplaceAt(src, pos, newElements) {
      return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
    } ////////////////////////////////////////////////////////////////////////////////


    function isValidEntityCode(c) {
      /*eslint no-bitwise:0*/
      // broken sequence
      if (c >= 0xD800 && c <= 0xDFFF) {
        return false;
      } // never used


      if (c >= 0xFDD0 && c <= 0xFDEF) {
        return false;
      }

      if ((c & 0xFFFF) === 0xFFFF || (c & 0xFFFF) === 0xFFFE) {
        return false;
      } // control codes


      if (c >= 0x00 && c <= 0x08) {
        return false;
      }

      if (c === 0x0B) {
        return false;
      }

      if (c >= 0x0E && c <= 0x1F) {
        return false;
      }

      if (c >= 0x7F && c <= 0x9F) {
        return false;
      } // out of range


      if (c > 0x10FFFF) {
        return false;
      }

      return true;
    }

    function fromCodePoint(c) {
      /*eslint no-bitwise:0*/
      if (c > 0xffff) {
        c -= 0x10000;
        var surrogate1 = 0xd800 + (c >> 10),
            surrogate2 = 0xdc00 + (c & 0x3ff);
        return String.fromCharCode(surrogate1, surrogate2);
      }

      return String.fromCharCode(c);
    }

    var UNESCAPE_MD_RE = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g;
    var ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
    var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + '|' + ENTITY_RE.source, 'gi');
    var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;

    function replaceEntityPattern(match, name) {
      var code = 0;

      if (has(entities$2, name)) {
        return entities$2[name];
      }

      if (name.charCodeAt(0) === 0x23
      /* # */
      && DIGITAL_ENTITY_TEST_RE.test(name)) {
        code = name[1].toLowerCase() === 'x' ? parseInt(name.slice(2), 16) : parseInt(name.slice(1), 10);

        if (isValidEntityCode(code)) {
          return fromCodePoint(code);
        }
      }

      return match;
    }
    /*function replaceEntities(str) {
      if (str.indexOf('&') < 0) { return str; }
    
      return str.replace(ENTITY_RE, replaceEntityPattern);
    }*/


    function unescapeMd(str) {
      if (str.indexOf('\\') < 0) {
        return str;
      }

      return str.replace(UNESCAPE_MD_RE, '$1');
    }

    function unescapeAll(str) {
      if (str.indexOf('\\') < 0 && str.indexOf('&') < 0) {
        return str;
      }

      return str.replace(UNESCAPE_ALL_RE, function (match, escaped, entity) {
        if (escaped) {
          return escaped;
        }

        return replaceEntityPattern(match, entity);
      });
    } ////////////////////////////////////////////////////////////////////////////////


    var HTML_ESCAPE_TEST_RE = /[&<>"]/;
    var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
    var HTML_REPLACEMENTS = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;'
    };

    function replaceUnsafeChar(ch) {
      return HTML_REPLACEMENTS[ch];
    }

    function escapeHtml(str) {
      if (HTML_ESCAPE_TEST_RE.test(str)) {
        return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
      }

      return str;
    } ////////////////////////////////////////////////////////////////////////////////


    var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;

    function escapeRE(str) {
      return str.replace(REGEXP_ESCAPE_RE, '\\$&');
    } ////////////////////////////////////////////////////////////////////////////////


    function isSpace(code) {
      switch (code) {
        case 0x09:
        case 0x20:
          return true;
      }

      return false;
    } // Zs (unicode class) || [\t\f\v\r\n]


    function isWhiteSpace(code) {
      if (code >= 0x2000 && code <= 0x200A) {
        return true;
      }

      switch (code) {
        case 0x09: // \t

        case 0x0A: // \n

        case 0x0B: // \v

        case 0x0C: // \f

        case 0x0D: // \r

        case 0x20:
        case 0xA0:
        case 0x1680:
        case 0x202F:
        case 0x205F:
        case 0x3000:
          return true;
      }

      return false;
    } ////////////////////////////////////////////////////////////////////////////////

    /*eslint-disable max-len*/
    // Currently without astral characters support.


    function isPunctChar(ch) {
      return regex.test(ch);
    } // Markdown ASCII punctuation characters.
    //
    // !, ", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \, ], ^, _, `, {, |, }, or ~
    // http://spec.commonmark.org/0.15/#ascii-punctuation-character
    //
    // Don't confuse with unicode punctuation !!! It lacks some chars in ascii range.
    //


    function isMdAsciiPunct(ch) {
      switch (ch) {
        case 0x21
        /* ! */
        :
        case 0x22
        /* " */
        :
        case 0x23
        /* # */
        :
        case 0x24
        /* $ */
        :
        case 0x25
        /* % */
        :
        case 0x26
        /* & */
        :
        case 0x27
        /* ' */
        :
        case 0x28
        /* ( */
        :
        case 0x29
        /* ) */
        :
        case 0x2A
        /* * */
        :
        case 0x2B
        /* + */
        :
        case 0x2C
        /* , */
        :
        case 0x2D
        /* - */
        :
        case 0x2E
        /* . */
        :
        case 0x2F
        /* / */
        :
        case 0x3A
        /* : */
        :
        case 0x3B
        /* ; */
        :
        case 0x3C
        /* < */
        :
        case 0x3D
        /* = */
        :
        case 0x3E
        /* > */
        :
        case 0x3F
        /* ? */
        :
        case 0x40
        /* @ */
        :
        case 0x5B
        /* [ */
        :
        case 0x5C
        /* \ */
        :
        case 0x5D
        /* ] */
        :
        case 0x5E
        /* ^ */
        :
        case 0x5F
        /* _ */
        :
        case 0x60
        /* ` */
        :
        case 0x7B
        /* { */
        :
        case 0x7C
        /* | */
        :
        case 0x7D
        /* } */
        :
        case 0x7E
        /* ~ */
        :
          return true;

        default:
          return false;
      }
    } // Hepler to unify [reference labels].
    //


    function normalizeReference(str) {
      // use .toUpperCase() instead of .toLowerCase()
      // here to avoid a conflict with Object.prototype
      // members (most notably, `__proto__`)
      return str.trim().replace(/\s+/g, ' ').toUpperCase();
    } ////////////////////////////////////////////////////////////////////////////////
    // Re-export libraries commonly used in both markdown-it and its plugins,
    // so plugins won't have to depend on them explicitly, which reduces their
    // bundled size (e.g. a browser build).
    //


    exports.lib = {};
    exports.lib.mdurl = mdurl;
    exports.lib.ucmicro = uc_micro;
    exports.assign = assign;
    exports.isString = isString;
    exports.has = has;
    exports.unescapeMd = unescapeMd;
    exports.unescapeAll = unescapeAll;
    exports.isValidEntityCode = isValidEntityCode;
    exports.fromCodePoint = fromCodePoint; // exports.replaceEntities     = replaceEntities;

    exports.escapeHtml = escapeHtml;
    exports.arrayReplaceAt = arrayReplaceAt;
    exports.isSpace = isSpace;
    exports.isWhiteSpace = isWhiteSpace;
    exports.isMdAsciiPunct = isMdAsciiPunct;
    exports.isPunctChar = isPunctChar;
    exports.escapeRE = escapeRE;
    exports.normalizeReference = normalizeReference;
  });
  var utils_1 = utils.lib;
  var utils_2 = utils.assign;
  var utils_3 = utils.isString;
  var utils_4 = utils.has;
  var utils_5 = utils.unescapeMd;
  var utils_6 = utils.unescapeAll;
  var utils_7 = utils.isValidEntityCode;
  var utils_8 = utils.fromCodePoint;
  var utils_9 = utils.escapeHtml;
  var utils_10 = utils.arrayReplaceAt;
  var utils_11 = utils.isSpace;
  var utils_12 = utils.isWhiteSpace;
  var utils_13 = utils.isMdAsciiPunct;
  var utils_14 = utils.isPunctChar;
  var utils_15 = utils.escapeRE;
  var utils_16 = utils.normalizeReference;

  // Parse link label

  var parse_link_label = function parseLinkLabel(state, start, disableNested) {
    var level,
        found,
        marker,
        prevPos,
        labelEnd = -1,
        max = state.posMax,
        oldPos = state.pos;
    state.pos = start + 1;
    level = 1;

    while (state.pos < max) {
      marker = state.src.charCodeAt(state.pos);

      if (marker === 0x5D
      /* ] */
      ) {
          level--;

          if (level === 0) {
            found = true;
            break;
          }
        }

      prevPos = state.pos;
      state.md.inline.skipToken(state);

      if (marker === 0x5B
      /* [ */
      ) {
          if (prevPos === state.pos - 1) {
            // increase level if we find text `[`, which is not a part of any token
            level++;
          } else if (disableNested) {
            state.pos = oldPos;
            return -1;
          }
        }
    }

    if (found) {
      labelEnd = state.pos;
    } // restore old state


    state.pos = oldPos;
    return labelEnd;
  };

  var isSpace = utils.isSpace;
  var unescapeAll = utils.unescapeAll;

  var parse_link_destination = function parseLinkDestination(str, pos, max) {
    var code,
        level,
        lines = 0,
        start = pos,
        result = {
      ok: false,
      pos: 0,
      lines: 0,
      str: ''
    };

    if (str.charCodeAt(pos) === 0x3C
    /* < */
    ) {
        pos++;

        while (pos < max) {
          code = str.charCodeAt(pos);

          if (code === 0x0A
          /* \n */
          || isSpace(code)) {
            return result;
          }

          if (code === 0x3E
          /* > */
          ) {
              result.pos = pos + 1;
              result.str = unescapeAll(str.slice(start + 1, pos));
              result.ok = true;
              return result;
            }

          if (code === 0x5C
          /* \ */
          && pos + 1 < max) {
            pos += 2;
            continue;
          }

          pos++;
        } // no closing '>'


        return result;
      } // this should be ... } else { ... branch


    level = 0;

    while (pos < max) {
      code = str.charCodeAt(pos);

      if (code === 0x20) {
        break;
      } // ascii control characters


      if (code < 0x20 || code === 0x7F) {
        break;
      }

      if (code === 0x5C
      /* \ */
      && pos + 1 < max) {
        pos += 2;
        continue;
      }

      if (code === 0x28
      /* ( */
      ) {
          level++;
        }

      if (code === 0x29
      /* ) */
      ) {
          if (level === 0) {
            break;
          }

          level--;
        }

      pos++;
    }

    if (start === pos) {
      return result;
    }

    if (level !== 0) {
      return result;
    }

    result.str = unescapeAll(str.slice(start, pos));
    result.lines = lines;
    result.pos = pos;
    result.ok = true;
    return result;
  };

  var unescapeAll$1 = utils.unescapeAll;

  var parse_link_title = function parseLinkTitle(str, pos, max) {
    var code,
        marker,
        lines = 0,
        start = pos,
        result = {
      ok: false,
      pos: 0,
      lines: 0,
      str: ''
    };

    if (pos >= max) {
      return result;
    }

    marker = str.charCodeAt(pos);

    if (marker !== 0x22
    /* " */
    && marker !== 0x27
    /* ' */
    && marker !== 0x28
    /* ( */
    ) {
        return result;
      }

    pos++; // if opening marker is "(", switch it to closing marker ")"

    if (marker === 0x28) {
      marker = 0x29;
    }

    while (pos < max) {
      code = str.charCodeAt(pos);

      if (code === marker) {
        result.pos = pos + 1;
        result.lines = lines;
        result.str = unescapeAll$1(str.slice(start + 1, pos));
        result.ok = true;
        return result;
      } else if (code === 0x0A) {
        lines++;
      } else if (code === 0x5C
      /* \ */
      && pos + 1 < max) {
        pos++;

        if (str.charCodeAt(pos) === 0x0A) {
          lines++;
        }
      }

      pos++;
    }

    return result;
  };

  var parseLinkLabel = parse_link_label;
  var parseLinkDestination = parse_link_destination;
  var parseLinkTitle = parse_link_title;
  var helpers = {
    parseLinkLabel: parseLinkLabel,
    parseLinkDestination: parseLinkDestination,
    parseLinkTitle: parseLinkTitle
  };

  var assign = utils.assign;
  var unescapeAll$2 = utils.unescapeAll;
  var escapeHtml = utils.escapeHtml; ////////////////////////////////////////////////////////////////////////////////

  var default_rules = {};

  default_rules.code_inline = function (tokens, idx, options, env, slf) {
    var token = tokens[idx];
    return '<code' + slf.renderAttrs(token) + '>' + escapeHtml(tokens[idx].content) + '</code>';
  };

  default_rules.code_block = function (tokens, idx, options, env, slf) {
    var token = tokens[idx];
    return '<pre' + slf.renderAttrs(token) + '><code>' + escapeHtml(tokens[idx].content) + '</code></pre>\n';
  };

  default_rules.fence = function (tokens, idx, options, env, slf) {
    var token = tokens[idx],
        info = token.info ? unescapeAll$2(token.info).trim() : '',
        langName = '',
        highlighted,
        i,
        tmpAttrs,
        tmpToken;

    if (info) {
      langName = info.split(/\s+/g)[0];
    }

    if (options.highlight) {
      highlighted = options.highlight(token.content, langName) || escapeHtml(token.content);
    } else {
      highlighted = escapeHtml(token.content);
    }

    if (highlighted.indexOf('<pre') === 0) {
      return highlighted + '\n';
    } // If language exists, inject class gently, without modifying original token.
    // May be, one day we will add .clone() for token and simplify this part, but
    // now we prefer to keep things local.


    if (info) {
      i = token.attrIndex('class');
      tmpAttrs = token.attrs ? token.attrs.slice() : [];

      if (i < 0) {
        tmpAttrs.push(['class', options.langPrefix + langName]);
      } else {
        tmpAttrs[i][1] += ' ' + options.langPrefix + langName;
      } // Fake token just to render attributes


      tmpToken = {
        attrs: tmpAttrs
      };
      return '<pre><code' + slf.renderAttrs(tmpToken) + '>' + highlighted + '</code></pre>\n';
    }

    return '<pre><code' + slf.renderAttrs(token) + '>' + highlighted + '</code></pre>\n';
  };

  default_rules.image = function (tokens, idx, options, env, slf) {
    var token = tokens[idx]; // "alt" attr MUST be set, even if empty. Because it's mandatory and
    // should be placed on proper position for tests.
    //
    // Replace content with actual value

    token.attrs[token.attrIndex('alt')][1] = slf.renderInlineAsText(token.children, options, env);
    return slf.renderToken(tokens, idx, options);
  };

  default_rules.hardbreak = function (tokens, idx, options
  /*, env */
  ) {
    return options.xhtmlOut ? '<br />\n' : '<br>\n';
  };

  default_rules.softbreak = function (tokens, idx, options
  /*, env */
  ) {
    return options.breaks ? options.xhtmlOut ? '<br />\n' : '<br>\n' : '\n';
  };

  default_rules.text = function (tokens, idx
  /*, options, env */
  ) {
    return escapeHtml(tokens[idx].content);
  };

  default_rules.html_block = function (tokens, idx
  /*, options, env */
  ) {
    return tokens[idx].content;
  };

  default_rules.html_inline = function (tokens, idx
  /*, options, env */
  ) {
    return tokens[idx].content;
  };
  /**
   * new Renderer()
   *
   * Creates new [[Renderer]] instance and fill [[Renderer#rules]] with defaults.
   **/


  function Renderer() {
    /**
     * Renderer#rules -> Object
     *
     * Contains render rules for tokens. Can be updated and extended.
     *
     * ##### Example
     *
     * ```javascript
     * var md = require('markdown-it')();
     *
     * md.renderer.rules.strong_open  = function () { return '<b>'; };
     * md.renderer.rules.strong_close = function () { return '</b>'; };
     *
     * var result = md.renderInline(...);
     * ```
     *
     * Each rule is called as independent static function with fixed signature:
     *
     * ```javascript
     * function my_token_render(tokens, idx, options, env, renderer) {
     *   // ...
     *   return renderedHTML;
     * }
     * ```
     *
     * See [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js)
     * for more details and examples.
     **/
    this.rules = assign({}, default_rules);
  }
  /**
   * Renderer.renderAttrs(token) -> String
   *
   * Render token attributes to string.
   **/


  Renderer.prototype.renderAttrs = function renderAttrs(token) {
    var i, l, result;

    if (!token.attrs) {
      return '';
    }

    result = '';

    for (i = 0, l = token.attrs.length; i < l; i++) {
      result += ' ' + escapeHtml(token.attrs[i][0]) + '="' + escapeHtml(token.attrs[i][1]) + '"';
    }

    return result;
  };
  /**
   * Renderer.renderToken(tokens, idx, options) -> String
   * - tokens (Array): list of tokens
   * - idx (Numbed): token index to render
   * - options (Object): params of parser instance
   *
   * Default token renderer. Can be overriden by custom function
   * in [[Renderer#rules]].
   **/


  Renderer.prototype.renderToken = function renderToken(tokens, idx, options) {
    var nextToken,
        result = '',
        needLf = false,
        token = tokens[idx]; // Tight list paragraphs

    if (token.hidden) {
      return '';
    } // Insert a newline between hidden paragraph and subsequent opening
    // block-level tag.
    //
    // For example, here we should insert a newline before blockquote:
    //  - a
    //    >
    //


    if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {
      result += '\n';
    } // Add token name, e.g. `<img`


    result += (token.nesting === -1 ? '</' : '<') + token.tag; // Encode attributes, e.g. `<img src="foo"`

    result += this.renderAttrs(token); // Add a slash for self-closing tags, e.g. `<img src="foo" /`

    if (token.nesting === 0 && options.xhtmlOut) {
      result += ' /';
    } // Check if we need to add a newline after this tag


    if (token.block) {
      needLf = true;

      if (token.nesting === 1) {
        if (idx + 1 < tokens.length) {
          nextToken = tokens[idx + 1];

          if (nextToken.type === 'inline' || nextToken.hidden) {
            // Block-level tag containing an inline tag.
            //
            needLf = false;
          } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {
            // Opening tag + closing tag of the same type. E.g. `<li></li>`.
            //
            needLf = false;
          }
        }
      }
    }

    result += needLf ? '>\n' : '>';
    return result;
  };
  /**
   * Renderer.renderInline(tokens, options, env) -> String
   * - tokens (Array): list on block tokens to renter
   * - options (Object): params of parser instance
   * - env (Object): additional data from parsed input (references, for example)
   *
   * The same as [[Renderer.render]], but for single token of `inline` type.
   **/


  Renderer.prototype.renderInline = function (tokens, options, env) {
    var type,
        result = '',
        rules = this.rules;

    for (var i = 0, len = tokens.length; i < len; i++) {
      type = tokens[i].type;

      if (typeof rules[type] !== 'undefined') {
        result += rules[type](tokens, i, options, env, this);
      } else {
        result += this.renderToken(tokens, i, options);
      }
    }

    return result;
  };
  /** internal
   * Renderer.renderInlineAsText(tokens, options, env) -> String
   * - tokens (Array): list on block tokens to renter
   * - options (Object): params of parser instance
   * - env (Object): additional data from parsed input (references, for example)
   *
   * Special kludge for image `alt` attributes to conform CommonMark spec.
   * Don't try to use it! Spec requires to show `alt` content with stripped markup,
   * instead of simple escaping.
   **/


  Renderer.prototype.renderInlineAsText = function (tokens, options, env) {
    var result = '';

    for (var i = 0, len = tokens.length; i < len; i++) {
      if (tokens[i].type === 'text') {
        result += tokens[i].content;
      } else if (tokens[i].type === 'image') {
        result += this.renderInlineAsText(tokens[i].children, options, env);
      }
    }

    return result;
  };
  /**
   * Renderer.render(tokens, options, env) -> String
   * - tokens (Array): list on block tokens to renter
   * - options (Object): params of parser instance
   * - env (Object): additional data from parsed input (references, for example)
   *
   * Takes token stream and generates HTML. Probably, you will never need to call
   * this method directly.
   **/


  Renderer.prototype.render = function (tokens, options, env) {
    var i,
        len,
        type,
        result = '',
        rules = this.rules;

    for (i = 0, len = tokens.length; i < len; i++) {
      type = tokens[i].type;

      if (type === 'inline') {
        result += this.renderInline(tokens[i].children, options, env);
      } else if (typeof rules[type] !== 'undefined') {
        result += rules[tokens[i].type](tokens, i, options, env, this);
      } else {
        result += this.renderToken(tokens, i, options, env);
      }
    }

    return result;
  };

  var renderer = Renderer;

  /**
   * class Ruler
   *
   * Helper class, used by [[MarkdownIt#core]], [[MarkdownIt#block]] and
   * [[MarkdownIt#inline]] to manage sequences of functions (rules):
   *
   * - keep rules in defined order
   * - assign the name to each rule
   * - enable/disable rules
   * - add/replace rules
   * - allow assign rules to additional named chains (in the same)
   * - cacheing lists of active rules
   *
   * You will not need use this class directly until write plugins. For simple
   * rules control use [[MarkdownIt.disable]], [[MarkdownIt.enable]] and
   * [[MarkdownIt.use]].
   **/

  function Ruler() {
    // List of added rules. Each element is:
    //
    // {
    //   name: XXX,
    //   enabled: Boolean,
    //   fn: Function(),
    //   alt: [ name2, name3 ]
    // }
    //
    this.__rules__ = []; // Cached rule chains.
    //
    // First level - chain name, '' for default.
    // Second level - diginal anchor for fast filtering by charcodes.
    //

    this.__cache__ = null;
  } ////////////////////////////////////////////////////////////////////////////////
  // Helper methods, should not be used directly
  // Find rule index by name
  //


  Ruler.prototype.__find__ = function (name) {
    for (var i = 0; i < this.__rules__.length; i++) {
      if (this.__rules__[i].name === name) {
        return i;
      }
    }

    return -1;
  }; // Build rules lookup cache
  //


  Ruler.prototype.__compile__ = function () {
    var self = this;
    var chains = ['']; // collect unique names

    self.__rules__.forEach(function (rule) {
      if (!rule.enabled) {
        return;
      }

      rule.alt.forEach(function (altName) {
        if (chains.indexOf(altName) < 0) {
          chains.push(altName);
        }
      });
    });

    self.__cache__ = {};
    chains.forEach(function (chain) {
      self.__cache__[chain] = [];

      self.__rules__.forEach(function (rule) {
        if (!rule.enabled) {
          return;
        }

        if (chain && rule.alt.indexOf(chain) < 0) {
          return;
        }

        self.__cache__[chain].push(rule.fn);
      });
    });
  };
  /**
   * Ruler.at(name, fn [, options])
   * - name (String): rule name to replace.
   * - fn (Function): new rule function.
   * - options (Object): new rule options (not mandatory).
   *
   * Replace rule by name with new function & options. Throws error if name not
   * found.
   *
   * ##### Options:
   *
   * - __alt__ - array with names of "alternate" chains.
   *
   * ##### Example
   *
   * Replace existing typorgapher replacement rule with new one:
   *
   * ```javascript
   * var md = require('markdown-it')();
   *
   * md.core.ruler.at('replacements', function replace(state) {
   *   //...
   * });
   * ```
   **/


  Ruler.prototype.at = function (name, fn, options) {
    var index = this.__find__(name);

    var opt = options || {};

    if (index === -1) {
      throw new Error('Parser rule not found: ' + name);
    }

    this.__rules__[index].fn = fn;
    this.__rules__[index].alt = opt.alt || [];
    this.__cache__ = null;
  };
  /**
   * Ruler.before(beforeName, ruleName, fn [, options])
   * - beforeName (String): new rule will be added before this one.
   * - ruleName (String): name of added rule.
   * - fn (Function): rule function.
   * - options (Object): rule options (not mandatory).
   *
   * Add new rule to chain before one with given name. See also
   * [[Ruler.after]], [[Ruler.push]].
   *
   * ##### Options:
   *
   * - __alt__ - array with names of "alternate" chains.
   *
   * ##### Example
   *
   * ```javascript
   * var md = require('markdown-it')();
   *
   * md.block.ruler.before('paragraph', 'my_rule', function replace(state) {
   *   //...
   * });
   * ```
   **/


  Ruler.prototype.before = function (beforeName, ruleName, fn, options) {
    var index = this.__find__(beforeName);

    var opt = options || {};

    if (index === -1) {
      throw new Error('Parser rule not found: ' + beforeName);
    }

    this.__rules__.splice(index, 0, {
      name: ruleName,
      enabled: true,
      fn: fn,
      alt: opt.alt || []
    });

    this.__cache__ = null;
  };
  /**
   * Ruler.after(afterName, ruleName, fn [, options])
   * - afterName (String): new rule will be added after this one.
   * - ruleName (String): name of added rule.
   * - fn (Function): rule function.
   * - options (Object): rule options (not mandatory).
   *
   * Add new rule to chain after one with given name. See also
   * [[Ruler.before]], [[Ruler.push]].
   *
   * ##### Options:
   *
   * - __alt__ - array with names of "alternate" chains.
   *
   * ##### Example
   *
   * ```javascript
   * var md = require('markdown-it')();
   *
   * md.inline.ruler.after('text', 'my_rule', function replace(state) {
   *   //...
   * });
   * ```
   **/


  Ruler.prototype.after = function (afterName, ruleName, fn, options) {
    var index = this.__find__(afterName);

    var opt = options || {};

    if (index === -1) {
      throw new Error('Parser rule not found: ' + afterName);
    }

    this.__rules__.splice(index + 1, 0, {
      name: ruleName,
      enabled: true,
      fn: fn,
      alt: opt.alt || []
    });

    this.__cache__ = null;
  };
  /**
   * Ruler.push(ruleName, fn [, options])
   * - ruleName (String): name of added rule.
   * - fn (Function): rule function.
   * - options (Object): rule options (not mandatory).
   *
   * Push new rule to the end of chain. See also
   * [[Ruler.before]], [[Ruler.after]].
   *
   * ##### Options:
   *
   * - __alt__ - array with names of "alternate" chains.
   *
   * ##### Example
   *
   * ```javascript
   * var md = require('markdown-it')();
   *
   * md.core.ruler.push('my_rule', function replace(state) {
   *   //...
   * });
   * ```
   **/


  Ruler.prototype.push = function (ruleName, fn, options) {
    var opt = options || {};

    this.__rules__.push({
      name: ruleName,
      enabled: true,
      fn: fn,
      alt: opt.alt || []
    });

    this.__cache__ = null;
  };
  /**
   * Ruler.enable(list [, ignoreInvalid]) -> Array
   * - list (String|Array): list of rule names to enable.
   * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
   *
   * Enable rules with given names. If any rule name not found - throw Error.
   * Errors can be disabled by second param.
   *
   * Returns list of found rule names (if no exception happened).
   *
   * See also [[Ruler.disable]], [[Ruler.enableOnly]].
   **/


  Ruler.prototype.enable = function (list, ignoreInvalid) {
    if (!Array.isArray(list)) {
      list = [list];
    }

    var result = []; // Search by name and enable

    list.forEach(function (name) {
      var idx = this.__find__(name);

      if (idx < 0) {
        if (ignoreInvalid) {
          return;
        }

        throw new Error('Rules manager: invalid rule name ' + name);
      }

      this.__rules__[idx].enabled = true;
      result.push(name);
    }, this);
    this.__cache__ = null;
    return result;
  };
  /**
   * Ruler.enableOnly(list [, ignoreInvalid])
   * - list (String|Array): list of rule names to enable (whitelist).
   * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
   *
   * Enable rules with given names, and disable everything else. If any rule name
   * not found - throw Error. Errors can be disabled by second param.
   *
   * See also [[Ruler.disable]], [[Ruler.enable]].
   **/


  Ruler.prototype.enableOnly = function (list, ignoreInvalid) {
    if (!Array.isArray(list)) {
      list = [list];
    }

    this.__rules__.forEach(function (rule) {
      rule.enabled = false;
    });

    this.enable(list, ignoreInvalid);
  };
  /**
   * Ruler.disable(list [, ignoreInvalid]) -> Array
   * - list (String|Array): list of rule names to disable.
   * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
   *
   * Disable rules with given names. If any rule name not found - throw Error.
   * Errors can be disabled by second param.
   *
   * Returns list of found rule names (if no exception happened).
   *
   * See also [[Ruler.enable]], [[Ruler.enableOnly]].
   **/


  Ruler.prototype.disable = function (list, ignoreInvalid) {
    if (!Array.isArray(list)) {
      list = [list];
    }

    var result = []; // Search by name and disable

    list.forEach(function (name) {
      var idx = this.__find__(name);

      if (idx < 0) {
        if (ignoreInvalid) {
          return;
        }

        throw new Error('Rules manager: invalid rule name ' + name);
      }

      this.__rules__[idx].enabled = false;
      result.push(name);
    }, this);
    this.__cache__ = null;
    return result;
  };
  /**
   * Ruler.getRules(chainName) -> Array
   *
   * Return array of active functions (rules) for given chain name. It analyzes
   * rules configuration, compiles caches if not exists and returns result.
   *
   * Default chain name is `''` (empty string). It can't be skipped. That's
   * done intentionally, to keep signature monomorphic for high speed.
   **/


  Ruler.prototype.getRules = function (chainName) {
    if (this.__cache__ === null) {
      this.__compile__();
    } // Chain can be empty, if rules disabled. But we still have to return Array.


    return this.__cache__[chainName] || [];
  };

  var ruler = Ruler;

  // Normalize input string
  var NEWLINES_RE = /\r[\n\u0085]?|[\u2424\u2028\u0085]/g;
  var NULL_RE = /\u0000/g;

  var normalize = function inline(state) {
    var str; // Normalize newlines

    str = state.src.replace(NEWLINES_RE, '\n'); // Replace NULL characters

    str = str.replace(NULL_RE, "\uFFFD");
    state.src = str;
  };

  var block$1 = function block(state) {
    var token;

    if (state.inlineMode) {
      token = new state.Token('inline', '', 0);
      token.content = state.src;
      token.map = [0, 1];
      token.children = [];
      state.tokens.push(token);
    } else {
      state.md.block.parse(state.src, state.md, state.env, state.tokens);
    }
  };

  var inline = function inline(state) {
    var tokens = state.tokens,
        tok,
        i,
        l; // Parse inlines

    for (i = 0, l = tokens.length; i < l; i++) {
      tok = tokens[i];

      if (tok.type === 'inline') {
        state.md.inline.parse(tok.content, state.md, state.env, tok.children);
      }
    }
  };

  var arrayReplaceAt = utils.arrayReplaceAt;

  function isLinkOpen(str) {
    return /^<a[>\s]/i.test(str);
  }

  function isLinkClose(str) {
    return /^<\/a\s*>/i.test(str);
  }

  var linkify = function linkify(state) {
    var i,
        j,
        l,
        tokens,
        token,
        currentToken,
        nodes,
        ln,
        text,
        pos,
        lastPos,
        level,
        htmlLinkLevel,
        url,
        fullUrl,
        urlText,
        blockTokens = state.tokens,
        links;

    if (!state.md.options.linkify) {
      return;
    }

    for (j = 0, l = blockTokens.length; j < l; j++) {
      if (blockTokens[j].type !== 'inline' || !state.md.linkify.pretest(blockTokens[j].content)) {
        continue;
      }

      tokens = blockTokens[j].children;
      htmlLinkLevel = 0; // We scan from the end, to keep position when new tags added.
      // Use reversed logic in links start/end match

      for (i = tokens.length - 1; i >= 0; i--) {
        currentToken = tokens[i]; // Skip content of markdown links

        if (currentToken.type === 'link_close') {
          i--;

          while (tokens[i].level !== currentToken.level && tokens[i].type !== 'link_open') {
            i--;
          }

          continue;
        } // Skip content of html tag links


        if (currentToken.type === 'html_inline') {
          if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {
            htmlLinkLevel--;
          }

          if (isLinkClose(currentToken.content)) {
            htmlLinkLevel++;
          }
        }

        if (htmlLinkLevel > 0) {
          continue;
        }

        if (currentToken.type === 'text' && state.md.linkify.test(currentToken.content)) {
          text = currentToken.content;
          links = state.md.linkify.match(text); // Now split string to nodes

          nodes = [];
          level = currentToken.level;
          lastPos = 0;

          for (ln = 0; ln < links.length; ln++) {
            url = links[ln].url;
            fullUrl = state.md.normalizeLink(url);

            if (!state.md.validateLink(fullUrl)) {
              continue;
            }

            urlText = links[ln].text; // Linkifier might send raw hostnames like "example.com", where url
            // starts with domain name. So we prepend http:// in those cases,
            // and remove it afterwards.
            //

            if (!links[ln].schema) {
              urlText = state.md.normalizeLinkText('http://' + urlText).replace(/^http:\/\//, '');
            } else if (links[ln].schema === 'mailto:' && !/^mailto:/i.test(urlText)) {
              urlText = state.md.normalizeLinkText('mailto:' + urlText).replace(/^mailto:/, '');
            } else {
              urlText = state.md.normalizeLinkText(urlText);
            }

            pos = links[ln].index;

            if (pos > lastPos) {
              token = new state.Token('text', '', 0);
              token.content = text.slice(lastPos, pos);
              token.level = level;
              nodes.push(token);
            }

            token = new state.Token('link_open', 'a', 1);
            token.attrs = [['href', fullUrl]];
            token.level = level++;
            token.markup = 'linkify';
            token.info = 'auto';
            nodes.push(token);
            token = new state.Token('text', '', 0);
            token.content = urlText;
            token.level = level;
            nodes.push(token);
            token = new state.Token('link_close', 'a', -1);
            token.level = --level;
            token.markup = 'linkify';
            token.info = 'auto';
            nodes.push(token);
            lastPos = links[ln].lastIndex;
          }

          if (lastPos < text.length) {
            token = new state.Token('text', '', 0);
            token.content = text.slice(lastPos);
            token.level = level;
            nodes.push(token);
          } // replace current node


          blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);
        }
      }
    }
  };

  // Simple typographyc replacements
  var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/; // Workaround for phantomjs - need regex without /g flag,
  // or root check will fail every second time

  var SCOPED_ABBR_TEST_RE = /\((c|tm|r|p)\)/i;
  var SCOPED_ABBR_RE = /\((c|tm|r|p)\)/ig;
  var SCOPED_ABBR = {
    c: '©',
    r: '®',
    p: '§',
    tm: '™'
  };

  function replaceFn(match, name) {
    return SCOPED_ABBR[name.toLowerCase()];
  }

  function replace_scoped(inlineTokens) {
    var i,
        token,
        inside_autolink = 0;

    for (i = inlineTokens.length - 1; i >= 0; i--) {
      token = inlineTokens[i];

      if (token.type === 'text' && !inside_autolink) {
        token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);
      }

      if (token.type === 'link_open' && token.info === 'auto') {
        inside_autolink--;
      }

      if (token.type === 'link_close' && token.info === 'auto') {
        inside_autolink++;
      }
    }
  }

  function replace_rare(inlineTokens) {
    var i,
        token,
        inside_autolink = 0;

    for (i = inlineTokens.length - 1; i >= 0; i--) {
      token = inlineTokens[i];

      if (token.type === 'text' && !inside_autolink) {
        if (RARE_RE.test(token.content)) {
          token.content = token.content.replace(/\+-/g, '±') // .., ..., ....... -> …
          // but ?..... & !..... -> ?.. & !..
          .replace(/\.{2,}/g, '…').replace(/([?!])…/g, '$1..').replace(/([?!]){4,}/g, '$1$1$1').replace(/,{2,}/g, ',') // em-dash
          .replace(/(^|[^-])---([^-]|$)/mg, "$1\u2014$2") // en-dash
          .replace(/(^|\s)--(\s|$)/mg, "$1\u2013$2").replace(/(^|[^-\s])--([^-\s]|$)/mg, "$1\u2013$2");
        }
      }

      if (token.type === 'link_open' && token.info === 'auto') {
        inside_autolink--;
      }

      if (token.type === 'link_close' && token.info === 'auto') {
        inside_autolink++;
      }
    }
  }

  var replacements = function replace(state) {
    var blkIdx;

    if (!state.md.options.typographer) {
      return;
    }

    for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
      if (state.tokens[blkIdx].type !== 'inline') {
        continue;
      }

      if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
        replace_scoped(state.tokens[blkIdx].children);
      }

      if (RARE_RE.test(state.tokens[blkIdx].content)) {
        replace_rare(state.tokens[blkIdx].children);
      }
    }
  };

  var isWhiteSpace = utils.isWhiteSpace;
  var isPunctChar = utils.isPunctChar;
  var isMdAsciiPunct = utils.isMdAsciiPunct;
  var QUOTE_TEST_RE = /['"]/;
  var QUOTE_RE = /['"]/g;
  var APOSTROPHE = "\u2019";
  /* ’ */

  function replaceAt(str, index, ch) {
    return str.substr(0, index) + ch + str.substr(index + 1);
  }

  function process_inlines(tokens, state) {
    var i, token, text, t, pos, max, thisLevel, item, lastChar, nextChar, isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace, canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;
    stack = [];

    for (i = 0; i < tokens.length; i++) {
      token = tokens[i];
      thisLevel = tokens[i].level;

      for (j = stack.length - 1; j >= 0; j--) {
        if (stack[j].level <= thisLevel) {
          break;
        }
      }

      stack.length = j + 1;

      if (token.type !== 'text') {
        continue;
      }

      text = token.content;
      pos = 0;
      max = text.length;
      /*eslint no-labels:0,block-scoped-var:0*/

      OUTER: while (pos < max) {
        QUOTE_RE.lastIndex = pos;
        t = QUOTE_RE.exec(text);

        if (!t) {
          break;
        }

        canOpen = canClose = true;
        pos = t.index + 1;
        isSingle = t[0] === "'"; // Find previous character,
        // default to space if it's the beginning of the line
        //

        lastChar = 0x20;

        if (t.index - 1 >= 0) {
          lastChar = text.charCodeAt(t.index - 1);
        } else {
          for (j = i - 1; j >= 0; j--) {
            if (tokens[j].type === 'softbreak' || tokens[j].type === 'hardbreak') break; // lastChar defaults to 0x20

            if (tokens[j].type !== 'text') continue;
            lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);
            break;
          }
        } // Find next character,
        // default to space if it's the end of the line
        //


        nextChar = 0x20;

        if (pos < max) {
          nextChar = text.charCodeAt(pos);
        } else {
          for (j = i + 1; j < tokens.length; j++) {
            if (tokens[j].type === 'softbreak' || tokens[j].type === 'hardbreak') break; // nextChar defaults to 0x20

            if (tokens[j].type !== 'text') continue;
            nextChar = tokens[j].content.charCodeAt(0);
            break;
          }
        }

        isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
        isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
        isLastWhiteSpace = isWhiteSpace(lastChar);
        isNextWhiteSpace = isWhiteSpace(nextChar);

        if (isNextWhiteSpace) {
          canOpen = false;
        } else if (isNextPunctChar) {
          if (!(isLastWhiteSpace || isLastPunctChar)) {
            canOpen = false;
          }
        }

        if (isLastWhiteSpace) {
          canClose = false;
        } else if (isLastPunctChar) {
          if (!(isNextWhiteSpace || isNextPunctChar)) {
            canClose = false;
          }
        }

        if (nextChar === 0x22
        /* " */
        && t[0] === '"') {
          if (lastChar >= 0x30
          /* 0 */
          && lastChar <= 0x39
          /* 9 */
          ) {
              // special case: 1"" - count first quote as an inch
              canClose = canOpen = false;
            }
        }

        if (canOpen && canClose) {
          // treat this as the middle of the word
          canOpen = false;
          canClose = isNextPunctChar;
        }

        if (!canOpen && !canClose) {
          // middle of word
          if (isSingle) {
            token.content = replaceAt(token.content, t.index, APOSTROPHE);
          }

          continue;
        }

        if (canClose) {
          // this could be a closing quote, rewind the stack to get a match
          for (j = stack.length - 1; j >= 0; j--) {
            item = stack[j];

            if (stack[j].level < thisLevel) {
              break;
            }

            if (item.single === isSingle && stack[j].level === thisLevel) {
              item = stack[j];

              if (isSingle) {
                openQuote = state.md.options.quotes[2];
                closeQuote = state.md.options.quotes[3];
              } else {
                openQuote = state.md.options.quotes[0];
                closeQuote = state.md.options.quotes[1];
              } // replace token.content *before* tokens[item.token].content,
              // because, if they are pointing at the same token, replaceAt
              // could mess up indices when quote length != 1


              token.content = replaceAt(token.content, t.index, closeQuote);
              tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, openQuote);
              pos += closeQuote.length - 1;

              if (item.token === i) {
                pos += openQuote.length - 1;
              }

              text = token.content;
              max = text.length;
              stack.length = j;
              continue OUTER;
            }
          }
        }

        if (canOpen) {
          stack.push({
            token: i,
            pos: t.index,
            single: isSingle,
            level: thisLevel
          });
        } else if (canClose && isSingle) {
          token.content = replaceAt(token.content, t.index, APOSTROPHE);
        }
      }
    }
  }

  var smartquotes = function smartquotes(state) {
    /*eslint max-depth:0*/
    var blkIdx;

    if (!state.md.options.typographer) {
      return;
    }

    for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
      if (state.tokens[blkIdx].type !== 'inline' || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {
        continue;
      }

      process_inlines(state.tokens[blkIdx].children, state);
    }
  };

  // Token class
  /**
   * class Token
   **/

  /**
   * new Token(type, tag, nesting)
   *
   * Create new token and fill passed properties.
   **/

  function Token(type, tag, nesting) {
    /**
     * Token#type -> String
     *
     * Type of the token (string, e.g. "paragraph_open")
     **/
    this.type = type;
    /**
     * Token#tag -> String
     *
     * html tag name, e.g. "p"
     **/

    this.tag = tag;
    /**
     * Token#attrs -> Array
     *
     * Html attributes. Format: `[ [ name1, value1 ], [ name2, value2 ] ]`
     **/

    this.attrs = null;
    /**
     * Token#map -> Array
     *
     * Source map info. Format: `[ line_begin, line_end ]`
     **/

    this.map = null;
    /**
     * Token#nesting -> Number
     *
     * Level change (number in {-1, 0, 1} set), where:
     *
     * -  `1` means the tag is opening
     * -  `0` means the tag is self-closing
     * - `-1` means the tag is closing
     **/

    this.nesting = nesting;
    /**
     * Token#level -> Number
     *
     * nesting level, the same as `state.level`
     **/

    this.level = 0;
    /**
     * Token#children -> Array
     *
     * An array of child nodes (inline and img tokens)
     **/

    this.children = null;
    /**
     * Token#content -> String
     *
     * In a case of self-closing tag (code, html, fence, etc.),
     * it has contents of this tag.
     **/

    this.content = '';
    /**
     * Token#markup -> String
     *
     * '*' or '_' for emphasis, fence string for fence, etc.
     **/

    this.markup = '';
    /**
     * Token#info -> String
     *
     * fence infostring
     **/

    this.info = '';
    /**
     * Token#meta -> Object
     *
     * A place for plugins to store an arbitrary data
     **/

    this.meta = null;
    /**
     * Token#block -> Boolean
     *
     * True for block-level tokens, false for inline tokens.
     * Used in renderer to calculate line breaks
     **/

    this.block = false;
    /**
     * Token#hidden -> Boolean
     *
     * If it's true, ignore this element when rendering. Used for tight lists
     * to hide paragraphs.
     **/

    this.hidden = false;
  }
  /**
   * Token.attrIndex(name) -> Number
   *
   * Search attribute index by name.
   **/


  Token.prototype.attrIndex = function attrIndex(name) {
    var attrs, i, len;

    if (!this.attrs) {
      return -1;
    }

    attrs = this.attrs;

    for (i = 0, len = attrs.length; i < len; i++) {
      if (attrs[i][0] === name) {
        return i;
      }
    }

    return -1;
  };
  /**
   * Token.attrPush(attrData)
   *
   * Add `[ name, value ]` attribute to list. Init attrs if necessary
   **/


  Token.prototype.attrPush = function attrPush(attrData) {
    if (this.attrs) {
      this.attrs.push(attrData);
    } else {
      this.attrs = [attrData];
    }
  };
  /**
   * Token.attrSet(name, value)
   *
   * Set `name` attribute to `value`. Override old value if exists.
   **/


  Token.prototype.attrSet = function attrSet(name, value) {
    var idx = this.attrIndex(name),
        attrData = [name, value];

    if (idx < 0) {
      this.attrPush(attrData);
    } else {
      this.attrs[idx] = attrData;
    }
  };
  /**
   * Token.attrGet(name)
   *
   * Get the value of attribute `name`, or null if it does not exist.
   **/


  Token.prototype.attrGet = function attrGet(name) {
    var idx = this.attrIndex(name),
        value = null;

    if (idx >= 0) {
      value = this.attrs[idx][1];
    }

    return value;
  };
  /**
   * Token.attrJoin(name, value)
   *
   * Join value to existing attribute via space. Or create new attribute if not
   * exists. Useful to operate with token classes.
   **/


  Token.prototype.attrJoin = function attrJoin(name, value) {
    var idx = this.attrIndex(name);

    if (idx < 0) {
      this.attrPush([name, value]);
    } else {
      this.attrs[idx][1] = this.attrs[idx][1] + ' ' + value;
    }
  };

  var token = Token;

  function StateCore(src, md, env) {
    this.src = src;
    this.env = env;
    this.tokens = [];
    this.inlineMode = false;
    this.md = md; // link to parser instance
  } // re-export Token class to use in core rules


  StateCore.prototype.Token = token;
  var state_core = StateCore;

  var _rules = [['normalize', normalize], ['block', block$1], ['inline', inline], ['linkify', linkify], ['replacements', replacements], ['smartquotes', smartquotes]];
  /**
   * new Core()
   **/

  function Core() {
    /**
     * Core#ruler -> Ruler
     *
     * [[Ruler]] instance. Keep configuration of core rules.
     **/
    this.ruler = new ruler();

    for (var i = 0; i < _rules.length; i++) {
      this.ruler.push(_rules[i][0], _rules[i][1]);
    }
  }
  /**
   * Core.process(state)
   *
   * Executes core chain rules.
   **/


  Core.prototype.process = function (state) {
    var i, l, rules;
    rules = this.ruler.getRules('');

    for (i = 0, l = rules.length; i < l; i++) {
      rules[i](state);
    }
  };

  Core.prototype.State = state_core;
  var parser_core = Core;

  var isSpace$1 = utils.isSpace;

  function getLine(state, line) {
    var pos = state.bMarks[line] + state.blkIndent,
        max = state.eMarks[line];
    return state.src.substr(pos, max - pos);
  }

  function escapedSplit(str) {
    var result = [],
        pos = 0,
        max = str.length,
        ch,
        escapes = 0,
        lastPos = 0,
        backTicked = false,
        lastBackTick = 0;
    ch = str.charCodeAt(pos);

    while (pos < max) {
      if (ch === 0x60
      /* ` */
      ) {
          if (backTicked) {
            // make \` close code sequence, but not open it;
            // the reason is: `\` is correct code block
            backTicked = false;
            lastBackTick = pos;
          } else if (escapes % 2 === 0) {
            backTicked = true;
            lastBackTick = pos;
          }
        } else if (ch === 0x7c
      /* | */
      && escapes % 2 === 0 && !backTicked) {
        result.push(str.substring(lastPos, pos));
        lastPos = pos + 1;
      }

      if (ch === 0x5c
      /* \ */
      ) {
          escapes++;
        } else {
        escapes = 0;
      }

      pos++; // If there was an un-closed backtick, go back to just after
      // the last backtick, but as if it was a normal character

      if (pos === max && backTicked) {
        backTicked = false;
        pos = lastBackTick + 1;
      }

      ch = str.charCodeAt(pos);
    }

    result.push(str.substring(lastPos));
    return result;
  }

  var table = function table(state, startLine, endLine, silent) {
    var ch, lineText, pos, i, nextLine, columns, columnCount, token, aligns, t, tableLines, tbodyLines; // should have at least two lines

    if (startLine + 2 > endLine) {
      return false;
    }

    nextLine = startLine + 1;

    if (state.sCount[nextLine] < state.blkIndent) {
      return false;
    } // if it's indented more than 3 spaces, it should be a code block


    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      return false;
    } // first character of the second line should be '|', '-', ':',
    // and no other characters are allowed but spaces;
    // basically, this is the equivalent of /^[-:|][-:|\s]*$/ regexp


    pos = state.bMarks[nextLine] + state.tShift[nextLine];

    if (pos >= state.eMarks[nextLine]) {
      return false;
    }

    ch = state.src.charCodeAt(pos++);

    if (ch !== 0x7C
    /* | */
    && ch !== 0x2D
    /* - */
    && ch !== 0x3A
    /* : */
    ) {
        return false;
      }

    while (pos < state.eMarks[nextLine]) {
      ch = state.src.charCodeAt(pos);

      if (ch !== 0x7C
      /* | */
      && ch !== 0x2D
      /* - */
      && ch !== 0x3A
      /* : */
      && !isSpace$1(ch)) {
        return false;
      }

      pos++;
    }

    lineText = getLine(state, startLine + 1);
    columns = lineText.split('|');
    aligns = [];

    for (i = 0; i < columns.length; i++) {
      t = columns[i].trim();

      if (!t) {
        // allow empty columns before and after table, but not in between columns;
        // e.g. allow ` |---| `, disallow ` ---||--- `
        if (i === 0 || i === columns.length - 1) {
          continue;
        } else {
          return false;
        }
      }

      if (!/^:?-+:?$/.test(t)) {
        return false;
      }

      if (t.charCodeAt(t.length - 1) === 0x3A
      /* : */
      ) {
          aligns.push(t.charCodeAt(0) === 0x3A
          /* : */
          ? 'center' : 'right');
        } else if (t.charCodeAt(0) === 0x3A
      /* : */
      ) {
          aligns.push('left');
        } else {
        aligns.push('');
      }
    }

    lineText = getLine(state, startLine).trim();

    if (lineText.indexOf('|') === -1) {
      return false;
    }

    if (state.sCount[startLine] - state.blkIndent >= 4) {
      return false;
    }

    columns = escapedSplit(lineText.replace(/^\||\|$/g, '')); // header row will define an amount of columns in the entire table,
    // and align row shouldn't be smaller than that (the rest of the rows can)

    columnCount = columns.length;

    if (columnCount > aligns.length) {
      return false;
    }

    if (silent) {
      return true;
    }

    token = state.push('table_open', 'table', 1);
    token.map = tableLines = [startLine, 0];
    token = state.push('thead_open', 'thead', 1);
    token.map = [startLine, startLine + 1];
    token = state.push('tr_open', 'tr', 1);
    token.map = [startLine, startLine + 1];

    for (i = 0; i < columns.length; i++) {
      token = state.push('th_open', 'th', 1);
      token.map = [startLine, startLine + 1];

      if (aligns[i]) {
        token.attrs = [['style', 'text-align:' + aligns[i]]];
      }

      token = state.push('inline', '', 0);
      token.content = columns[i].trim();
      token.map = [startLine, startLine + 1];
      token.children = [];
      token = state.push('th_close', 'th', -1);
    }

    token = state.push('tr_close', 'tr', -1);
    token = state.push('thead_close', 'thead', -1);
    token = state.push('tbody_open', 'tbody', 1);
    token.map = tbodyLines = [startLine + 2, 0];

    for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
      if (state.sCount[nextLine] < state.blkIndent) {
        break;
      }

      lineText = getLine(state, nextLine).trim();

      if (lineText.indexOf('|') === -1) {
        break;
      }

      if (state.sCount[nextLine] - state.blkIndent >= 4) {
        break;
      }

      columns = escapedSplit(lineText.replace(/^\||\|$/g, ''));
      token = state.push('tr_open', 'tr', 1);

      for (i = 0; i < columnCount; i++) {
        token = state.push('td_open', 'td', 1);

        if (aligns[i]) {
          token.attrs = [['style', 'text-align:' + aligns[i]]];
        }

        token = state.push('inline', '', 0);
        token.content = columns[i] ? columns[i].trim() : '';
        token.children = [];
        token = state.push('td_close', 'td', -1);
      }

      token = state.push('tr_close', 'tr', -1);
    }

    token = state.push('tbody_close', 'tbody', -1);
    token = state.push('table_close', 'table', -1);
    tableLines[1] = tbodyLines[1] = nextLine;
    state.line = nextLine;
    return true;
  };

  // Code block (4 spaces padded)

  var code = function code(state, startLine, endLine
  /*, silent*/
  ) {
    var nextLine, last, token;

    if (state.sCount[startLine] - state.blkIndent < 4) {
      return false;
    }

    last = nextLine = startLine + 1;

    while (nextLine < endLine) {
      if (state.isEmpty(nextLine)) {
        nextLine++;
        continue;
      }

      if (state.sCount[nextLine] - state.blkIndent >= 4) {
        nextLine++;
        last = nextLine;
        continue;
      }

      break;
    }

    state.line = last;
    token = state.push('code_block', 'code', 0);
    token.content = state.getLines(startLine, last, 4 + state.blkIndent, true);
    token.map = [startLine, state.line];
    return true;
  };

  // fences (``` lang, ~~~ lang)

  var fence = function fence(state, startLine, endLine, silent) {
    var marker,
        len,
        params,
        nextLine,
        mem,
        token,
        markup,
        haveEndMarker = false,
        pos = state.bMarks[startLine] + state.tShift[startLine],
        max = state.eMarks[startLine]; // if it's indented more than 3 spaces, it should be a code block

    if (state.sCount[startLine] - state.blkIndent >= 4) {
      return false;
    }

    if (pos + 3 > max) {
      return false;
    }

    marker = state.src.charCodeAt(pos);

    if (marker !== 0x7E
    /* ~ */
    && marker !== 0x60
    /* ` */
    ) {
        return false;
      } // scan marker length


    mem = pos;
    pos = state.skipChars(pos, marker);
    len = pos - mem;

    if (len < 3) {
      return false;
    }

    markup = state.src.slice(mem, pos);
    params = state.src.slice(pos, max);

    if (params.indexOf(String.fromCharCode(marker)) >= 0) {
      return false;
    } // Since start is found, we can report success here in validation mode


    if (silent) {
      return true;
    } // search end of block


    nextLine = startLine;

    for (;;) {
      nextLine++;

      if (nextLine >= endLine) {
        // unclosed block should be autoclosed by end of document.
        // also block seems to be autoclosed by end of parent
        break;
      }

      pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];

      if (pos < max && state.sCount[nextLine] < state.blkIndent) {
        // non-empty line with negative indent should stop the list:
        // - ```
        //  test
        break;
      }

      if (state.src.charCodeAt(pos) !== marker) {
        continue;
      }

      if (state.sCount[nextLine] - state.blkIndent >= 4) {
        // closing fence should be indented less than 4 spaces
        continue;
      }

      pos = state.skipChars(pos, marker); // closing code fence must be at least as long as the opening one

      if (pos - mem < len) {
        continue;
      } // make sure tail has spaces only


      pos = state.skipSpaces(pos);

      if (pos < max) {
        continue;
      }

      haveEndMarker = true; // found!

      break;
    } // If a fence has heading spaces, they should be removed from its inner block


    len = state.sCount[startLine];
    state.line = nextLine + (haveEndMarker ? 1 : 0);
    token = state.push('fence', 'code', 0);
    token.info = params;
    token.content = state.getLines(startLine + 1, nextLine, len, true);
    token.markup = markup;
    token.map = [startLine, state.line];
    return true;
  };

  var isSpace$2 = utils.isSpace;

  var blockquote = function blockquote(state, startLine, endLine, silent) {
    var adjustTab,
        ch,
        i,
        initial,
        l,
        lastLineEmpty,
        lines,
        nextLine,
        offset,
        oldBMarks,
        oldBSCount,
        oldIndent,
        oldParentType,
        oldSCount,
        oldTShift,
        spaceAfterMarker,
        terminate,
        terminatorRules,
        token,
        wasOutdented,
        oldLineMax = state.lineMax,
        pos = state.bMarks[startLine] + state.tShift[startLine],
        max = state.eMarks[startLine]; // if it's indented more than 3 spaces, it should be a code block

    if (state.sCount[startLine] - state.blkIndent >= 4) {
      return false;
    } // check the block quote marker


    if (state.src.charCodeAt(pos++) !== 0x3E
    /* > */
    ) {
        return false;
      } // we know that it's going to be a valid blockquote,
    // so no point trying to find the end of it in silent mode


    if (silent) {
      return true;
    } // skip spaces after ">" and re-calculate offset


    initial = offset = state.sCount[startLine] + pos - (state.bMarks[startLine] + state.tShift[startLine]); // skip one optional space after '>'

    if (state.src.charCodeAt(pos) === 0x20
    /* space */
    ) {
        // ' >   test '
        //     ^ -- position start of line here:
        pos++;
        initial++;
        offset++;
        adjustTab = false;
        spaceAfterMarker = true;
      } else if (state.src.charCodeAt(pos) === 0x09
    /* tab */
    ) {
        spaceAfterMarker = true;

        if ((state.bsCount[startLine] + offset) % 4 === 3) {
          // '  >\t  test '
          //       ^ -- position start of line here (tab has width===1)
          pos++;
          initial++;
          offset++;
          adjustTab = false;
        } else {
          // ' >\t  test '
          //    ^ -- position start of line here + shift bsCount slightly
          //         to make extra space appear
          adjustTab = true;
        }
      } else {
      spaceAfterMarker = false;
    }

    oldBMarks = [state.bMarks[startLine]];
    state.bMarks[startLine] = pos;

    while (pos < max) {
      ch = state.src.charCodeAt(pos);

      if (isSpace$2(ch)) {
        if (ch === 0x09) {
          offset += 4 - (offset + state.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4;
        } else {
          offset++;
        }
      } else {
        break;
      }

      pos++;
    }

    oldBSCount = [state.bsCount[startLine]];
    state.bsCount[startLine] = state.sCount[startLine] + 1 + (spaceAfterMarker ? 1 : 0);
    lastLineEmpty = pos >= max;
    oldSCount = [state.sCount[startLine]];
    state.sCount[startLine] = offset - initial;
    oldTShift = [state.tShift[startLine]];
    state.tShift[startLine] = pos - state.bMarks[startLine];
    terminatorRules = state.md.block.ruler.getRules('blockquote');
    oldParentType = state.parentType;
    state.parentType = 'blockquote';
    wasOutdented = false; // Search the end of the block
    //
    // Block ends with either:
    //  1. an empty line outside:
    //     ```
    //     > test
    //
    //     ```
    //  2. an empty line inside:
    //     ```
    //     >
    //     test
    //     ```
    //  3. another tag:
    //     ```
    //     > test
    //      - - -
    //     ```

    for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {
      // check if it's outdented, i.e. it's inside list item and indented
      // less than said list item:
      //
      // ```
      // 1. anything
      //    > current blockquote
      // 2. checking this line
      // ```
      if (state.sCount[nextLine] < state.blkIndent) wasOutdented = true;
      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];

      if (pos >= max) {
        // Case 1: line is not inside the blockquote, and this line is empty.
        break;
      }

      if (state.src.charCodeAt(pos++) === 0x3E
      /* > */
      && !wasOutdented) {
        // This line is inside the blockquote.
        // skip spaces after ">" and re-calculate offset
        initial = offset = state.sCount[nextLine] + pos - (state.bMarks[nextLine] + state.tShift[nextLine]); // skip one optional space after '>'

        if (state.src.charCodeAt(pos) === 0x20
        /* space */
        ) {
            // ' >   test '
            //     ^ -- position start of line here:
            pos++;
            initial++;
            offset++;
            adjustTab = false;
            spaceAfterMarker = true;
          } else if (state.src.charCodeAt(pos) === 0x09
        /* tab */
        ) {
            spaceAfterMarker = true;

            if ((state.bsCount[nextLine] + offset) % 4 === 3) {
              // '  >\t  test '
              //       ^ -- position start of line here (tab has width===1)
              pos++;
              initial++;
              offset++;
              adjustTab = false;
            } else {
              // ' >\t  test '
              //    ^ -- position start of line here + shift bsCount slightly
              //         to make extra space appear
              adjustTab = true;
            }
          } else {
          spaceAfterMarker = false;
        }

        oldBMarks.push(state.bMarks[nextLine]);
        state.bMarks[nextLine] = pos;

        while (pos < max) {
          ch = state.src.charCodeAt(pos);

          if (isSpace$2(ch)) {
            if (ch === 0x09) {
              offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
            } else {
              offset++;
            }
          } else {
            break;
          }

          pos++;
        }

        lastLineEmpty = pos >= max;
        oldBSCount.push(state.bsCount[nextLine]);
        state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);
        oldSCount.push(state.sCount[nextLine]);
        state.sCount[nextLine] = offset - initial;
        oldTShift.push(state.tShift[nextLine]);
        state.tShift[nextLine] = pos - state.bMarks[nextLine];
        continue;
      } // Case 2: line is not inside the blockquote, and the last line was empty.


      if (lastLineEmpty) {
        break;
      } // Case 3: another tag found.


      terminate = false;

      for (i = 0, l = terminatorRules.length; i < l; i++) {
        if (terminatorRules[i](state, nextLine, endLine, true)) {
          terminate = true;
          break;
        }
      }

      if (terminate) {
        // Quirk to enforce "hard termination mode" for paragraphs;
        // normally if you call `tokenize(state, startLine, nextLine)`,
        // paragraphs will look below nextLine for paragraph continuation,
        // but if blockquote is terminated by another tag, they shouldn't
        state.lineMax = nextLine;

        if (state.blkIndent !== 0) {
          // state.blkIndent was non-zero, we now set it to zero,
          // so we need to re-calculate all offsets to appear as
          // if indent wasn't changed
          oldBMarks.push(state.bMarks[nextLine]);
          oldBSCount.push(state.bsCount[nextLine]);
          oldTShift.push(state.tShift[nextLine]);
          oldSCount.push(state.sCount[nextLine]);
          state.sCount[nextLine] -= state.blkIndent;
        }

        break;
      }

      oldBMarks.push(state.bMarks[nextLine]);
      oldBSCount.push(state.bsCount[nextLine]);
      oldTShift.push(state.tShift[nextLine]);
      oldSCount.push(state.sCount[nextLine]); // A negative indentation means that this is a paragraph continuation
      //

      state.sCount[nextLine] = -1;
    }

    oldIndent = state.blkIndent;
    state.blkIndent = 0;
    token = state.push('blockquote_open', 'blockquote', 1);
    token.markup = '>';
    token.map = lines = [startLine, 0];
    state.md.block.tokenize(state, startLine, nextLine);
    token = state.push('blockquote_close', 'blockquote', -1);
    token.markup = '>';
    state.lineMax = oldLineMax;
    state.parentType = oldParentType;
    lines[1] = state.line; // Restore original tShift; this might not be necessary since the parser
    // has already been here, but just to make sure we can do that.

    for (i = 0; i < oldTShift.length; i++) {
      state.bMarks[i + startLine] = oldBMarks[i];
      state.tShift[i + startLine] = oldTShift[i];
      state.sCount[i + startLine] = oldSCount[i];
      state.bsCount[i + startLine] = oldBSCount[i];
    }

    state.blkIndent = oldIndent;
    return true;
  };

  var isSpace$3 = utils.isSpace;

  var hr = function hr(state, startLine, endLine, silent) {
    var marker,
        cnt,
        ch,
        token,
        pos = state.bMarks[startLine] + state.tShift[startLine],
        max = state.eMarks[startLine]; // if it's indented more than 3 spaces, it should be a code block

    if (state.sCount[startLine] - state.blkIndent >= 4) {
      return false;
    }

    marker = state.src.charCodeAt(pos++); // Check hr marker

    if (marker !== 0x2A
    /* * */
    && marker !== 0x2D
    /* - */
    && marker !== 0x5F
    /* _ */
    ) {
        return false;
      } // markers can be mixed with spaces, but there should be at least 3 of them


    cnt = 1;

    while (pos < max) {
      ch = state.src.charCodeAt(pos++);

      if (ch !== marker && !isSpace$3(ch)) {
        return false;
      }

      if (ch === marker) {
        cnt++;
      }
    }

    if (cnt < 3) {
      return false;
    }

    if (silent) {
      return true;
    }

    state.line = startLine + 1;
    token = state.push('hr', 'hr', 0);
    token.map = [startLine, state.line];
    token.markup = Array(cnt + 1).join(String.fromCharCode(marker));
    return true;
  };

  var isSpace$4 = utils.isSpace; // Search `[-+*][\n ]`, returns next pos after marker on success
  // or -1 on fail.

  function skipBulletListMarker(state, startLine) {
    var marker, pos, max, ch;
    pos = state.bMarks[startLine] + state.tShift[startLine];
    max = state.eMarks[startLine];
    marker = state.src.charCodeAt(pos++); // Check bullet

    if (marker !== 0x2A
    /* * */
    && marker !== 0x2D
    /* - */
    && marker !== 0x2B
    /* + */
    ) {
        return -1;
      }

    if (pos < max) {
      ch = state.src.charCodeAt(pos);

      if (!isSpace$4(ch)) {
        // " -test " - is not a list item
        return -1;
      }
    }

    return pos;
  } // Search `\d+[.)][\n ]`, returns next pos after marker on success
  // or -1 on fail.


  function skipOrderedListMarker(state, startLine) {
    var ch,
        start = state.bMarks[startLine] + state.tShift[startLine],
        pos = start,
        max = state.eMarks[startLine]; // List marker should have at least 2 chars (digit + dot)

    if (pos + 1 >= max) {
      return -1;
    }

    ch = state.src.charCodeAt(pos++);

    if (ch < 0x30
    /* 0 */
    || ch > 0x39
    /* 9 */
    ) {
        return -1;
      }

    for (;;) {
      // EOL -> fail
      if (pos >= max) {
        return -1;
      }

      ch = state.src.charCodeAt(pos++);

      if (ch >= 0x30
      /* 0 */
      && ch <= 0x39
      /* 9 */
      ) {
          // List marker should have no more than 9 digits
          // (prevents integer overflow in browsers)
          if (pos - start >= 10) {
            return -1;
          }

          continue;
        } // found valid marker


      if (ch === 0x29
      /* ) */
      || ch === 0x2e
      /* . */
      ) {
          break;
        }

      return -1;
    }

    if (pos < max) {
      ch = state.src.charCodeAt(pos);

      if (!isSpace$4(ch)) {
        // " 1.test " - is not a list item
        return -1;
      }
    }

    return pos;
  }

  function markTightParagraphs(state, idx) {
    var i,
        l,
        level = state.level + 2;

    for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
      if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {
        state.tokens[i + 2].hidden = true;
        state.tokens[i].hidden = true;
        i += 2;
      }
    }
  }

  var list = function list(state, startLine, endLine, silent) {
    var ch,
        contentStart,
        i,
        indent,
        indentAfterMarker,
        initial,
        isOrdered,
        itemLines,
        l,
        listLines,
        listTokIdx,
        markerCharCode,
        markerValue,
        max,
        nextLine,
        offset,
        oldIndent,
        oldLIndent,
        oldParentType,
        oldTShift,
        oldTight,
        pos,
        posAfterMarker,
        prevEmptyEnd,
        start,
        terminate,
        terminatorRules,
        token,
        isTerminatingParagraph = false,
        tight = true; // if it's indented more than 3 spaces, it should be a code block

    if (state.sCount[startLine] - state.blkIndent >= 4) {
      return false;
    } // limit conditions when list can interrupt
    // a paragraph (validation mode only)


    if (silent && state.parentType === 'paragraph') {
      // Next list item should still terminate previous list item;
      //
      // This code can fail if plugins use blkIndent as well as lists,
      // but I hope the spec gets fixed long before that happens.
      //
      if (state.tShift[startLine] >= state.blkIndent) {
        isTerminatingParagraph = true;
      }
    } // Detect list type and position after marker


    if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {
      isOrdered = true;
      start = state.bMarks[startLine] + state.tShift[startLine];
      markerValue = Number(state.src.substr(start, posAfterMarker - start - 1)); // If we're starting a new ordered list right after
      // a paragraph, it should start with 1.

      if (isTerminatingParagraph && markerValue !== 1) return false;
    } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {
      isOrdered = false;
    } else {
      return false;
    } // If we're starting a new unordered list right after
    // a paragraph, first line should not be empty.


    if (isTerminatingParagraph) {
      if (state.skipSpaces(posAfterMarker) >= state.eMarks[startLine]) return false;
    } // We should terminate list on style change. Remember first one to compare.


    markerCharCode = state.src.charCodeAt(posAfterMarker - 1); // For validation mode we can terminate immediately

    if (silent) {
      return true;
    } // Start list


    listTokIdx = state.tokens.length;

    if (isOrdered) {
      token = state.push('ordered_list_open', 'ol', 1);

      if (markerValue !== 1) {
        token.attrs = [['start', markerValue]];
      }
    } else {
      token = state.push('bullet_list_open', 'ul', 1);
    }

    token.map = listLines = [startLine, 0];
    token.markup = String.fromCharCode(markerCharCode); //
    // Iterate list items
    //

    nextLine = startLine;
    prevEmptyEnd = false;
    terminatorRules = state.md.block.ruler.getRules('list');
    oldParentType = state.parentType;
    state.parentType = 'list';

    while (nextLine < endLine) {
      pos = posAfterMarker;
      max = state.eMarks[nextLine];
      initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[startLine] + state.tShift[startLine]);

      while (pos < max) {
        ch = state.src.charCodeAt(pos);

        if (ch === 0x09) {
          offset += 4 - (offset + state.bsCount[nextLine]) % 4;
        } else if (ch === 0x20) {
          offset++;
        } else {
          break;
        }

        pos++;
      }

      contentStart = pos;

      if (contentStart >= max) {
        // trimming space in "-    \n  3" case, indent is 1 here
        indentAfterMarker = 1;
      } else {
        indentAfterMarker = offset - initial;
      } // If we have more than 4 spaces, the indent is 1
      // (the rest is just indented code block)


      if (indentAfterMarker > 4) {
        indentAfterMarker = 1;
      } // "  -  test"
      //  ^^^^^ - calculating total length of this thing


      indent = initial + indentAfterMarker; // Run subparser & write tokens

      token = state.push('list_item_open', 'li', 1);
      token.markup = String.fromCharCode(markerCharCode);
      token.map = itemLines = [startLine, 0];
      oldIndent = state.blkIndent;
      oldTight = state.tight;
      oldTShift = state.tShift[startLine];
      oldLIndent = state.sCount[startLine];
      state.blkIndent = indent;
      state.tight = true;
      state.tShift[startLine] = contentStart - state.bMarks[startLine];
      state.sCount[startLine] = offset;

      if (contentStart >= max && state.isEmpty(startLine + 1)) {
        // workaround for this case
        // (list item is empty, list terminates before "foo"):
        // ~~~~~~~~
        //   -
        //
        //     foo
        // ~~~~~~~~
        state.line = Math.min(state.line + 2, endLine);
      } else {
        state.md.block.tokenize(state, startLine, endLine, true);
      } // If any of list item is tight, mark list as tight


      if (!state.tight || prevEmptyEnd) {
        tight = false;
      } // Item become loose if finish with empty line,
      // but we should filter last element, because it means list finish


      prevEmptyEnd = state.line - startLine > 1 && state.isEmpty(state.line - 1);
      state.blkIndent = oldIndent;
      state.tShift[startLine] = oldTShift;
      state.sCount[startLine] = oldLIndent;
      state.tight = oldTight;
      token = state.push('list_item_close', 'li', -1);
      token.markup = String.fromCharCode(markerCharCode);
      nextLine = startLine = state.line;
      itemLines[1] = nextLine;
      contentStart = state.bMarks[startLine];

      if (nextLine >= endLine) {
        break;
      } //
      // Try to check if list is terminated or continued.
      //


      if (state.sCount[nextLine] < state.blkIndent) {
        break;
      } // fail if terminating block found


      terminate = false;

      for (i = 0, l = terminatorRules.length; i < l; i++) {
        if (terminatorRules[i](state, nextLine, endLine, true)) {
          terminate = true;
          break;
        }
      }

      if (terminate) {
        break;
      } // fail if list has another type


      if (isOrdered) {
        posAfterMarker = skipOrderedListMarker(state, nextLine);

        if (posAfterMarker < 0) {
          break;
        }
      } else {
        posAfterMarker = skipBulletListMarker(state, nextLine);

        if (posAfterMarker < 0) {
          break;
        }
      }

      if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {
        break;
      }
    } // Finalize list


    if (isOrdered) {
      token = state.push('ordered_list_close', 'ol', -1);
    } else {
      token = state.push('bullet_list_close', 'ul', -1);
    }

    token.markup = String.fromCharCode(markerCharCode);
    listLines[1] = nextLine;
    state.line = nextLine;
    state.parentType = oldParentType; // mark paragraphs tight if needed

    if (tight) {
      markTightParagraphs(state, listTokIdx);
    }

    return true;
  };

  var normalizeReference = utils.normalizeReference;
  var isSpace$5 = utils.isSpace;

  var reference = function reference(state, startLine, _endLine, silent) {
    var ch,
        destEndPos,
        destEndLineNo,
        endLine,
        href,
        i,
        l,
        label,
        labelEnd,
        oldParentType,
        res,
        start,
        str,
        terminate,
        terminatorRules,
        title,
        lines = 0,
        pos = state.bMarks[startLine] + state.tShift[startLine],
        max = state.eMarks[startLine],
        nextLine = startLine + 1; // if it's indented more than 3 spaces, it should be a code block

    if (state.sCount[startLine] - state.blkIndent >= 4) {
      return false;
    }

    if (state.src.charCodeAt(pos) !== 0x5B
    /* [ */
    ) {
        return false;
      } // Simple check to quickly interrupt scan on [link](url) at the start of line.
    // Can be useful on practice: https://github.com/markdown-it/markdown-it/issues/54


    while (++pos < max) {
      if (state.src.charCodeAt(pos) === 0x5D
      /* ] */
      && state.src.charCodeAt(pos - 1) !== 0x5C
      /* \ */
      ) {
          if (pos + 1 === max) {
            return false;
          }

          if (state.src.charCodeAt(pos + 1) !== 0x3A
          /* : */
          ) {
              return false;
            }

          break;
        }
    }

    endLine = state.lineMax; // jump line-by-line until empty one or EOF

    terminatorRules = state.md.block.ruler.getRules('reference');
    oldParentType = state.parentType;
    state.parentType = 'reference';

    for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
      // this would be a code block normally, but after paragraph
      // it's considered a lazy continuation regardless of what's there
      if (state.sCount[nextLine] - state.blkIndent > 3) {
        continue;
      } // quirk for blockquotes, this line should already be checked by that rule


      if (state.sCount[nextLine] < 0) {
        continue;
      } // Some tags can terminate paragraph without empty line.


      terminate = false;

      for (i = 0, l = terminatorRules.length; i < l; i++) {
        if (terminatorRules[i](state, nextLine, endLine, true)) {
          terminate = true;
          break;
        }
      }

      if (terminate) {
        break;
      }
    }

    str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
    max = str.length;

    for (pos = 1; pos < max; pos++) {
      ch = str.charCodeAt(pos);

      if (ch === 0x5B
      /* [ */
      ) {
          return false;
        } else if (ch === 0x5D
      /* ] */
      ) {
          labelEnd = pos;
          break;
        } else if (ch === 0x0A
      /* \n */
      ) {
          lines++;
        } else if (ch === 0x5C
      /* \ */
      ) {
          pos++;

          if (pos < max && str.charCodeAt(pos) === 0x0A) {
            lines++;
          }
        }
    }

    if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A
    /* : */
    ) {
        return false;
      } // [label]:   destination   'title'
    //         ^^^ skip optional whitespace here


    for (pos = labelEnd + 2; pos < max; pos++) {
      ch = str.charCodeAt(pos);

      if (ch === 0x0A) {
        lines++;
      } else if (isSpace$5(ch)) {
        /*eslint no-empty:0*/
      } else {
        break;
      }
    } // [label]:   destination   'title'
    //            ^^^^^^^^^^^ parse this


    res = state.md.helpers.parseLinkDestination(str, pos, max);

    if (!res.ok) {
      return false;
    }

    href = state.md.normalizeLink(res.str);

    if (!state.md.validateLink(href)) {
      return false;
    }

    pos = res.pos;
    lines += res.lines; // save cursor state, we could require to rollback later

    destEndPos = pos;
    destEndLineNo = lines; // [label]:   destination   'title'
    //                       ^^^ skipping those spaces

    start = pos;

    for (; pos < max; pos++) {
      ch = str.charCodeAt(pos);

      if (ch === 0x0A) {
        lines++;
      } else if (isSpace$5(ch)) {
        /*eslint no-empty:0*/
      } else {
        break;
      }
    } // [label]:   destination   'title'
    //                          ^^^^^^^ parse this


    res = state.md.helpers.parseLinkTitle(str, pos, max);

    if (pos < max && start !== pos && res.ok) {
      title = res.str;
      pos = res.pos;
      lines += res.lines;
    } else {
      title = '';
      pos = destEndPos;
      lines = destEndLineNo;
    } // skip trailing spaces until the rest of the line


    while (pos < max) {
      ch = str.charCodeAt(pos);

      if (!isSpace$5(ch)) {
        break;
      }

      pos++;
    }

    if (pos < max && str.charCodeAt(pos) !== 0x0A) {
      if (title) {
        // garbage at the end of the line after title,
        // but it could still be a valid reference if we roll back
        title = '';
        pos = destEndPos;
        lines = destEndLineNo;

        while (pos < max) {
          ch = str.charCodeAt(pos);

          if (!isSpace$5(ch)) {
            break;
          }

          pos++;
        }
      }
    }

    if (pos < max && str.charCodeAt(pos) !== 0x0A) {
      // garbage at the end of the line
      return false;
    }

    label = normalizeReference(str.slice(1, labelEnd));

    if (!label) {
      // CommonMark 0.20 disallows empty labels
      return false;
    } // Reference can not terminate anything. This check is for safety only.

    /*istanbul ignore if*/


    if (silent) {
      return true;
    }

    if (typeof state.env.references === 'undefined') {
      state.env.references = {};
    }

    if (typeof state.env.references[label] === 'undefined') {
      state.env.references[label] = {
        title: title,
        href: href
      };
    }

    state.parentType = oldParentType;
    state.line = startLine + lines + 1;
    return true;
  };

  var isSpace$6 = utils.isSpace;

  var heading = function heading(state, startLine, endLine, silent) {
    var ch,
        level,
        tmp,
        token,
        pos = state.bMarks[startLine] + state.tShift[startLine],
        max = state.eMarks[startLine]; // if it's indented more than 3 spaces, it should be a code block

    if (state.sCount[startLine] - state.blkIndent >= 4) {
      return false;
    }

    ch = state.src.charCodeAt(pos);

    if (ch !== 0x23
    /* # */
    || pos >= max) {
      return false;
    } // count heading level


    level = 1;
    ch = state.src.charCodeAt(++pos);

    while (ch === 0x23
    /* # */
    && pos < max && level <= 6) {
      level++;
      ch = state.src.charCodeAt(++pos);
    }

    if (level > 6 || pos < max && !isSpace$6(ch)) {
      return false;
    }

    if (silent) {
      return true;
    } // Let's cut tails like '    ###  ' from the end of string


    max = state.skipSpacesBack(max, pos);
    tmp = state.skipCharsBack(max, 0x23, pos); // #

    if (tmp > pos && isSpace$6(state.src.charCodeAt(tmp - 1))) {
      max = tmp;
    }

    state.line = startLine + 1;
    token = state.push('heading_open', 'h' + String(level), 1);
    token.markup = '########'.slice(0, level);
    token.map = [startLine, state.line];
    token = state.push('inline', '', 0);
    token.content = state.src.slice(pos, max).trim();
    token.map = [startLine, state.line];
    token.children = [];
    token = state.push('heading_close', 'h' + String(level), -1);
    token.markup = '########'.slice(0, level);
    return true;
  };

  // lheading (---, ===)

  var lheading = function lheading(state, startLine, endLine
  /*, silent*/
  ) {
    var content,
        terminate,
        i,
        l,
        token,
        pos,
        max,
        level,
        marker,
        nextLine = startLine + 1,
        oldParentType,
        terminatorRules = state.md.block.ruler.getRules('paragraph'); // if it's indented more than 3 spaces, it should be a code block

    if (state.sCount[startLine] - state.blkIndent >= 4) {
      return false;
    }

    oldParentType = state.parentType;
    state.parentType = 'paragraph'; // use paragraph to match terminatorRules
    // jump line-by-line until empty one or EOF

    for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
      // this would be a code block normally, but after paragraph
      // it's considered a lazy continuation regardless of what's there
      if (state.sCount[nextLine] - state.blkIndent > 3) {
        continue;
      } //
      // Check for underline in setext header
      //


      if (state.sCount[nextLine] >= state.blkIndent) {
        pos = state.bMarks[nextLine] + state.tShift[nextLine];
        max = state.eMarks[nextLine];

        if (pos < max) {
          marker = state.src.charCodeAt(pos);

          if (marker === 0x2D
          /* - */
          || marker === 0x3D
          /* = */
          ) {
              pos = state.skipChars(pos, marker);
              pos = state.skipSpaces(pos);

              if (pos >= max) {
                level = marker === 0x3D
                /* = */
                ? 1 : 2;
                break;
              }
            }
        }
      } // quirk for blockquotes, this line should already be checked by that rule


      if (state.sCount[nextLine] < 0) {
        continue;
      } // Some tags can terminate paragraph without empty line.


      terminate = false;

      for (i = 0, l = terminatorRules.length; i < l; i++) {
        if (terminatorRules[i](state, nextLine, endLine, true)) {
          terminate = true;
          break;
        }
      }

      if (terminate) {
        break;
      }
    }

    if (!level) {
      // Didn't find valid underline
      return false;
    }

    content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
    state.line = nextLine + 1;
    token = state.push('heading_open', 'h' + String(level), 1);
    token.markup = String.fromCharCode(marker);
    token.map = [startLine, state.line];
    token = state.push('inline', '', 0);
    token.content = content;
    token.map = [startLine, state.line - 1];
    token.children = [];
    token = state.push('heading_close', 'h' + String(level), -1);
    token.markup = String.fromCharCode(marker);
    state.parentType = oldParentType;
    return true;
  };

  // List of valid html blocks names, accorting to commonmark spec

  var html_blocks = ['address', 'article', 'aside', 'base', 'basefont', 'blockquote', 'body', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dialog', 'dir', 'div', 'dl', 'dt', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hr', 'html', 'iframe', 'legend', 'li', 'link', 'main', 'menu', 'menuitem', 'meta', 'nav', 'noframes', 'ol', 'optgroup', 'option', 'p', 'param', 'section', 'source', 'summary', 'table', 'tbody', 'td', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul'];

  // Regexps to match html elements

  var attr_name = '[a-zA-Z_:][a-zA-Z0-9:._-]*';
  var unquoted = '[^"\'=<>`\\x00-\\x20]+';
  var single_quoted = "'[^']*'";
  var double_quoted = '"[^"]*"';
  var attr_value = '(?:' + unquoted + '|' + single_quoted + '|' + double_quoted + ')';
  var attribute = '(?:\\s+' + attr_name + '(?:\\s*=\\s*' + attr_value + ')?)';
  var open_tag = '<[A-Za-z][A-Za-z0-9\\-]*' + attribute + '*\\s*\\/?>';
  var close_tag = '<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>';
  var comment = '<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->';
  var processing = '<[?].*?[?]>';
  var declaration = '<![A-Z]+\\s+[^>]*>';
  var cdata = '<!\\[CDATA\\[[\\s\\S]*?\\]\\]>';
  var HTML_TAG_RE = new RegExp('^(?:' + open_tag + '|' + close_tag + '|' + comment + '|' + processing + '|' + declaration + '|' + cdata + ')');
  var HTML_OPEN_CLOSE_TAG_RE = new RegExp('^(?:' + open_tag + '|' + close_tag + ')');
  var HTML_TAG_RE_1 = HTML_TAG_RE;
  var HTML_OPEN_CLOSE_TAG_RE_1 = HTML_OPEN_CLOSE_TAG_RE;
  var html_re = {
    HTML_TAG_RE: HTML_TAG_RE_1,
    HTML_OPEN_CLOSE_TAG_RE: HTML_OPEN_CLOSE_TAG_RE_1
  };

  var HTML_OPEN_CLOSE_TAG_RE$1 = html_re.HTML_OPEN_CLOSE_TAG_RE; // An array of opening and corresponding closing sequences for html tags,
  // last argument defines whether it can terminate a paragraph or not
  //

  var HTML_SEQUENCES = [[/^<(script|pre|style)(?=(\s|>|$))/i, /<\/(script|pre|style)>/i, true], [/^<!--/, /-->/, true], [/^<\?/, /\?>/, true], [/^<![A-Z]/, />/, true], [/^<!\[CDATA\[/, /\]\]>/, true], [new RegExp('^</?(' + html_blocks.join('|') + ')(?=(\\s|/?>|$))', 'i'), /^$/, true], [new RegExp(HTML_OPEN_CLOSE_TAG_RE$1.source + '\\s*$'), /^$/, false]];

  var html_block = function html_block(state, startLine, endLine, silent) {
    var i,
        nextLine,
        token,
        lineText,
        pos = state.bMarks[startLine] + state.tShift[startLine],
        max = state.eMarks[startLine]; // if it's indented more than 3 spaces, it should be a code block

    if (state.sCount[startLine] - state.blkIndent >= 4) {
      return false;
    }

    if (!state.md.options.html) {
      return false;
    }

    if (state.src.charCodeAt(pos) !== 0x3C
    /* < */
    ) {
        return false;
      }

    lineText = state.src.slice(pos, max);

    for (i = 0; i < HTML_SEQUENCES.length; i++) {
      if (HTML_SEQUENCES[i][0].test(lineText)) {
        break;
      }
    }

    if (i === HTML_SEQUENCES.length) {
      return false;
    }

    if (silent) {
      // true if this sequence can be a terminator, false otherwise
      return HTML_SEQUENCES[i][2];
    }

    nextLine = startLine + 1; // If we are here - we detected HTML block.
    // Let's roll down till block end.

    if (!HTML_SEQUENCES[i][1].test(lineText)) {
      for (; nextLine < endLine; nextLine++) {
        if (state.sCount[nextLine] < state.blkIndent) {
          break;
        }

        pos = state.bMarks[nextLine] + state.tShift[nextLine];
        max = state.eMarks[nextLine];
        lineText = state.src.slice(pos, max);

        if (HTML_SEQUENCES[i][1].test(lineText)) {
          if (lineText.length !== 0) {
            nextLine++;
          }

          break;
        }
      }
    }

    state.line = nextLine;
    token = state.push('html_block', '', 0);
    token.map = [startLine, nextLine];
    token.content = state.getLines(startLine, nextLine, state.blkIndent, true);
    return true;
  };

  // Paragraph

  var paragraph = function paragraph(state, startLine
  /*, endLine*/
  ) {
    var content,
        terminate,
        i,
        l,
        token,
        oldParentType,
        nextLine = startLine + 1,
        terminatorRules = state.md.block.ruler.getRules('paragraph'),
        endLine = state.lineMax;
    oldParentType = state.parentType;
    state.parentType = 'paragraph'; // jump line-by-line until empty one or EOF

    for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
      // this would be a code block normally, but after paragraph
      // it's considered a lazy continuation regardless of what's there
      if (state.sCount[nextLine] - state.blkIndent > 3) {
        continue;
      } // quirk for blockquotes, this line should already be checked by that rule


      if (state.sCount[nextLine] < 0) {
        continue;
      } // Some tags can terminate paragraph without empty line.


      terminate = false;

      for (i = 0, l = terminatorRules.length; i < l; i++) {
        if (terminatorRules[i](state, nextLine, endLine, true)) {
          terminate = true;
          break;
        }
      }

      if (terminate) {
        break;
      }
    }

    content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
    state.line = nextLine;
    token = state.push('paragraph_open', 'p', 1);
    token.map = [startLine, state.line];
    token = state.push('inline', '', 0);
    token.content = content;
    token.map = [startLine, state.line];
    token.children = [];
    token = state.push('paragraph_close', 'p', -1);
    state.parentType = oldParentType;
    return true;
  };

  var isSpace$7 = utils.isSpace;

  function StateBlock(src, md, env, tokens) {
    var ch, s, start, pos, len, indent, offset, indent_found;
    this.src = src; // link to parser instance

    this.md = md;
    this.env = env; //
    // Internal state vartiables
    //

    this.tokens = tokens;
    this.bMarks = []; // line begin offsets for fast jumps

    this.eMarks = []; // line end offsets for fast jumps

    this.tShift = []; // offsets of the first non-space characters (tabs not expanded)

    this.sCount = []; // indents for each line (tabs expanded)
    // An amount of virtual spaces (tabs expanded) between beginning
    // of each line (bMarks) and real beginning of that line.
    //
    // It exists only as a hack because blockquotes override bMarks
    // losing information in the process.
    //
    // It's used only when expanding tabs, you can think about it as
    // an initial tab length, e.g. bsCount=21 applied to string `\t123`
    // means first tab should be expanded to 4-21%4 === 3 spaces.
    //

    this.bsCount = []; // block parser variables

    this.blkIndent = 0; // required block content indent
    // (for example, if we are in list)

    this.line = 0; // line index in src

    this.lineMax = 0; // lines count

    this.tight = false; // loose/tight mode for lists

    this.ddIndent = -1; // indent of the current dd block (-1 if there isn't any)
    // can be 'blockquote', 'list', 'root', 'paragraph' or 'reference'
    // used in lists to determine if they interrupt a paragraph

    this.parentType = 'root';
    this.level = 0; // renderer

    this.result = ''; // Create caches
    // Generate markers.

    s = this.src;
    indent_found = false;

    for (start = pos = indent = offset = 0, len = s.length; pos < len; pos++) {
      ch = s.charCodeAt(pos);

      if (!indent_found) {
        if (isSpace$7(ch)) {
          indent++;

          if (ch === 0x09) {
            offset += 4 - offset % 4;
          } else {
            offset++;
          }

          continue;
        } else {
          indent_found = true;
        }
      }

      if (ch === 0x0A || pos === len - 1) {
        if (ch !== 0x0A) {
          pos++;
        }

        this.bMarks.push(start);
        this.eMarks.push(pos);
        this.tShift.push(indent);
        this.sCount.push(offset);
        this.bsCount.push(0);
        indent_found = false;
        indent = 0;
        offset = 0;
        start = pos + 1;
      }
    } // Push fake entry to simplify cache bounds checks


    this.bMarks.push(s.length);
    this.eMarks.push(s.length);
    this.tShift.push(0);
    this.sCount.push(0);
    this.bsCount.push(0);
    this.lineMax = this.bMarks.length - 1; // don't count last fake line
  } // Push new token to "stream".
  //


  StateBlock.prototype.push = function (type, tag, nesting) {
    var token$$1 = new token(type, tag, nesting);
    token$$1.block = true;

    if (nesting < 0) {
      this.level--;
    }

    token$$1.level = this.level;

    if (nesting > 0) {
      this.level++;
    }

    this.tokens.push(token$$1);
    return token$$1;
  };

  StateBlock.prototype.isEmpty = function isEmpty(line) {
    return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
  };

  StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
    for (var max = this.lineMax; from < max; from++) {
      if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
        break;
      }
    }

    return from;
  }; // Skip spaces from given position.


  StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
    var ch;

    for (var max = this.src.length; pos < max; pos++) {
      ch = this.src.charCodeAt(pos);

      if (!isSpace$7(ch)) {
        break;
      }
    }

    return pos;
  }; // Skip spaces from given position in reverse.


  StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {
    if (pos <= min) {
      return pos;
    }

    while (pos > min) {
      if (!isSpace$7(this.src.charCodeAt(--pos))) {
        return pos + 1;
      }
    }

    return pos;
  }; // Skip char codes from given position


  StateBlock.prototype.skipChars = function skipChars(pos, code) {
    for (var max = this.src.length; pos < max; pos++) {
      if (this.src.charCodeAt(pos) !== code) {
        break;
      }
    }

    return pos;
  }; // Skip char codes reverse from given position - 1


  StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {
    if (pos <= min) {
      return pos;
    }

    while (pos > min) {
      if (code !== this.src.charCodeAt(--pos)) {
        return pos + 1;
      }
    }

    return pos;
  }; // cut lines range from source.


  StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {
    var i,
        lineIndent,
        ch,
        first,
        last,
        queue,
        lineStart,
        line = begin;

    if (begin >= end) {
      return '';
    }

    queue = new Array(end - begin);

    for (i = 0; line < end; line++, i++) {
      lineIndent = 0;
      lineStart = first = this.bMarks[line];

      if (line + 1 < end || keepLastLF) {
        // No need for bounds check because we have fake entry on tail.
        last = this.eMarks[line] + 1;
      } else {
        last = this.eMarks[line];
      }

      while (first < last && lineIndent < indent) {
        ch = this.src.charCodeAt(first);

        if (isSpace$7(ch)) {
          if (ch === 0x09) {
            lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
          } else {
            lineIndent++;
          }
        } else if (first - lineStart < this.tShift[line]) {
          // patched tShift masked characters to look like spaces (blockquotes, list markers)
          lineIndent++;
        } else {
          break;
        }

        first++;
      }

      if (lineIndent > indent) {
        // partially expanding tabs in code blocks, e.g '\t\tfoobar'
        // with indent=2 becomes '  \tfoobar'
        queue[i] = new Array(lineIndent - indent + 1).join(' ') + this.src.slice(first, last);
      } else {
        queue[i] = this.src.slice(first, last);
      }
    }

    return queue.join('');
  }; // re-export Token class to use in block rules


  StateBlock.prototype.Token = token;
  var state_block = StateBlock;

  var _rules$1 = [// First 2 params - rule name & source. Secondary array - list of rules,
  // which can be terminated by this one.
  ['table', table, ['paragraph', 'reference']], ['code', code], ['fence', fence, ['paragraph', 'reference', 'blockquote', 'list']], ['blockquote', blockquote, ['paragraph', 'reference', 'blockquote', 'list']], ['hr', hr, ['paragraph', 'reference', 'blockquote', 'list']], ['list', list, ['paragraph', 'reference', 'blockquote']], ['reference', reference], ['heading', heading, ['paragraph', 'reference', 'blockquote']], ['lheading', lheading], ['html_block', html_block, ['paragraph', 'reference', 'blockquote']], ['paragraph', paragraph]];
  /**
   * new ParserBlock()
   **/

  function ParserBlock() {
    /**
     * ParserBlock#ruler -> Ruler
     *
     * [[Ruler]] instance. Keep configuration of block rules.
     **/
    this.ruler = new ruler();

    for (var i = 0; i < _rules$1.length; i++) {
      this.ruler.push(_rules$1[i][0], _rules$1[i][1], {
        alt: (_rules$1[i][2] || []).slice()
      });
    }
  } // Generate tokens for input range
  //


  ParserBlock.prototype.tokenize = function (state, startLine, endLine) {
    var ok,
        i,
        rules = this.ruler.getRules(''),
        len = rules.length,
        line = startLine,
        hasEmptyLines = false,
        maxNesting = state.md.options.maxNesting;

    while (line < endLine) {
      state.line = line = state.skipEmptyLines(line);

      if (line >= endLine) {
        break;
      } // Termination condition for nested calls.
      // Nested calls currently used for blockquotes & lists


      if (state.sCount[line] < state.blkIndent) {
        break;
      } // If nesting level exceeded - skip tail to the end. That's not ordinary
      // situation and we should not care about content.


      if (state.level >= maxNesting) {
        state.line = endLine;
        break;
      } // Try all possible rules.
      // On success, rule should:
      //
      // - update `state.line`
      // - update `state.tokens`
      // - return true


      for (i = 0; i < len; i++) {
        ok = rules[i](state, line, endLine, false);

        if (ok) {
          break;
        }
      } // set state.tight if we had an empty line before current tag
      // i.e. latest empty line should not count


      state.tight = !hasEmptyLines; // paragraph might "eat" one newline after it in nested lists

      if (state.isEmpty(state.line - 1)) {
        hasEmptyLines = true;
      }

      line = state.line;

      if (line < endLine && state.isEmpty(line)) {
        hasEmptyLines = true;
        line++;
        state.line = line;
      }
    }
  };
  /**
   * ParserBlock.parse(str, md, env, outTokens)
   *
   * Process input string and push block tokens into `outTokens`
   **/


  ParserBlock.prototype.parse = function (src, md, env, outTokens) {
    var state;

    if (!src) {
      return;
    }

    state = new this.State(src, md, env, outTokens);
    this.tokenize(state, state.line, state.lineMax);
  };

  ParserBlock.prototype.State = state_block;
  var parser_block = ParserBlock;

  // Skip text characters for text token, place those to pending buffer
  // '{}$%@~+=:' reserved for extentions
  // !, ", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \, ], ^, _, `, {, |, }, or ~
  // !!!! Don't confuse with "Markdown ASCII Punctuation" chars
  // http://spec.commonmark.org/0.15/#ascii-punctuation-character

  function isTerminatorChar(ch) {
    switch (ch) {
      case 0x0A
      /* \n */
      :
      case 0x21
      /* ! */
      :
      case 0x23
      /* # */
      :
      case 0x24
      /* $ */
      :
      case 0x25
      /* % */
      :
      case 0x26
      /* & */
      :
      case 0x2A
      /* * */
      :
      case 0x2B
      /* + */
      :
      case 0x2D
      /* - */
      :
      case 0x3A
      /* : */
      :
      case 0x3C
      /* < */
      :
      case 0x3D
      /* = */
      :
      case 0x3E
      /* > */
      :
      case 0x40
      /* @ */
      :
      case 0x5B
      /* [ */
      :
      case 0x5C
      /* \ */
      :
      case 0x5D
      /* ] */
      :
      case 0x5E
      /* ^ */
      :
      case 0x5F
      /* _ */
      :
      case 0x60
      /* ` */
      :
      case 0x7B
      /* { */
      :
      case 0x7D
      /* } */
      :
      case 0x7E
      /* ~ */
      :
        return true;

      default:
        return false;
    }
  }

  var text = function text(state, silent) {
    var pos = state.pos;

    while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
      pos++;
    }

    if (pos === state.pos) {
      return false;
    }

    if (!silent) {
      state.pending += state.src.slice(state.pos, pos);
    }

    state.pos = pos;
    return true;
  }; // Alternative implementation, for memory.

  var isSpace$8 = utils.isSpace;

  var newline = function newline(state, silent) {
    var pmax,
        max,
        pos = state.pos;

    if (state.src.charCodeAt(pos) !== 0x0A
    /* \n */
    ) {
        return false;
      }

    pmax = state.pending.length - 1;
    max = state.posMax; // '  \n' -> hardbreak
    // Lookup in pending chars is bad practice! Don't copy to other rules!
    // Pending string is stored in concat mode, indexed lookups will cause
    // convertion to flat mode.

    if (!silent) {
      if (pmax >= 0 && state.pending.charCodeAt(pmax) === 0x20) {
        if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 0x20) {
          state.pending = state.pending.replace(/ +$/, '');
          state.push('hardbreak', 'br', 0);
        } else {
          state.pending = state.pending.slice(0, -1);
          state.push('softbreak', 'br', 0);
        }
      } else {
        state.push('softbreak', 'br', 0);
      }
    }

    pos++; // skip heading spaces for next line

    while (pos < max && isSpace$8(state.src.charCodeAt(pos))) {
      pos++;
    }

    state.pos = pos;
    return true;
  };

  var isSpace$9 = utils.isSpace;
  var ESCAPED = [];

  for (var i$1 = 0; i$1 < 256; i$1++) {
    ESCAPED.push(0);
  }

  '\\!"#$%&\'()*+,./:;<=>?@[]^_`{|}~-'.split('').forEach(function (ch) {
    ESCAPED[ch.charCodeAt(0)] = 1;
  });

  var _escape = function escape(state, silent) {
    var ch,
        pos = state.pos,
        max = state.posMax;

    if (state.src.charCodeAt(pos) !== 0x5C
    /* \ */
    ) {
        return false;
      }

    pos++;

    if (pos < max) {
      ch = state.src.charCodeAt(pos);

      if (ch < 256 && ESCAPED[ch] !== 0) {
        if (!silent) {
          state.pending += state.src[pos];
        }

        state.pos += 2;
        return true;
      }

      if (ch === 0x0A) {
        if (!silent) {
          state.push('hardbreak', 'br', 0);
        }

        pos++; // skip leading whitespaces from next line

        while (pos < max) {
          ch = state.src.charCodeAt(pos);

          if (!isSpace$9(ch)) {
            break;
          }

          pos++;
        }

        state.pos = pos;
        return true;
      }
    }

    if (!silent) {
      state.pending += '\\';
    }

    state.pos++;
    return true;
  };

  // Parse backticks

  var backticks = function backtick(state, silent) {
    var start,
        max,
        marker,
        matchStart,
        matchEnd,
        token,
        pos = state.pos,
        ch = state.src.charCodeAt(pos);

    if (ch !== 0x60
    /* ` */
    ) {
        return false;
      }

    start = pos;
    pos++;
    max = state.posMax;

    while (pos < max && state.src.charCodeAt(pos) === 0x60
    /* ` */
    ) {
      pos++;
    }

    marker = state.src.slice(start, pos);
    matchStart = matchEnd = pos;

    while ((matchStart = state.src.indexOf('`', matchEnd)) !== -1) {
      matchEnd = matchStart + 1;

      while (matchEnd < max && state.src.charCodeAt(matchEnd) === 0x60
      /* ` */
      ) {
        matchEnd++;
      }

      if (matchEnd - matchStart === marker.length) {
        if (!silent) {
          token = state.push('code_inline', 'code', 0);
          token.markup = marker;
          token.content = state.src.slice(pos, matchStart).replace(/[ \n]+/g, ' ').trim();
        }

        state.pos = matchEnd;
        return true;
      }
    }

    if (!silent) {
      state.pending += marker;
    }

    state.pos += marker.length;
    return true;
  };

  // ~~strike through~~
  //

  var tokenize = function strikethrough(state, silent) {
    var i,
        scanned,
        token,
        len,
        ch,
        start = state.pos,
        marker = state.src.charCodeAt(start);

    if (silent) {
      return false;
    }

    if (marker !== 0x7E
    /* ~ */
    ) {
        return false;
      }

    scanned = state.scanDelims(state.pos, true);
    len = scanned.length;
    ch = String.fromCharCode(marker);

    if (len < 2) {
      return false;
    }

    if (len % 2) {
      token = state.push('text', '', 0);
      token.content = ch;
      len--;
    }

    for (i = 0; i < len; i += 2) {
      token = state.push('text', '', 0);
      token.content = ch + ch;
      state.delimiters.push({
        marker: marker,
        jump: i,
        token: state.tokens.length - 1,
        level: state.level,
        end: -1,
        open: scanned.can_open,
        close: scanned.can_close
      });
    }

    state.pos += scanned.length;
    return true;
  }; // Walk through delimiter list and replace text tokens with tags
  //


  var postProcess = function strikethrough(state) {
    var i,
        j,
        startDelim,
        endDelim,
        token,
        loneMarkers = [],
        delimiters = state.delimiters,
        max = state.delimiters.length;

    for (i = 0; i < max; i++) {
      startDelim = delimiters[i];

      if (startDelim.marker !== 0x7E
      /* ~ */
      ) {
          continue;
        }

      if (startDelim.end === -1) {
        continue;
      }

      endDelim = delimiters[startDelim.end];
      token = state.tokens[startDelim.token];
      token.type = 's_open';
      token.tag = 's';
      token.nesting = 1;
      token.markup = '~~';
      token.content = '';
      token = state.tokens[endDelim.token];
      token.type = 's_close';
      token.tag = 's';
      token.nesting = -1;
      token.markup = '~~';
      token.content = '';

      if (state.tokens[endDelim.token - 1].type === 'text' && state.tokens[endDelim.token - 1].content === '~') {
        loneMarkers.push(endDelim.token - 1);
      }
    } // If a marker sequence has an odd number of characters, it's splitted
    // like this: `~~~~~` -> `~` + `~~` + `~~`, leaving one marker at the
    // start of the sequence.
    //
    // So, we have to move all those markers after subsequent s_close tags.
    //


    while (loneMarkers.length) {
      i = loneMarkers.pop();
      j = i + 1;

      while (j < state.tokens.length && state.tokens[j].type === 's_close') {
        j++;
      }

      j--;

      if (i !== j) {
        token = state.tokens[j];
        state.tokens[j] = state.tokens[i];
        state.tokens[i] = token;
      }
    }
  };

  var strikethrough = {
    tokenize: tokenize,
    postProcess: postProcess
  };

  // Process *this* and _that_
  //

  var tokenize$1 = function emphasis(state, silent) {
    var i,
        scanned,
        token,
        start = state.pos,
        marker = state.src.charCodeAt(start);

    if (silent) {
      return false;
    }

    if (marker !== 0x5F
    /* _ */
    && marker !== 0x2A
    /* * */
    ) {
        return false;
      }

    scanned = state.scanDelims(state.pos, marker === 0x2A);

    for (i = 0; i < scanned.length; i++) {
      token = state.push('text', '', 0);
      token.content = String.fromCharCode(marker);
      state.delimiters.push({
        // Char code of the starting marker (number).
        //
        marker: marker,
        // Total length of these series of delimiters.
        //
        length: scanned.length,
        // An amount of characters before this one that's equivalent to
        // current one. In plain English: if this delimiter does not open
        // an emphasis, neither do previous `jump` characters.
        //
        // Used to skip sequences like "*****" in one step, for 1st asterisk
        // value will be 0, for 2nd it's 1 and so on.
        //
        jump: i,
        // A position of the token this delimiter corresponds to.
        //
        token: state.tokens.length - 1,
        // Token level.
        //
        level: state.level,
        // If this delimiter is matched as a valid opener, `end` will be
        // equal to its position, otherwise it's `-1`.
        //
        end: -1,
        // Boolean flags that determine if this delimiter could open or close
        // an emphasis.
        //
        open: scanned.can_open,
        close: scanned.can_close
      });
    }

    state.pos += scanned.length;
    return true;
  }; // Walk through delimiter list and replace text tokens with tags
  //


  var postProcess$1 = function emphasis(state) {
    var i,
        startDelim,
        endDelim,
        token,
        ch,
        isStrong,
        delimiters = state.delimiters,
        max = state.delimiters.length;

    for (i = max - 1; i >= 0; i--) {
      startDelim = delimiters[i];

      if (startDelim.marker !== 0x5F
      /* _ */
      && startDelim.marker !== 0x2A
      /* * */
      ) {
          continue;
        } // Process only opening markers


      if (startDelim.end === -1) {
        continue;
      }

      endDelim = delimiters[startDelim.end]; // If the previous delimiter has the same marker and is adjacent to this one,
      // merge those into one strong delimiter.
      //
      // `<em><em>whatever</em></em>` -> `<strong>whatever</strong>`
      //

      isStrong = i > 0 && delimiters[i - 1].end === startDelim.end + 1 && delimiters[i - 1].token === startDelim.token - 1 && delimiters[startDelim.end + 1].token === endDelim.token + 1 && delimiters[i - 1].marker === startDelim.marker;
      ch = String.fromCharCode(startDelim.marker);
      token = state.tokens[startDelim.token];
      token.type = isStrong ? 'strong_open' : 'em_open';
      token.tag = isStrong ? 'strong' : 'em';
      token.nesting = 1;
      token.markup = isStrong ? ch + ch : ch;
      token.content = '';
      token = state.tokens[endDelim.token];
      token.type = isStrong ? 'strong_close' : 'em_close';
      token.tag = isStrong ? 'strong' : 'em';
      token.nesting = -1;
      token.markup = isStrong ? ch + ch : ch;
      token.content = '';

      if (isStrong) {
        state.tokens[delimiters[i - 1].token].content = '';
        state.tokens[delimiters[startDelim.end + 1].token].content = '';
        i--;
      }
    }
  };

  var emphasis = {
    tokenize: tokenize$1,
    postProcess: postProcess$1
  };

  var normalizeReference$1 = utils.normalizeReference;
  var isSpace$10 = utils.isSpace;

  var link = function link(state, silent) {
    var attrs,
        code,
        label,
        labelEnd,
        labelStart,
        pos,
        res,
        ref,
        title,
        token,
        href = '',
        oldPos = state.pos,
        max = state.posMax,
        start = state.pos,
        parseReference = true;

    if (state.src.charCodeAt(state.pos) !== 0x5B
    /* [ */
    ) {
        return false;
      }

    labelStart = state.pos + 1;
    labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true); // parser failed to find ']', so it's not a valid link

    if (labelEnd < 0) {
      return false;
    }

    pos = labelEnd + 1;

    if (pos < max && state.src.charCodeAt(pos) === 0x28
    /* ( */
    ) {
        //
        // Inline link
        //
        // might have found a valid shortcut link, disable reference parsing
        parseReference = false; // [link](  <href>  "title"  )
        //        ^^ skipping these spaces

        pos++;

        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);

          if (!isSpace$10(code) && code !== 0x0A) {
            break;
          }
        }

        if (pos >= max) {
          return false;
        } // [link](  <href>  "title"  )
        //          ^^^^^^ parsing link destination


        start = pos;
        res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);

        if (res.ok) {
          href = state.md.normalizeLink(res.str);

          if (state.md.validateLink(href)) {
            pos = res.pos;
          } else {
            href = '';
          }
        } // [link](  <href>  "title"  )
        //                ^^ skipping these spaces


        start = pos;

        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);

          if (!isSpace$10(code) && code !== 0x0A) {
            break;
          }
        } // [link](  <href>  "title"  )
        //                  ^^^^^^^ parsing link title


        res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);

        if (pos < max && start !== pos && res.ok) {
          title = res.str;
          pos = res.pos; // [link](  <href>  "title"  )
          //                         ^^ skipping these spaces

          for (; pos < max; pos++) {
            code = state.src.charCodeAt(pos);

            if (!isSpace$10(code) && code !== 0x0A) {
              break;
            }
          }
        } else {
          title = '';
        }

        if (pos >= max || state.src.charCodeAt(pos) !== 0x29
        /* ) */
        ) {
            // parsing a valid shortcut link failed, fallback to reference
            parseReference = true;
          }

        pos++;
      }

    if (parseReference) {
      //
      // Link reference
      //
      if (typeof state.env.references === 'undefined') {
        return false;
      }

      if (pos < max && state.src.charCodeAt(pos) === 0x5B
      /* [ */
      ) {
          start = pos + 1;
          pos = state.md.helpers.parseLinkLabel(state, pos);

          if (pos >= 0) {
            label = state.src.slice(start, pos++);
          } else {
            pos = labelEnd + 1;
          }
        } else {
        pos = labelEnd + 1;
      } // covers label === '' and label === undefined
      // (collapsed reference link and shortcut reference link respectively)


      if (!label) {
        label = state.src.slice(labelStart, labelEnd);
      }

      ref = state.env.references[normalizeReference$1(label)];

      if (!ref) {
        state.pos = oldPos;
        return false;
      }

      href = ref.href;
      title = ref.title;
    } //
    // We found the end of the link, and know for a fact it's a valid link;
    // so all that's left to do is to call tokenizer.
    //


    if (!silent) {
      state.pos = labelStart;
      state.posMax = labelEnd;
      token = state.push('link_open', 'a', 1);
      token.attrs = attrs = [['href', href]];

      if (title) {
        attrs.push(['title', title]);
      }

      state.md.inline.tokenize(state);
      token = state.push('link_close', 'a', -1);
    }

    state.pos = pos;
    state.posMax = max;
    return true;
  };

  var normalizeReference$2 = utils.normalizeReference;
  var isSpace$11 = utils.isSpace;

  var image$1 = function image(state, silent) {
    var attrs,
        code,
        content,
        label,
        labelEnd,
        labelStart,
        pos,
        ref,
        res,
        title,
        token,
        tokens,
        start,
        href = '',
        oldPos = state.pos,
        max = state.posMax;

    if (state.src.charCodeAt(state.pos) !== 0x21
    /* ! */
    ) {
        return false;
      }

    if (state.src.charCodeAt(state.pos + 1) !== 0x5B
    /* [ */
    ) {
        return false;
      }

    labelStart = state.pos + 2;
    labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false); // parser failed to find ']', so it's not a valid link

    if (labelEnd < 0) {
      return false;
    }

    pos = labelEnd + 1;

    if (pos < max && state.src.charCodeAt(pos) === 0x28
    /* ( */
    ) {
        //
        // Inline link
        //
        // [link](  <href>  "title"  )
        //        ^^ skipping these spaces
        pos++;

        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);

          if (!isSpace$11(code) && code !== 0x0A) {
            break;
          }
        }

        if (pos >= max) {
          return false;
        } // [link](  <href>  "title"  )
        //          ^^^^^^ parsing link destination


        start = pos;
        res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);

        if (res.ok) {
          href = state.md.normalizeLink(res.str);

          if (state.md.validateLink(href)) {
            pos = res.pos;
          } else {
            href = '';
          }
        } // [link](  <href>  "title"  )
        //                ^^ skipping these spaces


        start = pos;

        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);

          if (!isSpace$11(code) && code !== 0x0A) {
            break;
          }
        } // [link](  <href>  "title"  )
        //                  ^^^^^^^ parsing link title


        res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);

        if (pos < max && start !== pos && res.ok) {
          title = res.str;
          pos = res.pos; // [link](  <href>  "title"  )
          //                         ^^ skipping these spaces

          for (; pos < max; pos++) {
            code = state.src.charCodeAt(pos);

            if (!isSpace$11(code) && code !== 0x0A) {
              break;
            }
          }
        } else {
          title = '';
        }

        if (pos >= max || state.src.charCodeAt(pos) !== 0x29
        /* ) */
        ) {
            state.pos = oldPos;
            return false;
          }

        pos++;
      } else {
      //
      // Link reference
      //
      if (typeof state.env.references === 'undefined') {
        return false;
      }

      if (pos < max && state.src.charCodeAt(pos) === 0x5B
      /* [ */
      ) {
          start = pos + 1;
          pos = state.md.helpers.parseLinkLabel(state, pos);

          if (pos >= 0) {
            label = state.src.slice(start, pos++);
          } else {
            pos = labelEnd + 1;
          }
        } else {
        pos = labelEnd + 1;
      } // covers label === '' and label === undefined
      // (collapsed reference link and shortcut reference link respectively)


      if (!label) {
        label = state.src.slice(labelStart, labelEnd);
      }

      ref = state.env.references[normalizeReference$2(label)];

      if (!ref) {
        state.pos = oldPos;
        return false;
      }

      href = ref.href;
      title = ref.title;
    } //
    // We found the end of the link, and know for a fact it's a valid link;
    // so all that's left to do is to call tokenizer.
    //


    if (!silent) {
      content = state.src.slice(labelStart, labelEnd);
      state.md.inline.parse(content, state.md, state.env, tokens = []);
      token = state.push('image', 'img', 0);
      token.attrs = attrs = [['src', href], ['alt', '']];
      token.children = tokens;
      token.content = content;

      if (title) {
        attrs.push(['title', title]);
      }
    }

    state.pos = pos;
    state.posMax = max;
    return true;
  };

  // Process autolinks '<protocol:...>'
  var EMAIL_RE = /^<([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/;
  var AUTOLINK_RE = /^<([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)>/;

  var autolink = function autolink(state, silent) {
    var tail,
        linkMatch,
        emailMatch,
        url,
        fullUrl,
        token,
        pos = state.pos;

    if (state.src.charCodeAt(pos) !== 0x3C
    /* < */
    ) {
        return false;
      }

    tail = state.src.slice(pos);

    if (tail.indexOf('>') < 0) {
      return false;
    }

    if (AUTOLINK_RE.test(tail)) {
      linkMatch = tail.match(AUTOLINK_RE);
      url = linkMatch[0].slice(1, -1);
      fullUrl = state.md.normalizeLink(url);

      if (!state.md.validateLink(fullUrl)) {
        return false;
      }

      if (!silent) {
        token = state.push('link_open', 'a', 1);
        token.attrs = [['href', fullUrl]];
        token.markup = 'autolink';
        token.info = 'auto';
        token = state.push('text', '', 0);
        token.content = state.md.normalizeLinkText(url);
        token = state.push('link_close', 'a', -1);
        token.markup = 'autolink';
        token.info = 'auto';
      }

      state.pos += linkMatch[0].length;
      return true;
    }

    if (EMAIL_RE.test(tail)) {
      emailMatch = tail.match(EMAIL_RE);
      url = emailMatch[0].slice(1, -1);
      fullUrl = state.md.normalizeLink('mailto:' + url);

      if (!state.md.validateLink(fullUrl)) {
        return false;
      }

      if (!silent) {
        token = state.push('link_open', 'a', 1);
        token.attrs = [['href', fullUrl]];
        token.markup = 'autolink';
        token.info = 'auto';
        token = state.push('text', '', 0);
        token.content = state.md.normalizeLinkText(url);
        token = state.push('link_close', 'a', -1);
        token.markup = 'autolink';
        token.info = 'auto';
      }

      state.pos += emailMatch[0].length;
      return true;
    }

    return false;
  };

  var HTML_TAG_RE$1 = html_re.HTML_TAG_RE;

  function isLetter(ch) {
    /*eslint no-bitwise:0*/
    var lc = ch | 0x20; // to lower case

    return lc >= 0x61
    /* a */
    && lc <= 0x7a
    /* z */
    ;
  }

  var html_inline = function html_inline(state, silent) {
    var ch,
        match,
        max,
        token,
        pos = state.pos;

    if (!state.md.options.html) {
      return false;
    } // Check start


    max = state.posMax;

    if (state.src.charCodeAt(pos) !== 0x3C
    /* < */
    || pos + 2 >= max) {
      return false;
    } // Quick fail on second char


    ch = state.src.charCodeAt(pos + 1);

    if (ch !== 0x21
    /* ! */
    && ch !== 0x3F
    /* ? */
    && ch !== 0x2F
    /* / */
    && !isLetter(ch)) {
      return false;
    }

    match = state.src.slice(pos).match(HTML_TAG_RE$1);

    if (!match) {
      return false;
    }

    if (!silent) {
      token = state.push('html_inline', '', 0);
      token.content = state.src.slice(pos, pos + match[0].length);
    }

    state.pos += match[0].length;
    return true;
  };

  var has = utils.has;
  var isValidEntityCode = utils.isValidEntityCode;
  var fromCodePoint = utils.fromCodePoint;
  var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,8}|[0-9]{1,8}));/i;
  var NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;

  var entity = function entity(state, silent) {
    var ch,
        code,
        match,
        pos = state.pos,
        max = state.posMax;

    if (state.src.charCodeAt(pos) !== 0x26
    /* & */
    ) {
        return false;
      }

    if (pos + 1 < max) {
      ch = state.src.charCodeAt(pos + 1);

      if (ch === 0x23
      /* # */
      ) {
          match = state.src.slice(pos).match(DIGITAL_RE);

          if (match) {
            if (!silent) {
              code = match[1][0].toLowerCase() === 'x' ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);
              state.pending += isValidEntityCode(code) ? fromCodePoint(code) : fromCodePoint(0xFFFD);
            }

            state.pos += match[0].length;
            return true;
          }
        } else {
        match = state.src.slice(pos).match(NAMED_RE);

        if (match) {
          if (has(entities$2, match[1])) {
            if (!silent) {
              state.pending += entities$2[match[1]];
            }

            state.pos += match[0].length;
            return true;
          }
        }
      }
    }

    if (!silent) {
      state.pending += '&';
    }

    state.pos++;
    return true;
  };

  // For each opening emphasis-like marker find a matching closing one

  var balance_pairs = function link_pairs(state) {
    var i,
        j,
        lastDelim,
        currDelim,
        delimiters = state.delimiters,
        max = state.delimiters.length;

    for (i = 0; i < max; i++) {
      lastDelim = delimiters[i];

      if (!lastDelim.close) {
        continue;
      }

      j = i - lastDelim.jump - 1;

      while (j >= 0) {
        currDelim = delimiters[j];

        if (currDelim.open && currDelim.marker === lastDelim.marker && currDelim.end < 0 && currDelim.level === lastDelim.level) {
          // typeofs are for backward compatibility with plugins
          var odd_match = (currDelim.close || lastDelim.open) && typeof currDelim.length !== 'undefined' && typeof lastDelim.length !== 'undefined' && (currDelim.length + lastDelim.length) % 3 === 0;

          if (!odd_match) {
            lastDelim.jump = i - j;
            lastDelim.open = false;
            currDelim.end = i;
            currDelim.jump = 0;
            break;
          }
        }

        j -= currDelim.jump + 1;
      }
    }
  };

  // Merge adjacent text nodes into one, and re-calculate all token levels

  var text_collapse = function text_collapse(state) {
    var curr,
        last,
        level = 0,
        tokens = state.tokens,
        max = state.tokens.length;

    for (curr = last = 0; curr < max; curr++) {
      // re-calculate levels
      level += tokens[curr].nesting;
      tokens[curr].level = level;

      if (tokens[curr].type === 'text' && curr + 1 < max && tokens[curr + 1].type === 'text') {
        // collapse two adjacent text nodes
        tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
      } else {
        if (curr !== last) {
          tokens[last] = tokens[curr];
        }

        last++;
      }
    }

    if (curr !== last) {
      tokens.length = last;
    }
  };

  var isWhiteSpace$1 = utils.isWhiteSpace;
  var isPunctChar$1 = utils.isPunctChar;
  var isMdAsciiPunct$1 = utils.isMdAsciiPunct;

  function StateInline(src, md, env, outTokens) {
    this.src = src;
    this.env = env;
    this.md = md;
    this.tokens = outTokens;
    this.pos = 0;
    this.posMax = this.src.length;
    this.level = 0;
    this.pending = '';
    this.pendingLevel = 0;
    this.cache = {}; // Stores { start: end } pairs. Useful for backtrack
    // optimization of pairs parse (emphasis, strikes).

    this.delimiters = []; // Emphasis-like delimiters
  } // Flush pending text
  //


  StateInline.prototype.pushPending = function () {
    var token$$1 = new token('text', '', 0);
    token$$1.content = this.pending;
    token$$1.level = this.pendingLevel;
    this.tokens.push(token$$1);
    this.pending = '';
    return token$$1;
  }; // Push new token to "stream".
  // If pending text exists - flush it as text token
  //


  StateInline.prototype.push = function (type, tag, nesting) {
    if (this.pending) {
      this.pushPending();
    }

    var token$$1 = new token(type, tag, nesting);

    if (nesting < 0) {
      this.level--;
    }

    token$$1.level = this.level;

    if (nesting > 0) {
      this.level++;
    }

    this.pendingLevel = this.level;
    this.tokens.push(token$$1);
    return token$$1;
  }; // Scan a sequence of emphasis-like markers, and determine whether
  // it can start an emphasis sequence or end an emphasis sequence.
  //
  //  - start - position to scan from (it should point at a valid marker);
  //  - canSplitWord - determine if these markers can be found inside a word
  //


  StateInline.prototype.scanDelims = function (start, canSplitWord) {
    var pos = start,
        lastChar,
        nextChar,
        count,
        can_open,
        can_close,
        isLastWhiteSpace,
        isLastPunctChar,
        isNextWhiteSpace,
        isNextPunctChar,
        left_flanking = true,
        right_flanking = true,
        max = this.posMax,
        marker = this.src.charCodeAt(start); // treat beginning of the line as a whitespace

    lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 0x20;

    while (pos < max && this.src.charCodeAt(pos) === marker) {
      pos++;
    }

    count = pos - start; // treat end of the line as a whitespace

    nextChar = pos < max ? this.src.charCodeAt(pos) : 0x20;
    isLastPunctChar = isMdAsciiPunct$1(lastChar) || isPunctChar$1(String.fromCharCode(lastChar));
    isNextPunctChar = isMdAsciiPunct$1(nextChar) || isPunctChar$1(String.fromCharCode(nextChar));
    isLastWhiteSpace = isWhiteSpace$1(lastChar);
    isNextWhiteSpace = isWhiteSpace$1(nextChar);

    if (isNextWhiteSpace) {
      left_flanking = false;
    } else if (isNextPunctChar) {
      if (!(isLastWhiteSpace || isLastPunctChar)) {
        left_flanking = false;
      }
    }

    if (isLastWhiteSpace) {
      right_flanking = false;
    } else if (isLastPunctChar) {
      if (!(isNextWhiteSpace || isNextPunctChar)) {
        right_flanking = false;
      }
    }

    if (!canSplitWord) {
      can_open = left_flanking && (!right_flanking || isLastPunctChar);
      can_close = right_flanking && (!left_flanking || isNextPunctChar);
    } else {
      can_open = left_flanking;
      can_close = right_flanking;
    }

    return {
      can_open: can_open,
      can_close: can_close,
      length: count
    };
  }; // re-export Token class to use in block rules


  StateInline.prototype.Token = token;
  var state_inline = StateInline;

  // Parser rules


  var _rules$2 = [['text', text], ['newline', newline], ['escape', _escape], ['backticks', backticks], ['strikethrough', strikethrough.tokenize], ['emphasis', emphasis.tokenize], ['link', link], ['image', image$1], ['autolink', autolink], ['html_inline', html_inline], ['entity', entity]];
  var _rules2 = [['balance_pairs', balance_pairs], ['strikethrough', strikethrough.postProcess], ['emphasis', emphasis.postProcess], ['text_collapse', text_collapse]];
  /**
   * new ParserInline()
   **/

  function ParserInline() {
    var i;
    /**
     * ParserInline#ruler -> Ruler
     *
     * [[Ruler]] instance. Keep configuration of inline rules.
     **/

    this.ruler = new ruler();

    for (i = 0; i < _rules$2.length; i++) {
      this.ruler.push(_rules$2[i][0], _rules$2[i][1]);
    }
    /**
     * ParserInline#ruler2 -> Ruler
     *
     * [[Ruler]] instance. Second ruler used for post-processing
     * (e.g. in emphasis-like rules).
     **/


    this.ruler2 = new ruler();

    for (i = 0; i < _rules2.length; i++) {
      this.ruler2.push(_rules2[i][0], _rules2[i][1]);
    }
  } // Skip single token by running all rules in validation mode;
  // returns `true` if any rule reported success
  //


  ParserInline.prototype.skipToken = function (state) {
    var ok,
        i,
        pos = state.pos,
        rules = this.ruler.getRules(''),
        len = rules.length,
        maxNesting = state.md.options.maxNesting,
        cache = state.cache;

    if (typeof cache[pos] !== 'undefined') {
      state.pos = cache[pos];
      return;
    }

    if (state.level < maxNesting) {
      for (i = 0; i < len; i++) {
        // Increment state.level and decrement it later to limit recursion.
        // It's harmless to do here, because no tokens are created. But ideally,
        // we'd need a separate private state variable for this purpose.
        //
        state.level++;
        ok = rules[i](state, true);
        state.level--;

        if (ok) {
          break;
        }
      }
    } else {
      // Too much nesting, just skip until the end of the paragraph.
      //
      // NOTE: this will cause links to behave incorrectly in the following case,
      //       when an amount of `[` is exactly equal to `maxNesting + 1`:
      //
      //       [[[[[[[[[[[[[[[[[[[[[foo]()
      //
      // TODO: remove this workaround when CM standard will allow nested links
      //       (we can replace it by preventing links from being parsed in
      //       validation mode)
      //
      state.pos = state.posMax;
    }

    if (!ok) {
      state.pos++;
    }

    cache[pos] = state.pos;
  }; // Generate tokens for input range
  //


  ParserInline.prototype.tokenize = function (state) {
    var ok,
        i,
        rules = this.ruler.getRules(''),
        len = rules.length,
        end = state.posMax,
        maxNesting = state.md.options.maxNesting;

    while (state.pos < end) {
      // Try all possible rules.
      // On success, rule should:
      //
      // - update `state.pos`
      // - update `state.tokens`
      // - return true
      if (state.level < maxNesting) {
        for (i = 0; i < len; i++) {
          ok = rules[i](state, false);

          if (ok) {
            break;
          }
        }
      }

      if (ok) {
        if (state.pos >= end) {
          break;
        }

        continue;
      }

      state.pending += state.src[state.pos++];
    }

    if (state.pending) {
      state.pushPending();
    }
  };
  /**
   * ParserInline.parse(str, md, env, outTokens)
   *
   * Process input string and push inline tokens into `outTokens`
   **/


  ParserInline.prototype.parse = function (str, md, env, outTokens) {
    var i, rules, len;
    var state = new this.State(str, md, env, outTokens);
    this.tokenize(state);
    rules = this.ruler2.getRules('');
    len = rules.length;

    for (i = 0; i < len; i++) {
      rules[i](state);
    }
  };

  ParserInline.prototype.State = state_inline;
  var parser_inline = ParserInline;

  var re = function re(opts) {
    var re = {}; // Use direct extract instead of `regenerate` to reduse browserified size

    re.src_Any = regex$1.source;
    re.src_Cc = regex$2.source;
    re.src_Z = regex$4.source;
    re.src_P = regex.source; // \p{\Z\P\Cc\CF} (white spaces + control + format + punctuation)

    re.src_ZPCc = [re.src_Z, re.src_P, re.src_Cc].join('|'); // \p{\Z\Cc} (white spaces + control)

    re.src_ZCc = [re.src_Z, re.src_Cc].join('|'); // Experimental. List of chars, completely prohibited in links
    // because can separate it from other part of text

    var text_separators = "[><\uFF5C]"; // All possible word characters (everything without punctuation, spaces & controls)
    // Defined via punctuation & spaces to save space
    // Should be something like \p{\L\N\S\M} (\w but without `_`)

    re.src_pseudo_letter = '(?:(?!' + text_separators + '|' + re.src_ZPCc + ')' + re.src_Any + ')'; // The same as abothe but without [0-9]
    // var src_pseudo_letter_non_d = '(?:(?![0-9]|' + src_ZPCc + ')' + src_Any + ')';
    ////////////////////////////////////////////////////////////////////////////////

    re.src_ip4 = '(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)'; // Prohibit any of "@/[]()" in user/pass to avoid wrong domain fetch.

    re.src_auth = '(?:(?:(?!' + re.src_ZCc + '|[@/\\[\\]()]).)+@)?';
    re.src_port = '(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?';
    re.src_host_terminator = '(?=$|' + text_separators + '|' + re.src_ZPCc + ')(?!-|_|:\\d|\\.-|\\.(?!$|' + re.src_ZPCc + '))';
    re.src_path = '(?:' + '[/?#]' + '(?:' + '(?!' + re.src_ZCc + '|' + text_separators + '|[()[\\]{}.,"\'?!\\-]).|' + '\\[(?:(?!' + re.src_ZCc + '|\\]).)*\\]|' + '\\((?:(?!' + re.src_ZCc + '|[)]).)*\\)|' + '\\{(?:(?!' + re.src_ZCc + '|[}]).)*\\}|' + '\\"(?:(?!' + re.src_ZCc + '|["]).)+\\"|' + "\\'(?:(?!" + re.src_ZCc + "|[']).)+\\'|" + "\\'(?=" + re.src_pseudo_letter + '|[-]).|' + // allow `I'm_king` if no pair found
    '\\.{2,3}[a-zA-Z0-9%/]|' + // github has ... in commit range links. Restrict to
    // - english
    // - percent-encoded
    // - parts of file path
    // until more examples found.
    '\\.(?!' + re.src_ZCc + '|[.]).|' + (opts && opts['---'] ? '\\-(?!--(?:[^-]|$))(?:-*)|' // `---` => long dash, terminate
    : '\\-+|') + '\\,(?!' + re.src_ZCc + ').|' + // allow `,,,` in paths
    '\\!(?!' + re.src_ZCc + '|[!]).|' + '\\?(?!' + re.src_ZCc + '|[?]).' + ')+' + '|\\/' + ')?';
    re.src_email_name = '[\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]+';
    re.src_xn = 'xn--[a-z0-9\\-]{1,59}'; // More to read about domain names
    // http://serverfault.com/questions/638260/

    re.src_domain_root = // Allow letters & digits (http://test1)
    '(?:' + re.src_xn + '|' + re.src_pseudo_letter + '{1,63}' + ')';
    re.src_domain = '(?:' + re.src_xn + '|' + '(?:' + re.src_pseudo_letter + ')' + '|' + // don't allow `--` in domain names, because:
    // - that can conflict with markdown &mdash; / &ndash;
    // - nobody use those anyway
    '(?:' + re.src_pseudo_letter + '(?:-(?!-)|' + re.src_pseudo_letter + '){0,61}' + re.src_pseudo_letter + ')' + ')';
    re.src_host = '(?:' + // Don't need IP check, because digits are already allowed in normal domain names
    //   src_ip4 +
    // '|' +
    '(?:(?:(?:' + re.src_domain + ')\\.)*' + re.src_domain
    /*_root*/
    + ')' + ')';
    re.tpl_host_fuzzy = '(?:' + re.src_ip4 + '|' + '(?:(?:(?:' + re.src_domain + ')\\.)+(?:%TLDS%))' + ')';
    re.tpl_host_no_ip_fuzzy = '(?:(?:(?:' + re.src_domain + ')\\.)+(?:%TLDS%))';
    re.src_host_strict = re.src_host + re.src_host_terminator;
    re.tpl_host_fuzzy_strict = re.tpl_host_fuzzy + re.src_host_terminator;
    re.src_host_port_strict = re.src_host + re.src_port + re.src_host_terminator;
    re.tpl_host_port_fuzzy_strict = re.tpl_host_fuzzy + re.src_port + re.src_host_terminator;
    re.tpl_host_port_no_ip_fuzzy_strict = re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator; ////////////////////////////////////////////////////////////////////////////////
    // Main rules
    // Rude test fuzzy links by host, for quick deny

    re.tpl_host_fuzzy_test = 'localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:' + re.src_ZPCc + '|>|$))';
    re.tpl_email_fuzzy = '(^|' + text_separators + '|\\(|' + re.src_ZCc + ')(' + re.src_email_name + '@' + re.tpl_host_fuzzy_strict + ')';
    re.tpl_link_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
    // but can start with > (markdown blockquote)
    "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + re.src_ZPCc + '))' + "((?![$+<=>^`|\uFF5C])" + re.tpl_host_port_fuzzy_strict + re.src_path + ')';
    re.tpl_link_no_ip_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
    // but can start with > (markdown blockquote)
    "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + re.src_ZPCc + '))' + "((?![$+<=>^`|\uFF5C])" + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + ')';
    return re;
  };

  // Helpers
  // Merge objects
  //


  function assign$1(obj
  /*from1, from2, from3, ...*/
  ) {
    var sources = Array.prototype.slice.call(arguments, 1);
    sources.forEach(function (source) {
      if (!source) {
        return;
      }

      Object.keys(source).forEach(function (key) {
        obj[key] = source[key];
      });
    });
    return obj;
  }

  function _class(obj) {
    return Object.prototype.toString.call(obj);
  }

  function isString(obj) {
    return _class(obj) === '[object String]';
  }

  function isObject$2(obj) {
    return _class(obj) === '[object Object]';
  }

  function isRegExp(obj) {
    return _class(obj) === '[object RegExp]';
  }

  function isFunction$2(obj) {
    return _class(obj) === '[object Function]';
  }

  function escapeRE(str) {
    return str.replace(/[.?*+^$[\]\\(){}|-]/g, '\\$&');
  } ////////////////////////////////////////////////////////////////////////////////


  var defaultOptions = {
    fuzzyLink: true,
    fuzzyEmail: true,
    fuzzyIP: false
  };

  function isOptionsObj(obj) {
    return Object.keys(obj || {}).reduce(function (acc, k) {
      return acc || defaultOptions.hasOwnProperty(k);
    }, false);
  }

  var defaultSchemas = {
    'http:': {
      validate: function validate(text, pos, self) {
        var tail = text.slice(pos);

        if (!self.re.http) {
          // compile lazily, because "host"-containing variables can change on tlds update.
          self.re.http = new RegExp('^\\/\\/' + self.re.src_auth + self.re.src_host_port_strict + self.re.src_path, 'i');
        }

        if (self.re.http.test(tail)) {
          return tail.match(self.re.http)[0].length;
        }

        return 0;
      }
    },
    'https:': 'http:',
    'ftp:': 'http:',
    '//': {
      validate: function validate(text, pos, self) {
        var tail = text.slice(pos);

        if (!self.re.no_http) {
          // compile lazily, because "host"-containing variables can change on tlds update.
          self.re.no_http = new RegExp('^' + self.re.src_auth + // Don't allow single-level domains, because of false positives like '//test'
          // with code comments
          '(?:localhost|(?:(?:' + self.re.src_domain + ')\\.)+' + self.re.src_domain_root + ')' + self.re.src_port + self.re.src_host_terminator + self.re.src_path, 'i');
        }

        if (self.re.no_http.test(tail)) {
          // should not be `://` & `///`, that protects from errors in protocol name
          if (pos >= 3 && text[pos - 3] === ':') {
            return 0;
          }

          if (pos >= 3 && text[pos - 3] === '/') {
            return 0;
          }

          return tail.match(self.re.no_http)[0].length;
        }

        return 0;
      }
    },
    'mailto:': {
      validate: function validate(text, pos, self) {
        var tail = text.slice(pos);

        if (!self.re.mailto) {
          self.re.mailto = new RegExp('^' + self.re.src_email_name + '@' + self.re.src_host_strict, 'i');
        }

        if (self.re.mailto.test(tail)) {
          return tail.match(self.re.mailto)[0].length;
        }

        return 0;
      }
    }
  };
  /*eslint-disable max-len*/
  // RE pattern for 2-character tlds (autogenerated by ./support/tlds_2char_gen.js)

  var tlds_2ch_src_re = 'a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]'; // DON'T try to make PRs with changes. Extend TLDs with LinkifyIt.tlds() instead

  var tlds_default = 'biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф'.split('|');
  /*eslint-enable max-len*/
  ////////////////////////////////////////////////////////////////////////////////

  function resetScanCache(self) {
    self.__index__ = -1;
    self.__text_cache__ = '';
  }

  function createValidator(re$$1) {
    return function (text, pos) {
      var tail = text.slice(pos);

      if (re$$1.test(tail)) {
        return tail.match(re$$1)[0].length;
      }

      return 0;
    };
  }

  function createNormalizer() {
    return function (match, self) {
      self.normalize(match);
    };
  } // Schemas compiler. Build regexps.
  //


  function compile(self) {
    // Load & clone RE patterns.
    var re$$1 = self.re = re(self.__opts__); // Define dynamic patterns

    var tlds = self.__tlds__.slice();

    self.onCompile();

    if (!self.__tlds_replaced__) {
      tlds.push(tlds_2ch_src_re);
    }

    tlds.push(re$$1.src_xn);
    re$$1.src_tlds = tlds.join('|');

    function untpl(tpl) {
      return tpl.replace('%TLDS%', re$$1.src_tlds);
    }

    re$$1.email_fuzzy = RegExp(untpl(re$$1.tpl_email_fuzzy), 'i');
    re$$1.link_fuzzy = RegExp(untpl(re$$1.tpl_link_fuzzy), 'i');
    re$$1.link_no_ip_fuzzy = RegExp(untpl(re$$1.tpl_link_no_ip_fuzzy), 'i');
    re$$1.host_fuzzy_test = RegExp(untpl(re$$1.tpl_host_fuzzy_test), 'i'); //
    // Compile each schema
    //

    var aliases = [];
    self.__compiled__ = {}; // Reset compiled data

    function schemaError(name, val) {
      throw new Error('(LinkifyIt) Invalid schema "' + name + '": ' + val);
    }

    Object.keys(self.__schemas__).forEach(function (name) {
      var val = self.__schemas__[name]; // skip disabled methods

      if (val === null) {
        return;
      }

      var compiled = {
        validate: null,
        link: null
      };
      self.__compiled__[name] = compiled;

      if (isObject$2(val)) {
        if (isRegExp(val.validate)) {
          compiled.validate = createValidator(val.validate);
        } else if (isFunction$2(val.validate)) {
          compiled.validate = val.validate;
        } else {
          schemaError(name, val);
        }

        if (isFunction$2(val.normalize)) {
          compiled.normalize = val.normalize;
        } else if (!val.normalize) {
          compiled.normalize = createNormalizer();
        } else {
          schemaError(name, val);
        }

        return;
      }

      if (isString(val)) {
        aliases.push(name);
        return;
      }

      schemaError(name, val);
    }); //
    // Compile postponed aliases
    //

    aliases.forEach(function (alias) {
      if (!self.__compiled__[self.__schemas__[alias]]) {
        // Silently fail on missed schemas to avoid errons on disable.
        // schemaError(alias, self.__schemas__[alias]);
        return;
      }

      self.__compiled__[alias].validate = self.__compiled__[self.__schemas__[alias]].validate;
      self.__compiled__[alias].normalize = self.__compiled__[self.__schemas__[alias]].normalize;
    }); //
    // Fake record for guessed links
    //

    self.__compiled__[''] = {
      validate: null,
      normalize: createNormalizer()
    }; //
    // Build schema condition
    //

    var slist = Object.keys(self.__compiled__).filter(function (name) {
      // Filter disabled & fake schemas
      return name.length > 0 && self.__compiled__[name];
    }).map(escapeRE).join('|'); // (?!_) cause 1.5x slowdown

    self.re.schema_test = RegExp("(^|(?!_)(?:[><\uFF5C]|" + re$$1.src_ZPCc + '))(' + slist + ')', 'i');
    self.re.schema_search = RegExp("(^|(?!_)(?:[><\uFF5C]|" + re$$1.src_ZPCc + '))(' + slist + ')', 'ig');
    self.re.pretest = RegExp('(' + self.re.schema_test.source + ')|' + '(' + self.re.host_fuzzy_test.source + ')|' + '@', 'i'); //
    // Cleanup
    //

    resetScanCache(self);
  }
  /**
   * class Match
   *
   * Match result. Single element of array, returned by [[LinkifyIt#match]]
   **/


  function Match(self, shift) {
    var start = self.__index__,
        end = self.__last_index__,
        text = self.__text_cache__.slice(start, end);
    /**
     * Match#schema -> String
     *
     * Prefix (protocol) for matched string.
     **/


    this.schema = self.__schema__.toLowerCase();
    /**
     * Match#index -> Number
     *
     * First position of matched string.
     **/

    this.index = start + shift;
    /**
     * Match#lastIndex -> Number
     *
     * Next position after matched string.
     **/

    this.lastIndex = end + shift;
    /**
     * Match#raw -> String
     *
     * Matched string.
     **/

    this.raw = text;
    /**
     * Match#text -> String
     *
     * Notmalized text of matched string.
     **/

    this.text = text;
    /**
     * Match#url -> String
     *
     * Normalized url of matched string.
     **/

    this.url = text;
  }

  function createMatch(self, shift) {
    var match = new Match(self, shift);

    self.__compiled__[match.schema].normalize(match, self);

    return match;
  }
  /**
   * class LinkifyIt
   **/

  /**
   * new LinkifyIt(schemas, options)
   * - schemas (Object): Optional. Additional schemas to validate (prefix/validator)
   * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }
   *
   * Creates new linkifier instance with optional additional schemas.
   * Can be called without `new` keyword for convenience.
   *
   * By default understands:
   *
   * - `http(s)://...` , `ftp://...`, `mailto:...` & `//...` links
   * - "fuzzy" links and emails (example.com, foo@bar.com).
   *
   * `schemas` is an object, where each key/value describes protocol/rule:
   *
   * - __key__ - link prefix (usually, protocol name with `:` at the end, `skype:`
   *   for example). `linkify-it` makes shure that prefix is not preceeded with
   *   alphanumeric char and symbols. Only whitespaces and punctuation allowed.
   * - __value__ - rule to check tail after link prefix
   *   - _String_ - just alias to existing rule
   *   - _Object_
   *     - _validate_ - validator function (should return matched length on success),
   *       or `RegExp`.
   *     - _normalize_ - optional function to normalize text & url of matched result
   *       (for example, for @twitter mentions).
   *
   * `options`:
   *
   * - __fuzzyLink__ - recognige URL-s without `http(s):` prefix. Default `true`.
   * - __fuzzyIP__ - allow IPs in fuzzy links above. Can conflict with some texts
   *   like version numbers. Default `false`.
   * - __fuzzyEmail__ - recognize emails without `mailto:` prefix.
   *
   **/


  function LinkifyIt(schemas, options) {
    if (!(this instanceof LinkifyIt)) {
      return new LinkifyIt(schemas, options);
    }

    if (!options) {
      if (isOptionsObj(schemas)) {
        options = schemas;
        schemas = {};
      }
    }

    this.__opts__ = assign$1({}, defaultOptions, options); // Cache last tested result. Used to skip repeating steps on next `match` call.

    this.__index__ = -1;
    this.__last_index__ = -1; // Next scan position

    this.__schema__ = '';
    this.__text_cache__ = '';
    this.__schemas__ = assign$1({}, defaultSchemas, schemas);
    this.__compiled__ = {};
    this.__tlds__ = tlds_default;
    this.__tlds_replaced__ = false;
    this.re = {};
    compile(this);
  }
  /** chainable
   * LinkifyIt#add(schema, definition)
   * - schema (String): rule name (fixed pattern prefix)
   * - definition (String|RegExp|Object): schema definition
   *
   * Add new rule definition. See constructor description for details.
   **/


  LinkifyIt.prototype.add = function add(schema, definition) {
    this.__schemas__[schema] = definition;
    compile(this);
    return this;
  };
  /** chainable
   * LinkifyIt#set(options)
   * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }
   *
   * Set recognition options for links without schema.
   **/


  LinkifyIt.prototype.set = function set(options) {
    this.__opts__ = assign$1(this.__opts__, options);
    return this;
  };
  /**
   * LinkifyIt#test(text) -> Boolean
   *
   * Searches linkifiable pattern and returns `true` on success or `false` on fail.
   **/


  LinkifyIt.prototype.test = function test(text) {
    // Reset scan cache
    this.__text_cache__ = text;
    this.__index__ = -1;

    if (!text.length) {
      return false;
    }

    var m, ml, me, len, shift, next, re$$1, tld_pos, at_pos; // try to scan for link with schema - that's the most simple rule

    if (this.re.schema_test.test(text)) {
      re$$1 = this.re.schema_search;
      re$$1.lastIndex = 0;

      while ((m = re$$1.exec(text)) !== null) {
        len = this.testSchemaAt(text, m[2], re$$1.lastIndex);

        if (len) {
          this.__schema__ = m[2];
          this.__index__ = m.index + m[1].length;
          this.__last_index__ = m.index + m[0].length + len;
          break;
        }
      }
    }

    if (this.__opts__.fuzzyLink && this.__compiled__['http:']) {
      // guess schemaless links
      tld_pos = text.search(this.re.host_fuzzy_test);

      if (tld_pos >= 0) {
        // if tld is located after found link - no need to check fuzzy pattern
        if (this.__index__ < 0 || tld_pos < this.__index__) {
          if ((ml = text.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {
            shift = ml.index + ml[1].length;

            if (this.__index__ < 0 || shift < this.__index__) {
              this.__schema__ = '';
              this.__index__ = shift;
              this.__last_index__ = ml.index + ml[0].length;
            }
          }
        }
      }
    }

    if (this.__opts__.fuzzyEmail && this.__compiled__['mailto:']) {
      // guess schemaless emails
      at_pos = text.indexOf('@');

      if (at_pos >= 0) {
        // We can't skip this check, because this cases are possible:
        // 192.168.1.1@gmail.com, my.in@example.com
        if ((me = text.match(this.re.email_fuzzy)) !== null) {
          shift = me.index + me[1].length;
          next = me.index + me[0].length;

          if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next > this.__last_index__) {
            this.__schema__ = 'mailto:';
            this.__index__ = shift;
            this.__last_index__ = next;
          }
        }
      }
    }

    return this.__index__ >= 0;
  };
  /**
   * LinkifyIt#pretest(text) -> Boolean
   *
   * Very quick check, that can give false positives. Returns true if link MAY BE
   * can exists. Can be used for speed optimization, when you need to check that
   * link NOT exists.
   **/


  LinkifyIt.prototype.pretest = function pretest(text) {
    return this.re.pretest.test(text);
  };
  /**
   * LinkifyIt#testSchemaAt(text, name, position) -> Number
   * - text (String): text to scan
   * - name (String): rule (schema) name
   * - position (Number): text offset to check from
   *
   * Similar to [[LinkifyIt#test]] but checks only specific protocol tail exactly
   * at given position. Returns length of found pattern (0 on fail).
   **/


  LinkifyIt.prototype.testSchemaAt = function testSchemaAt(text, schema, pos) {
    // If not supported schema check requested - terminate
    if (!this.__compiled__[schema.toLowerCase()]) {
      return 0;
    }

    return this.__compiled__[schema.toLowerCase()].validate(text, pos, this);
  };
  /**
   * LinkifyIt#match(text) -> Array|null
   *
   * Returns array of found link descriptions or `null` on fail. We strongly
   * recommend to use [[LinkifyIt#test]] first, for best speed.
   *
   * ##### Result match description
   *
   * - __schema__ - link schema, can be empty for fuzzy links, or `//` for
   *   protocol-neutral  links.
   * - __index__ - offset of matched text
   * - __lastIndex__ - index of next char after mathch end
   * - __raw__ - matched text
   * - __text__ - normalized text
   * - __url__ - link, generated from matched text
   **/


  LinkifyIt.prototype.match = function match(text) {
    var shift = 0,
        result = []; // Try to take previous element from cache, if .test() called before

    if (this.__index__ >= 0 && this.__text_cache__ === text) {
      result.push(createMatch(this, shift));
      shift = this.__last_index__;
    } // Cut head if cache was used


    var tail = shift ? text.slice(shift) : text; // Scan string until end reached

    while (this.test(tail)) {
      result.push(createMatch(this, shift));
      tail = tail.slice(this.__last_index__);
      shift += this.__last_index__;
    }

    if (result.length) {
      return result;
    }

    return null;
  };
  /** chainable
   * LinkifyIt#tlds(list [, keepOld]) -> this
   * - list (Array): list of tlds
   * - keepOld (Boolean): merge with current list if `true` (`false` by default)
   *
   * Load (or merge) new tlds list. Those are user for fuzzy links (without prefix)
   * to avoid false positives. By default this algorythm used:
   *
   * - hostname with any 2-letter root zones are ok.
   * - biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф
   *   are ok.
   * - encoded (`xn--...`) root zones are ok.
   *
   * If list is replaced, then exact match for 2-chars root zones will be checked.
   **/


  LinkifyIt.prototype.tlds = function tlds(list, keepOld) {
    list = Array.isArray(list) ? list : [list];

    if (!keepOld) {
      this.__tlds__ = list.slice();
      this.__tlds_replaced__ = true;
      compile(this);
      return this;
    }

    this.__tlds__ = this.__tlds__.concat(list).sort().filter(function (el, idx, arr) {
      return el !== arr[idx - 1];
    }).reverse();
    compile(this);
    return this;
  };
  /**
   * LinkifyIt#normalize(match)
   *
   * Default normalizer (if schema does not define it's own).
   **/


  LinkifyIt.prototype.normalize = function normalize(match) {
    // Do minimal possible changes by default. Need to collect feedback prior
    // to move forward https://github.com/markdown-it/linkify-it/issues/1
    if (!match.schema) {
      match.url = 'http://' + match.url;
    }

    if (match.schema === 'mailto:' && !/^mailto:/i.test(match.url)) {
      match.url = 'mailto:' + match.url;
    }
  };
  /**
   * LinkifyIt#onCompile()
   *
   * Override to modify basic RegExp-s.
   **/


  LinkifyIt.prototype.onCompile = function onCompile() {};

  var linkifyIt = LinkifyIt;

  var punycode = createCommonjsModule(function (module, exports) {

    (function (root) {
      /** Detect free variables */
      var freeExports = 'object' == 'object' && exports && !exports.nodeType && exports;
      var freeModule = 'object' == 'object' && module && !module.nodeType && module;
      var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal;

      if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
        root = freeGlobal;
      }
      /**
       * The `punycode` object.
       * @name punycode
       * @type Object
       */


      var punycode,

      /** Highest positive signed 32-bit float value */
      maxInt = 2147483647,
          // aka. 0x7FFFFFFF or 2^31-1

      /** Bootstring parameters */
      base = 36,
          tMin = 1,
          tMax = 26,
          skew = 38,
          damp = 700,
          initialBias = 72,
          initialN = 128,
          // 0x80
      delimiter = '-',
          // '\x2D'

      /** Regular expressions */
      regexPunycode = /^xn--/,
          regexNonASCII = /[^\x20-\x7E]/,
          // unprintable ASCII chars + non-ASCII chars
      regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g,
          // RFC 3490 separators

      /** Error messages */
      errors = {
        'overflow': 'Overflow: input needs wider integers to process',
        'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
        'invalid-input': 'Invalid input'
      },

      /** Convenience shortcuts */
      baseMinusTMin = base - tMin,
          floor = Math.floor,
          stringFromCharCode = String.fromCharCode,

      /** Temporary variable */
      key;
      /*--------------------------------------------------------------------------*/

      /**
       * A generic error utility function.
       * @private
       * @param {String} type The error type.
       * @returns {Error} Throws a `RangeError` with the applicable error message.
       */

      function error(type) {
        throw new RangeError(errors[type]);
      }
      /**
       * A generic `Array#map` utility function.
       * @private
       * @param {Array} array The array to iterate over.
       * @param {Function} callback The function that gets called for every array
       * item.
       * @returns {Array} A new array of values returned by the callback function.
       */


      function map(array, fn) {
        var length = array.length;
        var result = [];

        while (length--) {
          result[length] = fn(array[length]);
        }

        return result;
      }
      /**
       * A simple `Array#map`-like wrapper to work with domain name strings or email
       * addresses.
       * @private
       * @param {String} domain The domain name or email address.
       * @param {Function} callback The function that gets called for every
       * character.
       * @returns {Array} A new string of characters returned by the callback
       * function.
       */


      function mapDomain(string, fn) {
        var parts = string.split('@');
        var result = '';

        if (parts.length > 1) {
          // In email addresses, only the domain name should be punycoded. Leave
          // the local part (i.e. everything up to `@`) intact.
          result = parts[0] + '@';
          string = parts[1];
        } // Avoid `split(regex)` for IE8 compatibility. See #17.


        string = string.replace(regexSeparators, '\x2E');
        var labels = string.split('.');
        var encoded = map(labels, fn).join('.');
        return result + encoded;
      }
      /**
       * Creates an array containing the numeric code points of each Unicode
       * character in the string. While JavaScript uses UCS-2 internally,
       * this function will convert a pair of surrogate halves (each of which
       * UCS-2 exposes as separate characters) into a single code point,
       * matching UTF-16.
       * @see `punycode.ucs2.encode`
       * @see <https://mathiasbynens.be/notes/javascript-encoding>
       * @memberOf punycode.ucs2
       * @name decode
       * @param {String} string The Unicode input string (UCS-2).
       * @returns {Array} The new array of code points.
       */


      function ucs2decode(string) {
        var output = [],
            counter = 0,
            length = string.length,
            value,
            extra;

        while (counter < length) {
          value = string.charCodeAt(counter++);

          if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
            // high surrogate, and there is a next character
            extra = string.charCodeAt(counter++);

            if ((extra & 0xFC00) == 0xDC00) {
              // low surrogate
              output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
            } else {
              // unmatched surrogate; only append this code unit, in case the next
              // code unit is the high surrogate of a surrogate pair
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }

        return output;
      }
      /**
       * Creates a string based on an array of numeric code points.
       * @see `punycode.ucs2.decode`
       * @memberOf punycode.ucs2
       * @name encode
       * @param {Array} codePoints The array of numeric code points.
       * @returns {String} The new Unicode string (UCS-2).
       */


      function ucs2encode(array) {
        return map(array, function (value) {
          var output = '';

          if (value > 0xFFFF) {
            value -= 0x10000;
            output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
            value = 0xDC00 | value & 0x3FF;
          }

          output += stringFromCharCode(value);
          return output;
        }).join('');
      }
      /**
       * Converts a basic code point into a digit/integer.
       * @see `digitToBasic()`
       * @private
       * @param {Number} codePoint The basic numeric code point value.
       * @returns {Number} The numeric value of a basic code point (for use in
       * representing integers) in the range `0` to `base - 1`, or `base` if
       * the code point does not represent a value.
       */


      function basicToDigit(codePoint) {
        if (codePoint - 48 < 10) {
          return codePoint - 22;
        }

        if (codePoint - 65 < 26) {
          return codePoint - 65;
        }

        if (codePoint - 97 < 26) {
          return codePoint - 97;
        }

        return base;
      }
      /**
       * Converts a digit/integer into a basic code point.
       * @see `basicToDigit()`
       * @private
       * @param {Number} digit The numeric value of a basic code point.
       * @returns {Number} The basic code point whose value (when used for
       * representing integers) is `digit`, which needs to be in the range
       * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
       * used; else, the lowercase form is used. The behavior is undefined
       * if `flag` is non-zero and `digit` has no uppercase form.
       */


      function digitToBasic(digit, flag) {
        //  0..25 map to ASCII a..z or A..Z
        // 26..35 map to ASCII 0..9
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      }
      /**
       * Bias adaptation function as per section 3.4 of RFC 3492.
       * https://tools.ietf.org/html/rfc3492#section-3.4
       * @private
       */


      function adapt(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);

        for (;
        /* no initialization */
        delta > baseMinusTMin * tMax >> 1; k += base) {
          delta = floor(delta / baseMinusTMin);
        }

        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
      }
      /**
       * Converts a Punycode string of ASCII-only symbols to a string of Unicode
       * symbols.
       * @memberOf punycode
       * @param {String} input The Punycode string of ASCII-only symbols.
       * @returns {String} The resulting string of Unicode symbols.
       */


      function decode(input) {
        // Don't use UCS-2
        var output = [],
            inputLength = input.length,
            out,
            i = 0,
            n = initialN,
            bias = initialBias,
            basic,
            j,
            index,
            oldi,
            w,
            k,
            digit,
            t,

        /** Cached calculation results */
        baseMinusT; // Handle the basic code points: let `basic` be the number of input code
        // points before the last delimiter, or `0` if there is none, then copy
        // the first basic code points to the output.

        basic = input.lastIndexOf(delimiter);

        if (basic < 0) {
          basic = 0;
        }

        for (j = 0; j < basic; ++j) {
          // if it's not a basic code point
          if (input.charCodeAt(j) >= 0x80) {
            error('not-basic');
          }

          output.push(input.charCodeAt(j));
        } // Main decoding loop: start just after the last delimiter if any basic code
        // points were copied; start at the beginning otherwise.


        for (index = basic > 0 ? basic + 1 : 0; index < inputLength;)
        /* no final expression */
        {
          // `index` is the index of the next character to be consumed.
          // Decode a generalized variable-length integer into `delta`,
          // which gets added to `i`. The overflow checking is easier
          // if we increase `i` as we go, then subtract off its starting
          // value at the end to obtain `delta`.
          for (oldi = i, w = 1, k = base;;
          /* no condition */
          k += base) {
            if (index >= inputLength) {
              error('invalid-input');
            }

            digit = basicToDigit(input.charCodeAt(index++));

            if (digit >= base || digit > floor((maxInt - i) / w)) {
              error('overflow');
            }

            i += digit * w;
            t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

            if (digit < t) {
              break;
            }

            baseMinusT = base - t;

            if (w > floor(maxInt / baseMinusT)) {
              error('overflow');
            }

            w *= baseMinusT;
          }

          out = output.length + 1;
          bias = adapt(i - oldi, out, oldi == 0); // `i` was supposed to wrap around from `out` to `0`,
          // incrementing `n` each time, so we'll fix that now:

          if (floor(i / out) > maxInt - n) {
            error('overflow');
          }

          n += floor(i / out);
          i %= out; // Insert `n` at position `i` of the output

          output.splice(i++, 0, n);
        }

        return ucs2encode(output);
      }
      /**
       * Converts a string of Unicode symbols (e.g. a domain name label) to a
       * Punycode string of ASCII-only symbols.
       * @memberOf punycode
       * @param {String} input The string of Unicode symbols.
       * @returns {String} The resulting Punycode string of ASCII-only symbols.
       */


      function encode(input) {
        var n,
            delta,
            handledCPCount,
            basicLength,
            bias,
            j,
            m,
            q,
            k,
            t,
            currentValue,
            output = [],

        /** `inputLength` will hold the number of code points in `input`. */
        inputLength,

        /** Cached calculation results */
        handledCPCountPlusOne,
            baseMinusT,
            qMinusT; // Convert the input in UCS-2 to Unicode

        input = ucs2decode(input); // Cache the length

        inputLength = input.length; // Initialize the state

        n = initialN;
        delta = 0;
        bias = initialBias; // Handle the basic code points

        for (j = 0; j < inputLength; ++j) {
          currentValue = input[j];

          if (currentValue < 0x80) {
            output.push(stringFromCharCode(currentValue));
          }
        }

        handledCPCount = basicLength = output.length; // `handledCPCount` is the number of code points that have been handled;
        // `basicLength` is the number of basic code points.
        // Finish the basic string - if it is not empty - with a delimiter

        if (basicLength) {
          output.push(delimiter);
        } // Main encoding loop:


        while (handledCPCount < inputLength) {
          // All non-basic code points < n have been handled already. Find the next
          // larger one:
          for (m = maxInt, j = 0; j < inputLength; ++j) {
            currentValue = input[j];

            if (currentValue >= n && currentValue < m) {
              m = currentValue;
            }
          } // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
          // but guard against overflow


          handledCPCountPlusOne = handledCPCount + 1;

          if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
            error('overflow');
          }

          delta += (m - n) * handledCPCountPlusOne;
          n = m;

          for (j = 0; j < inputLength; ++j) {
            currentValue = input[j];

            if (currentValue < n && ++delta > maxInt) {
              error('overflow');
            }

            if (currentValue == n) {
              // Represent delta as a generalized variable-length integer
              for (q = delta, k = base;;
              /* no condition */
              k += base) {
                t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

                if (q < t) {
                  break;
                }

                qMinusT = q - t;
                baseMinusT = base - t;
                output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                q = floor(qMinusT / baseMinusT);
              }

              output.push(stringFromCharCode(digitToBasic(q, 0)));
              bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
              delta = 0;
              ++handledCPCount;
            }
          }

          ++delta;
          ++n;
        }

        return output.join('');
      }
      /**
       * Converts a Punycode string representing a domain name or an email address
       * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
       * it doesn't matter if you call it on a string that has already been
       * converted to Unicode.
       * @memberOf punycode
       * @param {String} input The Punycoded domain name or email address to
       * convert to Unicode.
       * @returns {String} The Unicode representation of the given Punycode
       * string.
       */


      function toUnicode(input) {
        return mapDomain(input, function (string) {
          return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
        });
      }
      /**
       * Converts a Unicode string representing a domain name or an email address to
       * Punycode. Only the non-ASCII parts of the domain name will be converted,
       * i.e. it doesn't matter if you call it with a domain that's already in
       * ASCII.
       * @memberOf punycode
       * @param {String} input The domain name or email address to convert, as a
       * Unicode string.
       * @returns {String} The Punycode representation of the given domain name or
       * email address.
       */


      function toASCII(input) {
        return mapDomain(input, function (string) {
          return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
        });
      }
      /*--------------------------------------------------------------------------*/

      /** Define the public API */


      punycode = {
        /**
         * A string representing the current Punycode.js version number.
         * @memberOf punycode
         * @type String
         */
        'version': '1.4.1',

        /**
         * An object of methods to convert from JavaScript's internal character
         * representation (UCS-2) to Unicode code points, and back.
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode
         * @type Object
         */
        'ucs2': {
          'decode': ucs2decode,
          'encode': ucs2encode
        },
        'decode': decode,
        'encode': encode,
        'toASCII': toASCII,
        'toUnicode': toUnicode
      };
      /** Expose `punycode` */
      // Some AMD build optimizers, like r.js, check for specific condition patterns
      // like the following:

      if (typeof undefined == 'function' && typeof undefined.amd == 'object' && undefined.amd) {
        undefined('punycode', function () {
          return punycode;
        });
      } else if (freeExports && freeModule) {
        if (module.exports == freeExports) {
          // in Node.js, io.js, or RingoJS v0.8.0+
          freeModule.exports = punycode;
        } else {
          // in Narwhal or RingoJS v0.7.0-
          for (key in punycode) {
            punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
          }
        }
      } else {
        // in Rhino or a web browser
        root.punycode = punycode;
      }
    })(commonjsGlobal);
  });

  // markdown-it default options

  var _default = {
    options: {
      html: false,
      // Enable HTML tags in source
      xhtmlOut: false,
      // Use '/' to close single tags (<br />)
      breaks: false,
      // Convert '\n' in paragraphs into <br>
      langPrefix: 'language-',
      // CSS language prefix for fenced blocks
      linkify: false,
      // autoconvert URL-like texts to links
      // Enable some language-neutral replacements + quotes beautification
      typographer: false,
      // Double + single quotes replacement pairs, when typographer enabled,
      // and smartquotes on. Could be either a String or an Array.
      //
      // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
      // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
      quotes: "\u201C\u201D\u2018\u2019",

      /* “”‘’ */
      // Highlighter function. Should return escaped HTML,
      // or '' if the source string is not changed and should be escaped externaly.
      // If result starts with <pre... internal wrapper is skipped.
      //
      // function (/*str, lang*/) { return ''; }
      //
      highlight: null,
      maxNesting: 100 // Internal protection, recursion limit

    },
    components: {
      core: {},
      block: {},
      inline: {}
    }
  };

  // "Zero" preset, with nothing enabled. Useful for manual configuring of simple

  var zero = {
    options: {
      html: false,
      // Enable HTML tags in source
      xhtmlOut: false,
      // Use '/' to close single tags (<br />)
      breaks: false,
      // Convert '\n' in paragraphs into <br>
      langPrefix: 'language-',
      // CSS language prefix for fenced blocks
      linkify: false,
      // autoconvert URL-like texts to links
      // Enable some language-neutral replacements + quotes beautification
      typographer: false,
      // Double + single quotes replacement pairs, when typographer enabled,
      // and smartquotes on. Could be either a String or an Array.
      //
      // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
      // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
      quotes: "\u201C\u201D\u2018\u2019",

      /* “”‘’ */
      // Highlighter function. Should return escaped HTML,
      // or '' if the source string is not changed and should be escaped externaly.
      // If result starts with <pre... internal wrapper is skipped.
      //
      // function (/*str, lang*/) { return ''; }
      //
      highlight: null,
      maxNesting: 20 // Internal protection, recursion limit

    },
    components: {
      core: {
        rules: ['normalize', 'block', 'inline']
      },
      block: {
        rules: ['paragraph']
      },
      inline: {
        rules: ['text'],
        rules2: ['balance_pairs', 'text_collapse']
      }
    }
  };

  // Commonmark default options

  var commonmark = {
    options: {
      html: true,
      // Enable HTML tags in source
      xhtmlOut: true,
      // Use '/' to close single tags (<br />)
      breaks: false,
      // Convert '\n' in paragraphs into <br>
      langPrefix: 'language-',
      // CSS language prefix for fenced blocks
      linkify: false,
      // autoconvert URL-like texts to links
      // Enable some language-neutral replacements + quotes beautification
      typographer: false,
      // Double + single quotes replacement pairs, when typographer enabled,
      // and smartquotes on. Could be either a String or an Array.
      //
      // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
      // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
      quotes: "\u201C\u201D\u2018\u2019",

      /* “”‘’ */
      // Highlighter function. Should return escaped HTML,
      // or '' if the source string is not changed and should be escaped externaly.
      // If result starts with <pre... internal wrapper is skipped.
      //
      // function (/*str, lang*/) { return ''; }
      //
      highlight: null,
      maxNesting: 20 // Internal protection, recursion limit

    },
    components: {
      core: {
        rules: ['normalize', 'block', 'inline']
      },
      block: {
        rules: ['blockquote', 'code', 'fence', 'heading', 'hr', 'html_block', 'lheading', 'list', 'reference', 'paragraph']
      },
      inline: {
        rules: ['autolink', 'backticks', 'emphasis', 'entity', 'escape', 'html_inline', 'image', 'link', 'newline', 'text'],
        rules2: ['balance_pairs', 'emphasis', 'text_collapse']
      }
    }
  };

  var config$3 = {
    'default': _default,
    zero: zero,
    commonmark: commonmark
  }; ////////////////////////////////////////////////////////////////////////////////
  //
  // This validator can prohibit more than really needed to prevent XSS. It's a
  // tradeoff to keep code simple and to be secure by default.
  //
  // If you need different setup - override validator method as you wish. Or
  // replace it with dummy function and use external sanitizer.
  //

  var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
  var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;

  function validateLink(url) {
    // url should be normalized at this point, and existing entities are decoded
    var str = url.trim().toLowerCase();
    return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) ? true : false : true;
  } ////////////////////////////////////////////////////////////////////////////////


  var RECODE_HOSTNAME_FOR = ['http:', 'https:', 'mailto:'];

  function normalizeLink(url) {
    var parsed = mdurl.parse(url, true);

    if (parsed.hostname) {
      // Encode hostnames in urls like:
      // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`
      //
      // We don't encode unknown schemas, because it's likely that we encode
      // something we shouldn't (e.g. `skype:name` treated as `skype:host`)
      //
      if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
        try {
          parsed.hostname = punycode.toASCII(parsed.hostname);
        } catch (er) {
          /**/
        }
      }
    }

    return mdurl.encode(mdurl.format(parsed));
  }

  function normalizeLinkText(url) {
    var parsed = mdurl.parse(url, true);

    if (parsed.hostname) {
      // Encode hostnames in urls like:
      // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`
      //
      // We don't encode unknown schemas, because it's likely that we encode
      // something we shouldn't (e.g. `skype:name` treated as `skype:host`)
      //
      if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
        try {
          parsed.hostname = punycode.toUnicode(parsed.hostname);
        } catch (er) {
          /**/
        }
      }
    }

    return mdurl.decode(mdurl.format(parsed));
  }
  /**
   * class MarkdownIt
   *
   * Main parser/renderer class.
   *
   * ##### Usage
   *
   * ```javascript
   * // node.js, "classic" way:
   * var MarkdownIt = require('markdown-it'),
   *     md = new MarkdownIt();
   * var result = md.render('# markdown-it rulezz!');
   *
   * // node.js, the same, but with sugar:
   * var md = require('markdown-it')();
   * var result = md.render('# markdown-it rulezz!');
   *
   * // browser without AMD, added to "window" on script load
   * // Note, there are no dash.
   * var md = window.markdownit();
   * var result = md.render('# markdown-it rulezz!');
   * ```
   *
   * Single line rendering, without paragraph wrap:
   *
   * ```javascript
   * var md = require('markdown-it')();
   * var result = md.renderInline('__markdown-it__ rulezz!');
   * ```
   **/

  /**
   * new MarkdownIt([presetName, options])
   * - presetName (String): optional, `commonmark` / `zero`
   * - options (Object)
   *
   * Creates parser instanse with given config. Can be called without `new`.
   *
   * ##### presetName
   *
   * MarkdownIt provides named presets as a convenience to quickly
   * enable/disable active syntax rules and options for common use cases.
   *
   * - ["commonmark"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/commonmark.js) -
   *   configures parser to strict [CommonMark](http://commonmark.org/) mode.
   * - [default](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/default.js) -
   *   similar to GFM, used when no preset name given. Enables all available rules,
   *   but still without html, typographer & autolinker.
   * - ["zero"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/zero.js) -
   *   all rules disabled. Useful to quickly setup your config via `.enable()`.
   *   For example, when you need only `bold` and `italic` markup and nothing else.
   *
   * ##### options:
   *
   * - __html__ - `false`. Set `true` to enable HTML tags in source. Be careful!
   *   That's not safe! You may need external sanitizer to protect output from XSS.
   *   It's better to extend features via plugins, instead of enabling HTML.
   * - __xhtmlOut__ - `false`. Set `true` to add '/' when closing single tags
   *   (`<br />`). This is needed only for full CommonMark compatibility. In real
   *   world you will need HTML output.
   * - __breaks__ - `false`. Set `true` to convert `\n` in paragraphs into `<br>`.
   * - __langPrefix__ - `language-`. CSS language class prefix for fenced blocks.
   *   Can be useful for external highlighters.
   * - __linkify__ - `false`. Set `true` to autoconvert URL-like text to links.
   * - __typographer__  - `false`. Set `true` to enable [some language-neutral
   *   replacement](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/replacements.js) +
   *   quotes beautification (smartquotes).
   * - __quotes__ - `“”‘’`, String or Array. Double + single quotes replacement
   *   pairs, when typographer enabled and smartquotes on. For example, you can
   *   use `'«»„“'` for Russian, `'„“‚‘'` for German, and
   *   `['«\xA0', '\xA0»', '‹\xA0', '\xA0›']` for French (including nbsp).
   * - __highlight__ - `null`. Highlighter function for fenced code blocks.
   *   Highlighter `function (str, lang)` should return escaped HTML. It can also
   *   return empty string if the source was not changed and should be escaped
   *   externaly. If result starts with <pre... internal wrapper is skipped.
   *
   * ##### Example
   *
   * ```javascript
   * // commonmark mode
   * var md = require('markdown-it')('commonmark');
   *
   * // default mode
   * var md = require('markdown-it')();
   *
   * // enable everything
   * var md = require('markdown-it')({
   *   html: true,
   *   linkify: true,
   *   typographer: true
   * });
   * ```
   *
   * ##### Syntax highlighting
   *
   * ```js
   * var hljs = require('highlight.js') // https://highlightjs.org/
   *
   * var md = require('markdown-it')({
   *   highlight: function (str, lang) {
   *     if (lang && hljs.getLanguage(lang)) {
   *       try {
   *         return hljs.highlight(lang, str, true).value;
   *       } catch (__) {}
   *     }
   *
   *     return ''; // use external default escaping
   *   }
   * });
   * ```
   *
   * Or with full wrapper override (if you need assign class to `<pre>`):
   *
   * ```javascript
   * var hljs = require('highlight.js') // https://highlightjs.org/
   *
   * // Actual default values
   * var md = require('markdown-it')({
   *   highlight: function (str, lang) {
   *     if (lang && hljs.getLanguage(lang)) {
   *       try {
   *         return '<pre class="hljs"><code>' +
   *                hljs.highlight(lang, str, true).value +
   *                '</code></pre>';
   *       } catch (__) {}
   *     }
   *
   *     return '<pre class="hljs"><code>' + md.utils.escapeHtml(str) + '</code></pre>';
   *   }
   * });
   * ```
   *
   **/


  function MarkdownIt(presetName, options) {
    if (!(this instanceof MarkdownIt)) {
      return new MarkdownIt(presetName, options);
    }

    if (!options) {
      if (!utils.isString(presetName)) {
        options = presetName || {};
        presetName = 'default';
      }
    }
    /**
     * MarkdownIt#inline -> ParserInline
     *
     * Instance of [[ParserInline]]. You may need it to add new rules when
     * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
     * [[MarkdownIt.enable]].
     **/


    this.inline = new parser_inline();
    /**
     * MarkdownIt#block -> ParserBlock
     *
     * Instance of [[ParserBlock]]. You may need it to add new rules when
     * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
     * [[MarkdownIt.enable]].
     **/

    this.block = new parser_block();
    /**
     * MarkdownIt#core -> Core
     *
     * Instance of [[Core]] chain executor. You may need it to add new rules when
     * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
     * [[MarkdownIt.enable]].
     **/

    this.core = new parser_core();
    /**
     * MarkdownIt#renderer -> Renderer
     *
     * Instance of [[Renderer]]. Use it to modify output look. Or to add rendering
     * rules for new token types, generated by plugins.
     *
     * ##### Example
     *
     * ```javascript
     * var md = require('markdown-it')();
     *
     * function myToken(tokens, idx, options, env, self) {
     *   //...
     *   return result;
     * };
     *
     * md.renderer.rules['my_token'] = myToken
     * ```
     *
     * See [[Renderer]] docs and [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js).
     **/

    this.renderer = new renderer();
    /**
     * MarkdownIt#linkify -> LinkifyIt
     *
     * [linkify-it](https://github.com/markdown-it/linkify-it) instance.
     * Used by [linkify](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/linkify.js)
     * rule.
     **/

    this.linkify = new linkifyIt();
    /**
     * MarkdownIt#validateLink(url) -> Boolean
     *
     * Link validation function. CommonMark allows too much in links. By default
     * we disable `javascript:`, `vbscript:`, `file:` schemas, and almost all `data:...` schemas
     * except some embedded image types.
     *
     * You can change this behaviour:
     *
     * ```javascript
     * var md = require('markdown-it')();
     * // enable everything
     * md.validateLink = function () { return true; }
     * ```
     **/

    this.validateLink = validateLink;
    /**
     * MarkdownIt#normalizeLink(url) -> String
     *
     * Function used to encode link url to a machine-readable format,
     * which includes url-encoding, punycode, etc.
     **/

    this.normalizeLink = normalizeLink;
    /**
     * MarkdownIt#normalizeLinkText(url) -> String
     *
     * Function used to decode link url to a human-readable format`
     **/

    this.normalizeLinkText = normalizeLinkText; // Expose utils & helpers for easy acces from plugins

    /**
     * MarkdownIt#utils -> utils
     *
     * Assorted utility functions, useful to write plugins. See details
     * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/common/utils.js).
     **/

    this.utils = utils;
    /**
     * MarkdownIt#helpers -> helpers
     *
     * Link components parser functions, useful to write plugins. See details
     * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/helpers).
     **/

    this.helpers = utils.assign({}, helpers);
    this.options = {};
    this.configure(presetName);

    if (options) {
      this.set(options);
    }
  }
  /** chainable
   * MarkdownIt.set(options)
   *
   * Set parser options (in the same format as in constructor). Probably, you
   * will never need it, but you can change options after constructor call.
   *
   * ##### Example
   *
   * ```javascript
   * var md = require('markdown-it')()
   *             .set({ html: true, breaks: true })
   *             .set({ typographer, true });
   * ```
   *
   * __Note:__ To achieve the best possible performance, don't modify a
   * `markdown-it` instance options on the fly. If you need multiple configurations
   * it's best to create multiple instances and initialize each with separate
   * config.
   **/


  MarkdownIt.prototype.set = function (options) {
    utils.assign(this.options, options);
    return this;
  };
  /** chainable, internal
   * MarkdownIt.configure(presets)
   *
   * Batch load of all options and compenent settings. This is internal method,
   * and you probably will not need it. But if you with - see available presets
   * and data structure [here](https://github.com/markdown-it/markdown-it/tree/master/lib/presets)
   *
   * We strongly recommend to use presets instead of direct config loads. That
   * will give better compatibility with next versions.
   **/


  MarkdownIt.prototype.configure = function (presets) {
    var self = this,
        presetName;

    if (utils.isString(presets)) {
      presetName = presets;
      presets = config$3[presetName];

      if (!presets) {
        throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name');
      }
    }

    if (!presets) {
      throw new Error('Wrong `markdown-it` preset, can\'t be empty');
    }

    if (presets.options) {
      self.set(presets.options);
    }

    if (presets.components) {
      Object.keys(presets.components).forEach(function (name) {
        if (presets.components[name].rules) {
          self[name].ruler.enableOnly(presets.components[name].rules);
        }

        if (presets.components[name].rules2) {
          self[name].ruler2.enableOnly(presets.components[name].rules2);
        }
      });
    }

    return this;
  };
  /** chainable
   * MarkdownIt.enable(list, ignoreInvalid)
   * - list (String|Array): rule name or list of rule names to enable
   * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
   *
   * Enable list or rules. It will automatically find appropriate components,
   * containing rules with given names. If rule not found, and `ignoreInvalid`
   * not set - throws exception.
   *
   * ##### Example
   *
   * ```javascript
   * var md = require('markdown-it')()
   *             .enable(['sub', 'sup'])
   *             .disable('smartquotes');
   * ```
   **/


  MarkdownIt.prototype.enable = function (list, ignoreInvalid) {
    var result = [];

    if (!Array.isArray(list)) {
      list = [list];
    }

    ['core', 'block', 'inline'].forEach(function (chain) {
      result = result.concat(this[chain].ruler.enable(list, true));
    }, this);
    result = result.concat(this.inline.ruler2.enable(list, true));
    var missed = list.filter(function (name) {
      return result.indexOf(name) < 0;
    });

    if (missed.length && !ignoreInvalid) {
      throw new Error('MarkdownIt. Failed to enable unknown rule(s): ' + missed);
    }

    return this;
  };
  /** chainable
   * MarkdownIt.disable(list, ignoreInvalid)
   * - list (String|Array): rule name or list of rule names to disable.
   * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
   *
   * The same as [[MarkdownIt.enable]], but turn specified rules off.
   **/


  MarkdownIt.prototype.disable = function (list, ignoreInvalid) {
    var result = [];

    if (!Array.isArray(list)) {
      list = [list];
    }

    ['core', 'block', 'inline'].forEach(function (chain) {
      result = result.concat(this[chain].ruler.disable(list, true));
    }, this);
    result = result.concat(this.inline.ruler2.disable(list, true));
    var missed = list.filter(function (name) {
      return result.indexOf(name) < 0;
    });

    if (missed.length && !ignoreInvalid) {
      throw new Error('MarkdownIt. Failed to disable unknown rule(s): ' + missed);
    }

    return this;
  };
  /** chainable
   * MarkdownIt.use(plugin, params)
   *
   * Load specified plugin with given params into current parser instance.
   * It's just a sugar to call `plugin(md, params)` with curring.
   *
   * ##### Example
   *
   * ```javascript
   * var iterator = require('markdown-it-for-inline');
   * var md = require('markdown-it')()
   *             .use(iterator, 'foo_replace', 'text', function (tokens, idx) {
   *               tokens[idx].content = tokens[idx].content.replace(/foo/g, 'bar');
   *             });
   * ```
   **/


  MarkdownIt.prototype.use = function (plugin
  /*, params, ... */
  ) {
    var args = [this].concat(Array.prototype.slice.call(arguments, 1));
    plugin.apply(plugin, args);
    return this;
  };
  /** internal
   * MarkdownIt.parse(src, env) -> Array
   * - src (String): source string
   * - env (Object): environment sandbox
   *
   * Parse input string and returns list of block tokens (special token type
   * "inline" will contain list of inline tokens). You should not call this
   * method directly, until you write custom renderer (for example, to produce
   * AST).
   *
   * `env` is used to pass data between "distributed" rules and return additional
   * metadata like reference info, needed for the renderer. It also can be used to
   * inject data in specific cases. Usually, you will be ok to pass `{}`,
   * and then pass updated object to renderer.
   **/


  MarkdownIt.prototype.parse = function (src, env) {
    if (typeof src !== 'string') {
      throw new Error('Input data should be a String');
    }

    var state = new this.core.State(src, this, env);
    this.core.process(state);
    return state.tokens;
  };
  /**
   * MarkdownIt.render(src [, env]) -> String
   * - src (String): source string
   * - env (Object): environment sandbox
   *
   * Render markdown string into html. It does all magic for you :).
   *
   * `env` can be used to inject additional metadata (`{}` by default).
   * But you will not need it with high probability. See also comment
   * in [[MarkdownIt.parse]].
   **/


  MarkdownIt.prototype.render = function (src, env) {
    env = env || {};
    return this.renderer.render(this.parse(src, env), this.options, env);
  };
  /** internal
   * MarkdownIt.parseInline(src, env) -> Array
   * - src (String): source string
   * - env (Object): environment sandbox
   *
   * The same as [[MarkdownIt.parse]] but skip all block rules. It returns the
   * block tokens list with the single `inline` element, containing parsed inline
   * tokens in `children` property. Also updates `env` object.
   **/


  MarkdownIt.prototype.parseInline = function (src, env) {
    var state = new this.core.State(src, this, env);
    state.inlineMode = true;
    this.core.process(state);
    return state.tokens;
  };
  /**
   * MarkdownIt.renderInline(src [, env]) -> String
   * - src (String): source string
   * - env (Object): environment sandbox
   *
   * Similar to [[MarkdownIt.render]] but for single paragraph content. Result
   * will NOT be wrapped into `<p>` tags.
   **/


  MarkdownIt.prototype.renderInline = function (src, env) {
    env = env || {};
    return this.renderer.render(this.parseInline(src, env), this.options, env);
  };

  var lib = MarkdownIt;

  var markdownIt = lib;

  var markdownIt$1 = new markdownIt({
    html: true,
    langPrefix: 'hljs ',
    highlight: function highlight(str, lang) {
      var hljs = window.hljs;

      if (hljs == null) {
        console.warn('highlight.js (`window.hljs`) is missing');
        return '';
      }

      if (lang && hljs.getLanguage(lang)) {
        try {
          return hljs.highlight(lang, str).value;
        } catch (e) {
          console.error(e);
        }
      }

      try {
        return hljs.highlightAuto(str).value;
      } catch (e) {
        console.error(e);
      }

      return ''; // use external default escaping
    }
  });
  function compileMarkdown(markdown) {
    markdownIt$1.renderer.rules.link_open = linkOpenAsTargetBlank;
    return markdownIt$1.render(markdown);
  }

  function linkOpenAsTargetBlank(tokens, idx, options, _, self) {
    var linkOpenToken = tokens[idx];
    var targetAttrIndex = linkOpenToken.attrIndex('target');

    if (targetAttrIndex < 0) {
      linkOpenToken.attrPush(['target', '_blank']);
    } else {
      linkOpenToken.attrs[targetAttrIndex][1] = '_blank';
    }

    return self.renderToken(tokens, idx, options);
  }

  function _CustomElement$3() {
    return Reflect.construct(HTMLElement, [], this.__proto__.constructor);
  }
  Object.setPrototypeOf(_CustomElement$3.prototype, HTMLElement.prototype);
  Object.setPrototypeOf(_CustomElement$3, HTMLElement);

  function template$3(_ref) {
    var image = _ref.image,
        filter = _ref.filter;
    return html`
<style>

:host {
  display: flex;
  position: relative;
  min-width: 100vw;
  min-height: 100vh;
  overflow: hidden;
}

:host[id] { /* nearly initialized */
  visibility: visible;
}

.layout-slot {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;

  position: absolute;
  z-index: 2;
  transform-origin: left top;

  min-width: auto;
  min-height: auto;
  opacity: 1;
  z-index: 2;

  width: var(--talkie-slide-width, 1024px);
  height: var(--talkie-slide-height, 768px);
  transform: var(--talkie-slide-scale, scale(1));
  top: var(--talkie-slide-top, 0);
  left: var(--talkie-slide-left, 0);
}

tk-backface {
  background: var(--talkie-slide-bg, radial-gradient(#f8f8f8 0%, #e6e6e6 100%));
}

[invert] + tk-backface {
  background: var(--talkie-slide-invert-bg, radial-gradient(#262626 0%, #080808 100%));
}

/* Layout Utilities */
.layout-slot[flex]       { display: flex !important; }
.layout-slot[vertical]   { flex-direction: column !important; }
.layout-slot[horizontal] { flex-direction: row !important; }

.layout-slot[v-center]             { justify-content: center !important; }
.layout-slot[horizontal][v-center] { align-items: center !important; }

.layout-slot[v-top]             { justify-content: flex-start !important; }
.layout-slot[horizontal][v-top] { align-items: flex-start !important; }

.layout-slot[v-bottom]             { justify-content: flex-end !important; }
.layout-slot[horizontal][v-bottom] { align-items: flex-end !important; }

.layout-slot[h-center]             { align-items: center !important; }
.layout-slot[horizontal][h-center] { justify-content: center !important; }

.layout-slot[h-left]             { align-items: flex-start !important; }
.layout-slot[horizontal][h-left] { justify-content: flex-start !important; }

.layout-slot[h-right]             { align-items: flex-end !important; }
.layout-slot[horizontal][h-right] { justify-content: flex-end !important; }

.layout-slot[h-left] > *  { text-align: left !important; }
.layout-slot[h-right] > * { text-align: right !important; }

.layout-slot[s-center] { align-self: center !important; }
.layout-slot[s-start]  { align-self: flex-start !important; }
.layout-slot[s-end]    { align-self: flex-end !important; }
</style>

<div class="layout-slot">
  <slot></slot>
</div>

<tk-backface
  role="presentation"
  image="${image}"
  filter="${filter}"></tk-backface>
`;
  }

  var TalkieSlideAttributes;

  (function (TalkieSlideAttributes) {
    TalkieSlideAttributes["BACKFACE"] = "backface";
    TalkieSlideAttributes["BACKFACE_FILTER"] = "backface-filter";
    TalkieSlideAttributes["TYPE"] = "type";
  })(TalkieSlideAttributes || (TalkieSlideAttributes = {}));

  var TalkieSlide =
  /*#__PURE__*/
  function (_CustomElement2) {
    _createClass(TalkieSlide, null, [{
      key: "ns",
      get: function get() {
        return 'tk-slide';
      }
    }]);

    function TalkieSlide() {
      _classCallCheck(this, TalkieSlide);

      return _possibleConstructorReturn(this, _getPrototypeOf(TalkieSlide).call(this));
    }

    _createClass(TalkieSlide, [{
      key: "getLayoutElement",
      value: function getLayoutElement() {
        if (this.shadowRoot == null) {
          throw new Error('shadowRoot not initialized yet');
        }

        return this.shadowRoot.querySelector('.layout-slot');
      }
    }, {
      key: "toVisible",
      value: function toVisible() {
        this.setAttribute('aria-hidden', 'false');
      }
    }, {
      key: "toInvisible",
      value: function toInvisible() {
        this.setAttribute('aria-hidden', 'true');
      }
    }, {
      key: "connectedCallback",
      value: function connectedCallback() {
        if (this.getAttribute(TalkieSlideAttributes.TYPE) === 'text/x-markdown') {
          this.innerHTML = compileMarkdown(this.innerHTML.replace('&gt;', '>'));
        }

        this.attachShadow({
          mode: 'open'
        });
        this.render();
        this.inheritAttributesToLayoutSlot();
      }
    }, {
      key: "inheritAttributesToLayoutSlot",
      value: function inheritAttributesToLayoutSlot() {
        var layoutEl = this.getLayoutElement();
        var ownAttributes = Object.keys(TalkieSlideAttributes).map(function (key) {
          return TalkieSlideAttributes[key];
        });
        /**
         * FIXME This is a WORKAROUND :(
         *
         * In Array.from, InvalidCharacterError occurred in EdgeHTML 16.16299.
         * Therefore, convert it to Array in the following way.
         */

        Array.prototype.slice.call(this.attributes).filter(function (attr) {
          return !ownAttributes.includes(attr.name);
        }).forEach(function (attr) {
          layoutEl.setAttribute(attr.name, attr.value);
        });
        /**
         * Properties such as `display: flex` usually require declaration both in parent element in LightDOM and in parent element in <slot>.
         * However, if `ShadyDOM` is enabled, simply applying style will duplicate, so delete the `layout` attribute which causes it in Talkie.
         */

        if (window.ShadyDOM != null) {
          this.removeAttribute('layout');
        }
      }
    }, {
      key: "render",
      value: function render$$1() {
        if (this.shadowRoot == null) {
          throw new Error('shadowRoot not initialized yet');
        }

        render$1(template$3({
          image: this.getAttribute(TalkieSlideAttributes.BACKFACE) || '',
          filter: this.getAttribute(TalkieSlideAttributes.BACKFACE_FILTER) || ''
        }), this.shadowRoot, TalkieSlide.ns);
      }
    }]);

    _inherits(TalkieSlide, _CustomElement2);

    return TalkieSlide;
  }(_CustomElement$3);

  var keycode = createCommonjsModule(function (module, exports) {
    // Source: http://jsfiddle.net/vWx8V/
    // http://stackoverflow.com/questions/5603195/full-list-of-javascript-keycodes

    /**
     * Conenience method returns corresponding value for given keyName or keyCode.
     *
     * @param {Mixed} keyCode {Number} or keyName {String}
     * @return {Mixed}
     * @api public
     */
    function keyCode(searchInput) {
      // Keyboard Events
      if (searchInput && 'object' === typeof searchInput) {
        var hasKeyCode = searchInput.which || searchInput.keyCode || searchInput.charCode;
        if (hasKeyCode) searchInput = hasKeyCode;
      } // Numbers


      if ('number' === typeof searchInput) return names[searchInput]; // Everything else (cast to string)

      var search = String(searchInput); // check codes

      var foundNamedKey = codes[search.toLowerCase()];
      if (foundNamedKey) return foundNamedKey; // check aliases

      var foundNamedKey = aliases[search.toLowerCase()];
      if (foundNamedKey) return foundNamedKey; // weird character?

      if (search.length === 1) return search.charCodeAt(0);
      return undefined;
    }
    /**
     * Compares a keyboard event with a given keyCode or keyName.
     *
     * @param {Event} event Keyboard event that should be tested
     * @param {Mixed} keyCode {Number} or keyName {String}
     * @return {Boolean}
     * @api public
     */


    keyCode.isEventKey = function isEventKey(event, nameOrCode) {
      if (event && 'object' === typeof event) {
        var keyCode = event.which || event.keyCode || event.charCode;

        if (keyCode === null || keyCode === undefined) {
          return false;
        }

        if (typeof nameOrCode === 'string') {
          // check codes
          var foundNamedKey = codes[nameOrCode.toLowerCase()];

          if (foundNamedKey) {
            return foundNamedKey === keyCode;
          } // check aliases


          var foundNamedKey = aliases[nameOrCode.toLowerCase()];

          if (foundNamedKey) {
            return foundNamedKey === keyCode;
          }
        } else if (typeof nameOrCode === 'number') {
          return nameOrCode === keyCode;
        }

        return false;
      }
    };

    exports = module.exports = keyCode;
    /**
     * Get by name
     *
     *   exports.code['enter'] // => 13
     */

    var codes = exports.code = exports.codes = {
      'backspace': 8,
      'tab': 9,
      'enter': 13,
      'shift': 16,
      'ctrl': 17,
      'alt': 18,
      'pause/break': 19,
      'caps lock': 20,
      'esc': 27,
      'space': 32,
      'page up': 33,
      'page down': 34,
      'end': 35,
      'home': 36,
      'left': 37,
      'up': 38,
      'right': 39,
      'down': 40,
      'insert': 45,
      'delete': 46,
      'command': 91,
      'left command': 91,
      'right command': 93,
      'numpad *': 106,
      'numpad +': 107,
      'numpad -': 109,
      'numpad .': 110,
      'numpad /': 111,
      'num lock': 144,
      'scroll lock': 145,
      'my computer': 182,
      'my calculator': 183,
      ';': 186,
      '=': 187,
      ',': 188,
      '-': 189,
      '.': 190,
      '/': 191,
      '`': 192,
      '[': 219,
      '\\': 220,
      ']': 221,
      "'": 222 // Helper aliases

    };
    var aliases = exports.aliases = {
      'windows': 91,
      '⇧': 16,
      '⌥': 18,
      '⌃': 17,
      '⌘': 91,
      'ctl': 17,
      'control': 17,
      'option': 18,
      'pause': 19,
      'break': 19,
      'caps': 20,
      'return': 13,
      'escape': 27,
      'spc': 32,
      'spacebar': 32,
      'pgup': 33,
      'pgdn': 34,
      'ins': 45,
      'del': 46,
      'cmd': 91
      /*!
       * Programatically add the following
       */
      // lower case chars

    };

    for (i = 97; i < 123; i++) {
      codes[String.fromCharCode(i)] = i - 32;
    } // numbers


    for (var i = 48; i < 58; i++) {
      codes[i - 48] = i;
    } // function keys


    for (i = 1; i < 13; i++) {
      codes['f' + i] = i + 111;
    } // numpad keys


    for (i = 0; i < 10; i++) {
      codes['numpad ' + i] = i + 96;
    }
    /**
     * Get by code
     *
     *   exports.name[13] // => 'Enter'
     */


    var names = exports.names = exports.title = {}; // title for backward compat
    // Create reverse mapping

    for (i in codes) {
      names[codes[i]] = i;
    } // Add aliases


    for (var alias in aliases) {
      codes[alias] = aliases[alias];
    }
  });
  var keycode_1 = keycode.code;
  var keycode_2 = keycode.codes;
  var keycode_3 = keycode.aliases;
  var keycode_4 = keycode.names;
  var keycode_5 = keycode.title;

  /** PURE_IMPORTS_START  PURE_IMPORTS_END */
  var nextHandle = 0;
  var tasksByHandle = {};

  function runIfPresent(handle) {
    var cb = tasksByHandle[handle];

    if (cb) {
      cb();
    }
  }

  var Immediate$2 = {
    setImmediate: function setImmediate(cb) {
      var handle = nextHandle++;
      tasksByHandle[handle] = cb;
      Promise.resolve().then(function () {
        return runIfPresent(handle);
      });
      return handle;
    },
    clearImmediate: function clearImmediate(handle) {
      delete tasksByHandle[handle];
    }
  };

  /** PURE_IMPORTS_START tslib,.._util_Immediate,._AsyncAction PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */

  var AsapAction$1 =
  /*@__PURE__*/
  function (_super) {
    __extends(AsapAction, _super);

    function AsapAction(scheduler, work) {
      var _this = _super.call(this, scheduler, work) || this;

      _this.scheduler = scheduler;
      _this.work = work;
      return _this;
    }

    AsapAction.prototype.requestAsyncId = function (scheduler, id, delay) {
      if (delay === void 0) {
        delay = 0;
      } // If delay is greater than 0, request as an async action.


      if (delay !== null && delay > 0) {
        return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
      } // Push the action to the end of the scheduler queue.


      scheduler.actions.push(this); // If a microtask has already been scheduled, don't schedule another
      // one. If a microtask hasn't been scheduled yet, schedule one now. Return
      // the current scheduled microtask id.

      return scheduler.scheduled || (scheduler.scheduled = Immediate$2.setImmediate(scheduler.flush.bind(scheduler, null)));
    };

    AsapAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
      if (delay === void 0) {
        delay = 0;
      } // If delay exists and is greater than 0, or if the delay is null (the
      // action wasn't rescheduled) but was originally scheduled as an async
      // action, then recycle as an async action.


      if (delay !== null && delay > 0 || delay === null && this.delay > 0) {
        return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
      } // If the scheduler queue is empty, cancel the requested microtask and
      // set the scheduled flag to undefined so the next AsapAction will schedule
      // its own.


      if (scheduler.actions.length === 0) {
        Immediate$2.clearImmediate(id);
        scheduler.scheduled = undefined;
      } // Return undefined so the action knows to request a new async id if it's rescheduled.


      return undefined;
    };

    return AsapAction;
  }(AsyncAction);

  /** PURE_IMPORTS_START tslib,._AsyncScheduler PURE_IMPORTS_END */

  var AsapScheduler$1 =
  /*@__PURE__*/
  function (_super) {
    __extends(AsapScheduler, _super);

    function AsapScheduler() {
      return _super !== null && _super.apply(this, arguments) || this;
    }

    AsapScheduler.prototype.flush = function (action) {
      this.active = true;
      this.scheduled = undefined;
      var actions = this.actions;
      var error;
      var index = -1;
      var count = actions.length;
      action = action || actions.shift();

      do {
        if (error = action.execute(action.state, action.delay)) {
          break;
        }
      } while (++index < count && (action = actions.shift()));

      this.active = false;

      if (error) {
        while (++index < count && (action = actions.shift())) {
          action.unsubscribe();
        }

        throw error;
      }
    };

    return AsapScheduler;
  }(AsyncScheduler);

  /** PURE_IMPORTS_START ._AsapAction,._AsapScheduler PURE_IMPORTS_END */
  /**
   *
   * Asap Scheduler
   *
   * <span class="informal">Perform task as fast as it can be performed asynchronously</span>
   *
   * `asap` scheduler behaves the same as {@link async} scheduler when you use it to delay task
   * in time. If however you set delay to `0`, `asap` will wait for current synchronously executing
   * code to end and then it will try to execute given task as fast as possible.
   *
   * `asap` scheduler will do its best to minimize time between end of currently executing code
   * and start of scheduled task. This makes it best candidate for performing so called "deferring".
   * Traditionally this was achieved by calling `setTimeout(deferredTask, 0)`, but that technique involves
   * some (although minimal) unwanted delay.
   *
   * Note that using `asap` scheduler does not necessarily mean that your task will be first to process
   * after currently executing code. In particular, if some task was also scheduled with `asap` before,
   * that task will execute first. That being said, if you need to schedule task asynchronously, but
   * as soon as possible, `asap` scheduler is your best bet.
   *
   * @example <caption>Compare async and asap scheduler</caption>
   *
   * Rx.Scheduler.async.schedule(() => console.log('async')); // scheduling 'async' first...
   * Rx.Scheduler.asap.schedule(() => console.log('asap'));
   *
   * // Logs:
   * // "asap"
   * // "async"
   * // ... but 'asap' goes first!
   *
   * @static true
   * @name asap
   * @owner Scheduler
   */

  var asap$2 =
  /*@__PURE__*/
  new AsapScheduler$1(AsapAction$1);

  /** PURE_IMPORTS_START tslib,._AsyncAction PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */

  var AnimationFrameAction$1 =
  /*@__PURE__*/
  function (_super) {
    __extends(AnimationFrameAction, _super);

    function AnimationFrameAction(scheduler, work) {
      var _this = _super.call(this, scheduler, work) || this;

      _this.scheduler = scheduler;
      _this.work = work;
      return _this;
    }

    AnimationFrameAction.prototype.requestAsyncId = function (scheduler, id, delay) {
      if (delay === void 0) {
        delay = 0;
      } // If delay is greater than 0, request as an async action.


      if (delay !== null && delay > 0) {
        return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
      } // Push the action to the end of the scheduler queue.


      scheduler.actions.push(this); // If an animation frame has already been requested, don't request another
      // one. If an animation frame hasn't been requested yet, request one. Return
      // the current animation frame request id.

      return scheduler.scheduled || (scheduler.scheduled = requestAnimationFrame(function () {
        return scheduler.flush(null);
      }));
    };

    AnimationFrameAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
      if (delay === void 0) {
        delay = 0;
      } // If delay exists and is greater than 0, or if the delay is null (the
      // action wasn't rescheduled) but was originally scheduled as an async
      // action, then recycle as an async action.


      if (delay !== null && delay > 0 || delay === null && this.delay > 0) {
        return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
      } // If the scheduler queue is empty, cancel the requested animation frame and
      // set the scheduled flag to undefined so the next AnimationFrameAction will
      // request its own.


      if (scheduler.actions.length === 0) {
        cancelAnimationFrame(id);
        scheduler.scheduled = undefined;
      } // Return undefined so the action knows to request a new async id if it's rescheduled.


      return undefined;
    };

    return AnimationFrameAction;
  }(AsyncAction);

  /** PURE_IMPORTS_START tslib,._AsyncScheduler PURE_IMPORTS_END */

  var AnimationFrameScheduler$1 =
  /*@__PURE__*/
  function (_super) {
    __extends(AnimationFrameScheduler, _super);

    function AnimationFrameScheduler() {
      return _super !== null && _super.apply(this, arguments) || this;
    }

    AnimationFrameScheduler.prototype.flush = function (action) {
      this.active = true;
      this.scheduled = undefined;
      var actions = this.actions;
      var error;
      var index = -1;
      var count = actions.length;
      action = action || actions.shift();

      do {
        if (error = action.execute(action.state, action.delay)) {
          break;
        }
      } while (++index < count && (action = actions.shift()));

      this.active = false;

      if (error) {
        while (++index < count && (action = actions.shift())) {
          action.unsubscribe();
        }

        throw error;
      }
    };

    return AnimationFrameScheduler;
  }(AsyncScheduler);

  /** PURE_IMPORTS_START ._AnimationFrameAction,._AnimationFrameScheduler PURE_IMPORTS_END */
  /**
   *
   * Animation Frame Scheduler
   *
   * <span class="informal">Perform task when `window.requestAnimationFrame` would fire</span>
   *
   * When `animationFrame` scheduler is used with delay, it will fall back to {@link async} scheduler
   * behaviour.
   *
   * Without delay, `animationFrame` scheduler can be used to create smooth browser animations.
   * It makes sure scheduled task will happen just before next browser content repaint,
   * thus performing animations as efficiently as possible.
   *
   * @example <caption>Schedule div height animation</caption>
   * const div = document.querySelector('.some-div');
   *
   * Rx.Scheduler.animationFrame.schedule(function(height) {
   *   div.style.height = height + "px";
   *
   *   this.schedule(height + 1);  // `this` references currently executing Action,
   *                               // which we reschedule with new state
   * }, 0, 0);
   *
   * // You will see .some-div element growing in height
   *
   *
   * @static true
   * @name animationFrame
   * @owner Scheduler
   */

  var animationFrame$2 =
  /*@__PURE__*/
  new AnimationFrameScheduler$1(AnimationFrameAction$1);

  var VirtualTimeScheduler$1 =
  /*@__PURE__*/
  function (_super) {
    __extends(VirtualTimeScheduler, _super);

    function VirtualTimeScheduler(SchedulerAction, maxFrames) {
      if (SchedulerAction === void 0) {
        SchedulerAction = VirtualAction;
      }

      if (maxFrames === void 0) {
        maxFrames = Number.POSITIVE_INFINITY;
      }

      var _this = _super.call(this, SchedulerAction, function () {
        return _this.frame;
      }) || this;

      _this.maxFrames = maxFrames;
      _this.frame = 0;
      _this.index = -1;
      return _this;
    }
    /**
     * Prompt the Scheduler to execute all of its queued actions, therefore
     * clearing its queue.
     * @return {void}
     */


    VirtualTimeScheduler.prototype.flush = function () {
      var _a = this,
          actions = _a.actions,
          maxFrames = _a.maxFrames;

      var error, action;

      while ((action = actions.shift()) && (this.frame = action.delay) <= maxFrames) {
        if (error = action.execute(action.state, action.delay)) {
          break;
        }
      }

      if (error) {
        while (action = actions.shift()) {
          action.unsubscribe();
        }

        throw error;
      }
    };

    VirtualTimeScheduler.frameTimeFactor = 10;
    return VirtualTimeScheduler;
  }(AsyncScheduler);
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */

  var VirtualAction =
  /*@__PURE__*/
  function (_super) {
    __extends(VirtualAction, _super);

    function VirtualAction(scheduler, work, index) {
      if (index === void 0) {
        index = scheduler.index += 1;
      }

      var _this = _super.call(this, scheduler, work) || this;

      _this.scheduler = scheduler;
      _this.work = work;
      _this.index = index;
      _this.active = true;
      _this.index = scheduler.index = index;
      return _this;
    }

    VirtualAction.prototype.schedule = function (state, delay) {
      if (delay === void 0) {
        delay = 0;
      }

      if (!this.id) {
        return _super.prototype.schedule.call(this, state, delay);
      }

      this.active = false; // If an action is rescheduled, we save allocations by mutating its state,
      // pushing it to the end of the scheduler queue, and recycling the action.
      // But since the VirtualTimeScheduler is used for testing, VirtualActions
      // must be immutable so they can be inspected later.

      var action = new VirtualAction(this.scheduler, this.work);
      this.add(action);
      return action.schedule(state, delay);
    };

    VirtualAction.prototype.requestAsyncId = function (scheduler, id, delay) {
      if (delay === void 0) {
        delay = 0;
      }

      this.delay = scheduler.frame + delay;
      var actions = scheduler.actions;
      actions.push(this);
      actions.sort(VirtualAction.sortActions);
      return true;
    };

    VirtualAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
      if (delay === void 0) {
        delay = 0;
      }

      return undefined;
    };

    VirtualAction.prototype._execute = function (state, delay) {
      if (this.active === true) {
        return _super.prototype._execute.call(this, state, delay);
      }
    };

    VirtualAction.sortActions = function (a, b) {
      if (a.delay === b.delay) {
        if (a.index === b.index) {
          return 0;
        } else if (a.index > b.index) {
          return 1;
        } else {
          return -1;
        }
      } else if (a.delay > b.delay) {
        return 1;
      } else {
        return -1;
      }
    };

    return VirtualAction;
  }(AsyncAction);

  /** PURE_IMPORTS_START .._Observable,.._AsyncSubject PURE_IMPORTS_END */

  /** PURE_IMPORTS_START .._Observable,.._AsyncSubject PURE_IMPORTS_END */

  /** PURE_IMPORTS_START .._Observable,._from,._empty PURE_IMPORTS_END */

  /** PURE_IMPORTS_START tslib,.._Observable,.._util_isArray,._empty,.._util_subscribeToResult,.._OuterSubscriber PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */

  var ForkJoinSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(ForkJoinSubscriber, _super);

    function ForkJoinSubscriber(destination, sources) {
      var _this = _super.call(this, destination) || this;

      _this.sources = sources;
      _this.completed = 0;
      _this.haveValues = 0;
      var len = sources.length;
      _this.values = new Array(len);

      for (var i = 0; i < len; i++) {
        var source = sources[i];
        var innerSubscription = subscribeToResult(_this, source, null, i);

        if (innerSubscription) {
          _this.add(innerSubscription);
        }
      }

      return _this;
    }

    ForkJoinSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
      this.values[outerIndex] = innerValue;

      if (!innerSub._hasValue) {
        innerSub._hasValue = true;
        this.haveValues++;
      }
    };

    ForkJoinSubscriber.prototype.notifyComplete = function (innerSub) {
      var _a = this,
          destination = _a.destination,
          haveValues = _a.haveValues,
          values = _a.values;

      var len = values.length;

      if (!innerSub._hasValue) {
        destination.complete();
        return;
      }

      this.completed++;

      if (this.completed !== len) {
        return;
      }

      if (haveValues === len) {
        destination.next(values);
      }

      destination.complete();
    };

    return ForkJoinSubscriber;
  }(OuterSubscriber);

  /** PURE_IMPORTS_START .._Observable PURE_IMPORTS_END */
  var toString$2 = Object.prototype.toString;
  /* tslint:enable:max-line-length */

  /**
   * Creates an Observable that emits events of a specific type coming from the
   * given event target.
   *
   * <span class="informal">Creates an Observable from DOM events, or Node.js
   * EventEmitter events or others.</span>
   *
   * <img src="./img/fromEvent.png" width="100%">
   *
   * `fromEvent` accepts as a first argument event target, which is an object with methods
   * for registering event handler functions. As a second argument it takes string that indicates
   * type of event we want to listen for. `fromEvent` supports selected types of event targets,
   * which are described in detail below. If your event target does not match any of the ones listed,
   * you should use {@link fromEventPattern}, which can be used on arbitrary APIs.
   * When it comes to APIs supported by `fromEvent`, their methods for adding and removing event
   * handler functions have different names, but they all accept a string describing event type
   * and function itself, which will be called whenever said event happens.
   *
   * Every time resulting Observable is subscribed, event handler function will be registered
   * to event target on given event type. When that event fires, value
   * passed as a first argument to registered function will be emitted by output Observable.
   * When Observable is unsubscribed, function will be unregistered from event target.
   *
   * Note that if event target calls registered function with more than one argument, second
   * and following arguments will not appear in resulting stream. In order to get access to them,
   * you can pass to `fromEvent` optional project function, which will be called with all arguments
   * passed to event handler. Output Observable will then emit value returned by project function,
   * instead of the usual value.
   *
   * Remember that event targets listed below are checked via duck typing. It means that
   * no matter what kind of object you have and no matter what environment you work in,
   * you can safely use `fromEvent` on that object if it exposes described methods (provided
   * of course they behave as was described above). So for example if Node.js library exposes
   * event target which has the same method names as DOM EventTarget, `fromEvent` is still
   * a good choice.
   *
   * If the API you use is more callback then event handler oriented (subscribed
   * callback function fires only once and thus there is no need to manually
   * unregister it), you should use {@link bindCallback} or {@link bindNodeCallback}
   * instead.
   *
   * `fromEvent` supports following types of event targets:
   *
   * **DOM EventTarget**
   *
   * This is an object with `addEventListener` and `removeEventListener` methods.
   *
   * In the browser, `addEventListener` accepts - apart from event type string and event
   * handler function arguments - optional third parameter, which is either an object or boolean,
   * both used for additional configuration how and when passed function will be called. When
   * `fromEvent` is used with event target of that type, you can provide this values
   * as third parameter as well.
   *
   * **Node.js EventEmitter**
   *
   * An object with `addListener` and `removeListener` methods.
   *
   * **JQuery-style event target**
   *
   * An object with `on` and `off` methods
   *
   * **DOM NodeList**
   *
   * List of DOM Nodes, returned for example by `document.querySelectorAll` or `Node.childNodes`.
   *
   * Although this collection is not event target in itself, `fromEvent` will iterate over all Nodes
   * it contains and install event handler function in every of them. When returned Observable
   * is unsubscribed, function will be removed from all Nodes.
   *
   * **DOM HtmlCollection**
   *
   * Just as in case of NodeList it is a collection of DOM nodes. Here as well event handler function is
   * installed and removed in each of elements.
   *
   *
   * @example <caption>Emits clicks happening on the DOM document</caption>
   * var clicks = fromEvent(document, 'click');
   * clicks.subscribe(x => console.log(x));
   *
   * // Results in:
   * // MouseEvent object logged to console every time a click
   * // occurs on the document.
   *
   *
   * @example <caption>Use addEventListener with capture option</caption>
   * var clicksInDocument = fromEvent(document, 'click', true); // note optional configuration parameter
   *                                                                          // which will be passed to addEventListener
   * var clicksInDiv = fromEvent(someDivInDocument, 'click');
   *
   * clicksInDocument.subscribe(() => console.log('document'));
   * clicksInDiv.subscribe(() => console.log('div'));
   *
   * // By default events bubble UP in DOM tree, so normally
   * // when we would click on div in document
   * // "div" would be logged first and then "document".
   * // Since we specified optional `capture` option, document
   * // will catch event when it goes DOWN DOM tree, so console
   * // will log "document" and then "div".
   *
   * @see {@link bindCallback}
   * @see {@link bindNodeCallback}
   * @see {@link fromEventPattern}
   *
   * @param {EventTargetLike} target The DOM EventTarget, Node.js
   * EventEmitter, JQuery-like event target, NodeList or HTMLCollection to attach the event handler to.
   * @param {string} eventName The event name of interest, being emitted by the
   * `target`.
   * @param {EventListenerOptions} [options] Options to pass through to addEventListener
   * @return {Observable<T>}
   * @name fromEvent
   */

  function fromEvent$1(target, eventName, options) {
    return new Observable(function (subscriber) {
      function handler(e) {
        if (arguments.length > 1) {
          subscriber.next(Array.prototype.slice.call(arguments));
        } else {
          subscriber.next(e);
        }
      }

      setupSubscription(target, eventName, handler, subscriber, options);
    });
  }

  function setupSubscription(sourceObj, eventName, handler, subscriber, options) {
    var unsubscribe;

    if (isNodeList(sourceObj) || isHTMLCollection(sourceObj)) {
      for (var i = 0, len = sourceObj.length; i < len; i++) {
        setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
      }
    } else if (isEventTarget(sourceObj)) {
      var source_1 = sourceObj;
      sourceObj.addEventListener(eventName, handler, options);

      unsubscribe = function unsubscribe() {
        return source_1.removeEventListener(eventName, handler, options);
      };
    } else if (isJQueryStyleEventEmitter(sourceObj)) {
      var source_2 = sourceObj;
      sourceObj.on(eventName, handler);

      unsubscribe = function unsubscribe() {
        return source_2.off(eventName, handler);
      };
    } else if (isNodeStyleEventEmitter(sourceObj)) {
      var source_3 = sourceObj;
      sourceObj.addListener(eventName, handler);

      unsubscribe = function unsubscribe() {
        return source_3.removeListener(eventName, handler);
      };
    } else {
      throw new TypeError('Invalid event target');
    }

    subscriber.add(unsubscribe);
  }

  function isNodeStyleEventEmitter(sourceObj) {
    return !!sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';
  }

  function isJQueryStyleEventEmitter(sourceObj) {
    return !!sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';
  }

  function isNodeList(sourceObj) {
    return !!sourceObj && toString$2.call(sourceObj) === '[object NodeList]';
  }

  function isHTMLCollection(sourceObj) {
    return !!sourceObj && toString$2.call(sourceObj) === '[object HTMLCollection]';
  }

  function isEventTarget(sourceObj) {
    return !!sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';
  }

  /** PURE_IMPORTS_START .._Observable,.._util_isFunction PURE_IMPORTS_END */

  /** PURE_IMPORTS_START .._Observable,.._util_identity,.._util_isScheduler PURE_IMPORTS_END */

  /** PURE_IMPORTS_START ._defer,._empty PURE_IMPORTS_END */

  /** PURE_IMPORTS_START .._Observable,.._scheduler_async,.._util_isNumeric PURE_IMPORTS_END */

  /** PURE_IMPORTS_START .._Observable,.._util_isScheduler,.._.._internal_operators_mergeAll,._fromArray PURE_IMPORTS_END */
  /* tslint:enable:max-line-length */

  /**
   * Creates an output Observable which concurrently emits all values from every
   * given input Observable.
   *
   * <span class="informal">Flattens multiple Observables together by blending
   * their values into one Observable.</span>
   *
   * <img src="./img/merge.png" width="100%">
   *
   * `merge` subscribes to each given input Observable (as arguments), and simply
   * forwards (without doing any transformation) all the values from all the input
   * Observables to the output Observable. The output Observable only completes
   * once all input Observables have completed. Any error delivered by an input
   * Observable will be immediately emitted on the output Observable.
   *
   * @example <caption>Merge together two Observables: 1s interval and clicks</caption>
   * var clicks = Rx.Observable.fromEvent(document, 'click');
   * var timer = Rx.Observable.interval(1000);
   * var clicksOrTimer = Rx.Observable.merge(clicks, timer);
   * clicksOrTimer.subscribe(x => console.log(x));
   *
   * // Results in the following:
   * // timer will emit ascending values, one every second(1000ms) to console
   * // clicks logs MouseEvents to console everytime the "document" is clicked
   * // Since the two streams are merged you see these happening
   * // as they occur.
   *
   * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>
   * var timer1 = Rx.Observable.interval(1000).take(10);
   * var timer2 = Rx.Observable.interval(2000).take(6);
   * var timer3 = Rx.Observable.interval(500).take(10);
   * var concurrent = 2; // the argument
   * var merged = Rx.Observable.merge(timer1, timer2, timer3, concurrent);
   * merged.subscribe(x => console.log(x));
   *
   * // Results in the following:
   * // - First timer1 and timer2 will run concurrently
   * // - timer1 will emit a value every 1000ms for 10 iterations
   * // - timer2 will emit a value every 2000ms for 6 iterations
   * // - after timer1 hits it's max iteration, timer2 will
   * //   continue, and timer3 will start to run concurrently with timer2
   * // - when timer2 hits it's max iteration it terminates, and
   * //   timer3 will continue to emit a value every 500ms until it is complete
   *
   * @see {@link mergeAll}
   * @see {@link mergeMap}
   * @see {@link mergeMapTo}
   * @see {@link mergeScan}
   *
   * @param {...ObservableInput} observables Input Observables to merge together.
   * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
   * Observables being subscribed to concurrently.
   * @param {Scheduler} [scheduler=null] The IScheduler to use for managing
   * concurrency of input Observables.
   * @return {Observable} an Observable that emits items that are the result of
   * every input Observable.
   * @static true
   * @name merge
   * @owner Observable
   */

  function merge$1() {
    var observables = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      observables[_i] = arguments[_i];
    }

    var concurrent = Number.POSITIVE_INFINITY;
    var scheduler = null;
    var last = observables[observables.length - 1];

    if (isScheduler(last)) {
      scheduler = observables.pop();

      if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
        concurrent = observables.pop();
      }
    } else if (typeof last === 'number') {
      concurrent = observables.pop();
    }

    if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable) {
      return observables[0];
    }

    return mergeAll(concurrent)(fromArray(observables, scheduler));
  }

  /** PURE_IMPORTS_START .._Observable,._from,.._util_isArray,._empty PURE_IMPORTS_END */

  /** PURE_IMPORTS_START .._Observable,.._Subscription PURE_IMPORTS_END */

  /** PURE_IMPORTS_START tslib,.._util_isArray,._fromArray,.._OuterSubscriber,.._util_subscribeToResult PURE_IMPORTS_END */
  /**
   * We need this JSDoc comment for affecting ESDoc.
   * @ignore
   * @extends {Ignored}
   */

  var RaceSubscriber =
  /*@__PURE__*/
  function (_super) {
    __extends(RaceSubscriber, _super);

    function RaceSubscriber(destination) {
      var _this = _super.call(this, destination) || this;

      _this.hasFirst = false;
      _this.observables = [];
      _this.subscriptions = [];
      return _this;
    }

    RaceSubscriber.prototype._next = function (observable) {
      this.observables.push(observable);
    };

    RaceSubscriber.prototype._complete = function () {
      var observables = this.observables;
      var len = observables.length;

      if (len === 0) {
        this.destination.complete();
      } else {
        for (var i = 0; i < len && !this.hasFirst; i++) {
          var observable = observables[i];
          var subscription = subscribeToResult(this, observable, observable, i);

          if (this.subscriptions) {
            this.subscriptions.push(subscription);
          }

          this.add(subscription);
        }

        this.observables = null;
      }
    };

    RaceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
      if (!this.hasFirst) {
        this.hasFirst = true;

        for (var i = 0; i < this.subscriptions.length; i++) {
          if (i !== outerIndex) {
            var subscription = this.subscriptions[i];
            subscription.unsubscribe();
            this.remove(subscription);
          }
        }

        this.subscriptions = null;
      }

      this.destination.next(innerValue);
    };

    return RaceSubscriber;
  }(OuterSubscriber);

  /** PURE_IMPORTS_START .._Observable PURE_IMPORTS_END */

  /** PURE_IMPORTS_START .._Observable,._from,._empty PURE_IMPORTS_END */

  /** PURE_IMPORTS_START .._Observable,.._util_noop PURE_IMPORTS_END */

  /* Observable */

  var KEY_DOWN$ = fromEvent$1(document, 'keydown');

  function keyCodeIs(keyCode) {
    return function (event) {
      return event.keyCode === keyCode;
    };
  }
  function keydown(charKey) {
    var keyCode = typeof charKey === 'string' ? keycode(charKey) : charKey;
    return KEY_DOWN$.pipe(filter(keyCodeIs(keyCode)), tap(function (e) {
      return e.preventDefault();
    }));
  }
  function resize() {
    return fromEvent$1(window, 'resize');
  }
  function hashchange() {
    return fromEvent$1(window, 'hashchange');
  }
  function scroll() {
    return fromEvent$1(window, 'scroll');
  }

  var ResponsiveRatio;

  (function (ResponsiveRatio) {
    ResponsiveRatio["NORMAL"] = "4:3";
    ResponsiveRatio["WIDE"] = "16:9";
  })(ResponsiveRatio || (ResponsiveRatio = {}));

  function initResponsive(_ref) {
    var samplingElement = _ref.samplingElement,
        resizeObservable$ = _ref.resizeObservable$,
        ratio = _ref.ratio;

    if (samplingElement == null) {
      throw new Error('oops, `samplingElement` must not to be null');
    }

    var trigger$ = new BehaviorSubject({});
    resizeObservable$.subscribe(trigger$);
    var width = ratio === ResponsiveRatio.NORMAL ? 1024 : 1366;
    var height = 768;
    var hRatio$ = trigger$.pipe(map(horizontalRatioOf(width)));
    var vRatio$ = trigger$.pipe(map(verticalRatioOf(height)));
    var currentRatio$ = combineLatest(hRatio$, vRatio$).pipe(map(function (hv) {
      return Math.min(hv[0], hv[1]);
    }));
    var style = document.createElement('style');
    style.innerHTML = `
    tk-slide {
      --talkie-slide-width: ${width}px;
      --talkie-slide-height: ${height}px;
      --talkie-slide-scale: scale(1);
      --talkie-slide-top: 0;
      --talkie-slide-left: 0;
    }
  `;
    document.head.appendChild(style);
    currentRatio$.subscribe(function (ratio) {
      style.innerHTML = style.innerHTML.replace(/--talkie-slide-scale: scale\(.+\);/, `--talkie-slide-scale: scale(${Math.abs(ratio)});`);
      var rect = samplingElement.getBoundingClientRect();
      style.innerHTML = style.innerHTML.replace(/--talkie-slide-top: .+;/, `--talkie-slide-top: ${(window.innerHeight - rect.height) / 2}px;`).replace(/--talkie-slide-left: .+;/, `--talkie-slide-left: ${(window.innerWidth - rect.width) / 2}px;`);
    });
  }

  function horizontalRatioOf(width) {
    return function () {
      return window.innerWidth / width;
    };
  }

  function verticalRatioOf(height) {
    return function () {
      return window.innerHeight / height;
    };
  }

  function initPaging(_ref) {
    var startPage = _ref.startPage,
        totalPage = _ref.totalPage;
    var nextTrigger = new Subject();
    var prevTrigger = new Subject();
    var moveTrigger = new Subject();
    var currentSubject = new BehaviorSubject(startPage);
    var currentPage$ = currentSubject.pipe(map(inRangeOf(1, totalPage)), distinctUntilChanged());
    var currentPercentage$ = currentPage$.pipe(map(percentOf(totalPage)));
    merge$1(nextTrigger.pipe(withLatestFrom(currentPage$, function (_, page) {
      return page;
    }), map(function (v) {
      return v + 1;
    })), prevTrigger.pipe(withLatestFrom(currentPage$, function (_, page) {
      return page;
    }), map(function (v) {
      return v - 1;
    })), moveTrigger.pipe(map(function (v) {
      return v;
    }
    /* noop */
    ))).subscribe(currentSubject);
    return {
      current$: currentPage$,
      percentage$: currentPercentage$,
      next: nextTrigger,
      prev: prevTrigger,
      move: moveTrigger
    };
  }

  function inRangeOf(min, max) {
    return function (z) {
      return Math.min(max, Math.max(z, min));
    };
  }

  function percentOf(max) {
    return function (current) {
      return 100 / max * current;
    };
  }

  /**
   * fullscreen
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Fullscreen_API
   */

  function initFullScreen() {
    var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document.documentElement;
    var fullScreen$ = new Subject();
    fullScreen$.subscribe(toggleScreenOf(target));
    return fullScreen$;
  }

  function toggleScreenOf(el) {
    var request, exit;
    var doc = document;

    if (el.requestFullscreen) {
      request = 'requestFullscreen';
    } else if (el.webkitRequestFullscreen) {
      request = 'webkitRequestFullscreen';
    } else if (el.mozRequestFullScreen) {
      request = 'mozRequestFullScreen';
    } else if (el.msRequestFullscreen) {
      request = 'msRequestFullscreen';
    }

    if (doc.exitFullscreen) {
      exit = 'exitFullscreen';
    } else if (doc.webkitExitFullscreen) {
      exit = 'webkitExitFullscreen';
    } else if (doc.mozCancelFullScreen) {
      exit = 'mozCancelFullScreen';
    } else if (doc.msExitFullscreen) {
      exit = 'msExitFullscreen';
    }

    return function () {
      if (!doc.fullscreenElement && !doc.mozFullScreenElement && !doc.webkitFullscreenElement && !doc.msFullscreenElement) {
        el[request]();
      } else {
        doc[exit]();
      }
    };
  }

  function getPageNumberFromHash() {
    return parseInt(location.hash.replace(/^#/, ''), 10) || 0;
  }

  function run$1() {
    customElements.define(TalkieBackface.ns, TalkieBackface);
    customElements.define(TalkiePager.ns, TalkiePager);
    customElements.define(TalkieProgress.ns, TalkieProgress);
    customElements.define(TalkieSlide.ns, TalkieSlide);
    /**
     * Elements
     */

    var pagerElement = document.querySelector('tk-pager');
    var progressElement = document.querySelector('tk-progress');
    var slideElements = Array.from(document.querySelectorAll('tk-slide'));
    slideElements.forEach(function (el, i) {
      return el.setAttribute('id', String(i + 1));
    });
    var startPage = getPageNumberFromHash() || 1;
    var totalPage = slideElements.length;
    /**
     * Responsive
     */

    initResponsive({
      samplingElement: slideElements[0].getLayoutElement(),
      resizeObservable$: resize(),
      ratio: ResponsiveRatio.NORMAL
    });
    /**
     * Paging controls
     */

    var _initPaging = initPaging({
      startPage: startPage,
      totalPage: totalPage
    }),
        prev = _initPaging.prev,
        next = _initPaging.next,
        move = _initPaging.move,
        current$ = _initPaging.current$,
        percentage$ = _initPaging.percentage$;

    var isKeyboardMove = false;
    current$.pipe(map(function (current) {
      return slideElements[current - 1];
    })).subscribe(function (currentSlideElement) {
      slideElements.forEach(function (el) {
        return el.toInvisible();
      });
      currentSlideElement.toVisible();

      if (isKeyboardMove) {
        currentSlideElement.scrollIntoView();
        isKeyboardMove = false;
      }
    }); // keyboard control

    rxjs_38(keydown('left'), keydown('up'), keydown('a')).subscribe(function () {
      isKeyboardMove = true;
      prev.next(); // lol
    });
    rxjs_38(keydown('right'), keydown('down'), keydown('s')).subscribe(function () {
      isKeyboardMove = true;
      next.next(); // oops
    }); /// hashchange -> page change

    hashchange().pipe(map(getPageNumberFromHash)).subscribe(move); // scroll change -> page change

    scroll().pipe(throttleTime(200)).subscribe(function () {
      var el = document.elementFromPoint(window.innerWidth / 2, window.innerHeight / 2);

      if (el = el.closest(TalkieSlide.ns)) {
        move.next(parseInt(el.getAttribute('id'), 10));
      }
    }); // pager

    if (pagerElement != null) {
      pagerElement.setAttribute(TalkiePagerAttributes.CURRENT, String(startPage));
      pagerElement.setAttribute(TalkiePagerAttributes.TOTAL, String(totalPage));
      current$.subscribe(function (current) {
        return pagerElement.setAttribute(TalkiePagerAttributes.CURRENT, String(current));
      });
    }

    if (progressElement != null) {
      percentage$.subscribe(function (percentage) {
        return progressElement.setAttribute(TalkieProgressAttributes.PROGRESS, String(percentage));
      });
    }
    /**
     * Full screeen mode
     */


    keydown('f').subscribe(initFullScreen());
  }

  var index$1 = {
    run: run$1
  };

  return index$1;

})));
//# sourceMappingURL=talkie.js.map
